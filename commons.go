// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/FlatFilers/flatfile-go/internal"
	time "time"
)

type ApiAction struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`
	// The text on the Button itself
	Label     string    `json:"label" url:"label"`
	Id        ActionId  `json:"id" url:"id"`
	TargetId  string    `json:"targetId" url:"targetId"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApiAction) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *ApiAction) GetOperation() *string {
	if a == nil {
		return nil
	}
	return a.Operation
}

func (a *ApiAction) GetMode() *ActionMode {
	if a == nil {
		return nil
	}
	return a.Mode
}

func (a *ApiAction) GetTooltip() *string {
	if a == nil {
		return nil
	}
	return a.Tooltip
}

func (a *ApiAction) GetMessages() []*ActionMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *ApiAction) GetType() *string {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *ApiAction) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *ApiAction) GetSchedule() *ActionSchedule {
	if a == nil {
		return nil
	}
	return a.Schedule
}

func (a *ApiAction) GetPrimary() *bool {
	if a == nil {
		return nil
	}
	return a.Primary
}

func (a *ApiAction) GetConfirm() *bool {
	if a == nil {
		return nil
	}
	return a.Confirm
}

func (a *ApiAction) GetIcon() *string {
	if a == nil {
		return nil
	}
	return a.Icon
}

func (a *ApiAction) GetRequireAllValid() *bool {
	if a == nil {
		return nil
	}
	return a.RequireAllValid
}

func (a *ApiAction) GetRequireSelection() *bool {
	if a == nil {
		return nil
	}
	return a.RequireSelection
}

func (a *ApiAction) GetInputForm() *InputForm {
	if a == nil {
		return nil
	}
	return a.InputForm
}

func (a *ApiAction) GetConstraints() []*ActionConstraint {
	if a == nil {
		return nil
	}
	return a.Constraints
}

func (a *ApiAction) GetMount() *ActionMount {
	if a == nil {
		return nil
	}
	return a.Mount
}

func (a *ApiAction) GetGuide() *Guide {
	if a == nil {
		return nil
	}
	return a.Guide
}

func (a *ApiAction) GetGuardrail() *Guardrail {
	if a == nil {
		return nil
	}
	return a.Guardrail
}

func (a *ApiAction) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *ApiAction) GetId() ActionId {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *ApiAction) GetTargetId() string {
	if a == nil {
		return ""
	}
	return a.TargetId
}

func (a *ApiAction) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *ApiAction) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *ApiAction) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiAction) UnmarshalJSON(data []byte) error {
	type embed ApiAction
	var unmarshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApiAction(unmarshaler.embed)
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiAction) MarshalJSON() ([]byte, error) {
	type embed ApiAction
	var marshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*a),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ApiAction) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiActionConfig struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`
	// The text on the Button itself
	Label    string `json:"label" url:"label"`
	TargetId string `json:"targetId" url:"targetId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApiActionConfig) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *ApiActionConfig) GetOperation() *string {
	if a == nil {
		return nil
	}
	return a.Operation
}

func (a *ApiActionConfig) GetMode() *ActionMode {
	if a == nil {
		return nil
	}
	return a.Mode
}

func (a *ApiActionConfig) GetTooltip() *string {
	if a == nil {
		return nil
	}
	return a.Tooltip
}

func (a *ApiActionConfig) GetMessages() []*ActionMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *ApiActionConfig) GetType() *string {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *ApiActionConfig) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *ApiActionConfig) GetSchedule() *ActionSchedule {
	if a == nil {
		return nil
	}
	return a.Schedule
}

func (a *ApiActionConfig) GetPrimary() *bool {
	if a == nil {
		return nil
	}
	return a.Primary
}

func (a *ApiActionConfig) GetConfirm() *bool {
	if a == nil {
		return nil
	}
	return a.Confirm
}

func (a *ApiActionConfig) GetIcon() *string {
	if a == nil {
		return nil
	}
	return a.Icon
}

func (a *ApiActionConfig) GetRequireAllValid() *bool {
	if a == nil {
		return nil
	}
	return a.RequireAllValid
}

func (a *ApiActionConfig) GetRequireSelection() *bool {
	if a == nil {
		return nil
	}
	return a.RequireSelection
}

func (a *ApiActionConfig) GetInputForm() *InputForm {
	if a == nil {
		return nil
	}
	return a.InputForm
}

func (a *ApiActionConfig) GetConstraints() []*ActionConstraint {
	if a == nil {
		return nil
	}
	return a.Constraints
}

func (a *ApiActionConfig) GetMount() *ActionMount {
	if a == nil {
		return nil
	}
	return a.Mount
}

func (a *ApiActionConfig) GetGuide() *Guide {
	if a == nil {
		return nil
	}
	return a.Guide
}

func (a *ApiActionConfig) GetGuardrail() *Guardrail {
	if a == nil {
		return nil
	}
	return a.Guardrail
}

func (a *ApiActionConfig) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *ApiActionConfig) GetTargetId() string {
	if a == nil {
		return ""
	}
	return a.TargetId
}

func (a *ApiActionConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiActionConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiActionConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiActionConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiActionConfig) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Account ID
type AccountId = string

type Action struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`
	// The text on the Button itself
	Label string `json:"label" url:"label"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Action) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *Action) GetOperation() *string {
	if a == nil {
		return nil
	}
	return a.Operation
}

func (a *Action) GetMode() *ActionMode {
	if a == nil {
		return nil
	}
	return a.Mode
}

func (a *Action) GetTooltip() *string {
	if a == nil {
		return nil
	}
	return a.Tooltip
}

func (a *Action) GetMessages() []*ActionMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *Action) GetType() *string {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *Action) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *Action) GetSchedule() *ActionSchedule {
	if a == nil {
		return nil
	}
	return a.Schedule
}

func (a *Action) GetPrimary() *bool {
	if a == nil {
		return nil
	}
	return a.Primary
}

func (a *Action) GetConfirm() *bool {
	if a == nil {
		return nil
	}
	return a.Confirm
}

func (a *Action) GetIcon() *string {
	if a == nil {
		return nil
	}
	return a.Icon
}

func (a *Action) GetRequireAllValid() *bool {
	if a == nil {
		return nil
	}
	return a.RequireAllValid
}

func (a *Action) GetRequireSelection() *bool {
	if a == nil {
		return nil
	}
	return a.RequireSelection
}

func (a *Action) GetInputForm() *InputForm {
	if a == nil {
		return nil
	}
	return a.InputForm
}

func (a *Action) GetConstraints() []*ActionConstraint {
	if a == nil {
		return nil
	}
	return a.Constraints
}

func (a *Action) GetMount() *ActionMount {
	if a == nil {
		return nil
	}
	return a.Mount
}

func (a *Action) GetGuide() *Guide {
	if a == nil {
		return nil
	}
	return a.Guide
}

func (a *Action) GetGuardrail() *Guardrail {
	if a == nil {
		return nil
	}
	return a.Guardrail
}

func (a *Action) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *Action) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Action) UnmarshalJSON(data []byte) error {
	type unmarshaler Action
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Action(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Action) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionConstraint struct {
	Type             string
	HasAllValid      *ActionConstraintHasAllValid
	HasSelection     *ActionConstraintHasSelection
	HasData          *ActionConstraintHasData
	HasColumnEnabled *ActionConstraintHasColumnEnabled
}

func NewActionConstraintFromHasAllValid(value *ActionConstraintHasAllValid) *ActionConstraint {
	return &ActionConstraint{Type: "hasAllValid", HasAllValid: value}
}

func NewActionConstraintFromHasSelection(value *ActionConstraintHasSelection) *ActionConstraint {
	return &ActionConstraint{Type: "hasSelection", HasSelection: value}
}

func NewActionConstraintFromHasData(value *ActionConstraintHasData) *ActionConstraint {
	return &ActionConstraint{Type: "hasData", HasData: value}
}

func NewActionConstraintFromHasColumnEnabled(value *ActionConstraintHasColumnEnabled) *ActionConstraint {
	return &ActionConstraint{Type: "hasColumnEnabled", HasColumnEnabled: value}
}

func (a *ActionConstraint) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ActionConstraint) GetHasAllValid() *ActionConstraintHasAllValid {
	if a == nil {
		return nil
	}
	return a.HasAllValid
}

func (a *ActionConstraint) GetHasSelection() *ActionConstraintHasSelection {
	if a == nil {
		return nil
	}
	return a.HasSelection
}

func (a *ActionConstraint) GetHasData() *ActionConstraintHasData {
	if a == nil {
		return nil
	}
	return a.HasData
}

func (a *ActionConstraint) GetHasColumnEnabled() *ActionConstraintHasColumnEnabled {
	if a == nil {
		return nil
	}
	return a.HasColumnEnabled
}

func (a *ActionConstraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "hasAllValid":
		value := new(ActionConstraintHasAllValid)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasAllValid = value
	case "hasSelection":
		value := new(ActionConstraintHasSelection)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasSelection = value
	case "hasData":
		value := new(ActionConstraintHasData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasData = value
	case "hasColumnEnabled":
		value := new(ActionConstraintHasColumnEnabled)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasColumnEnabled = value
	}
	return nil
}

func (a ActionConstraint) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "hasAllValid":
		return internal.MarshalJSONWithExtraProperty(a.HasAllValid, "type", "hasAllValid")
	case "hasSelection":
		return internal.MarshalJSONWithExtraProperty(a.HasSelection, "type", "hasSelection")
	case "hasData":
		return internal.MarshalJSONWithExtraProperty(a.HasData, "type", "hasData")
	case "hasColumnEnabled":
		return internal.MarshalJSONWithExtraProperty(a.HasColumnEnabled, "type", "hasColumnEnabled")
	}
}

type ActionConstraintVisitor interface {
	VisitHasAllValid(*ActionConstraintHasAllValid) error
	VisitHasSelection(*ActionConstraintHasSelection) error
	VisitHasData(*ActionConstraintHasData) error
	VisitHasColumnEnabled(*ActionConstraintHasColumnEnabled) error
}

func (a *ActionConstraint) Accept(visitor ActionConstraintVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "hasAllValid":
		return visitor.VisitHasAllValid(a.HasAllValid)
	case "hasSelection":
		return visitor.VisitHasSelection(a.HasSelection)
	case "hasData":
		return visitor.VisitHasData(a.HasData)
	case "hasColumnEnabled":
		return visitor.VisitHasColumnEnabled(a.HasColumnEnabled)
	}
}

func (a *ActionConstraint) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.HasAllValid != nil {
		fields = append(fields, "hasAllValid")
	}
	if a.HasSelection != nil {
		fields = append(fields, "hasSelection")
	}
	if a.HasData != nil {
		fields = append(fields, "hasData")
	}
	if a.HasColumnEnabled != nil {
		fields = append(fields, "hasColumnEnabled")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

// This constraint requires that all records are valid before the action can be performed.
type ActionConstraintHasAllValid struct {
	IgnoreSelection *bool `json:"ignoreSelection,omitempty" url:"ignoreSelection,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionConstraintHasAllValid) GetIgnoreSelection() *bool {
	if a == nil {
		return nil
	}
	return a.IgnoreSelection
}

func (a *ActionConstraintHasAllValid) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasAllValid) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasAllValid
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasAllValid(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasAllValid) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This constraint requires the column to be enabled and not readonly before the action can be performed.
type ActionConstraintHasColumnEnabled struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionConstraintHasColumnEnabled) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasColumnEnabled) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasColumnEnabled
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasColumnEnabled(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasColumnEnabled) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This constraint requires that at least one record exists before the action can be performed.
type ActionConstraintHasData struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionConstraintHasData) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasData) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasData) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This constraint requires that at least one record is selected before the action can be performed.
type ActionConstraintHasSelection struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionConstraintHasSelection) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasSelection) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasSelection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasSelection(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasSelection) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Action ID
type ActionId = string

type ActionMessage struct {
	Type    ActionMessageType `json:"type" url:"type"`
	Content string            `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionMessage) GetType() ActionMessageType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ActionMessage) GetContent() string {
	if a == nil {
		return ""
	}
	return a.Content
}

func (a *ActionMessage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMessage) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionMessageType string

const (
	ActionMessageTypeError ActionMessageType = "error"
	ActionMessageTypeInfo  ActionMessageType = "info"
)

func NewActionMessageTypeFromString(s string) (ActionMessageType, error) {
	switch s {
	case "error":
		return ActionMessageTypeError, nil
	case "info":
		return ActionMessageTypeInfo, nil
	}
	var t ActionMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionMessageType) Ptr() *ActionMessageType {
	return &a
}

// Foreground actions will prevent interacting with the resource until complete
type ActionMode string

const (
	ActionModeForeground      ActionMode = "foreground"
	ActionModeBackground      ActionMode = "background"
	ActionModeToolbarBlocking ActionMode = "toolbarBlocking"
)

func NewActionModeFromString(s string) (ActionMode, error) {
	switch s {
	case "foreground":
		return ActionModeForeground, nil
	case "background":
		return ActionModeBackground, nil
	case "toolbarBlocking":
		return ActionModeToolbarBlocking, nil
	}
	var t ActionMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionMode) Ptr() *ActionMode {
	return &a
}

type ActionMount struct {
	Type     string
	Sheet    *ActionMountSheet
	Workbook *ActionMountWorkbook
	Field    *ActionMountField
	Document *ActionMountDocument
	File     *ActionMountFile
}

func NewActionMountFromSheet(value *ActionMountSheet) *ActionMount {
	return &ActionMount{Type: "sheet", Sheet: value}
}

func NewActionMountFromWorkbook(value *ActionMountWorkbook) *ActionMount {
	return &ActionMount{Type: "workbook", Workbook: value}
}

func NewActionMountFromField(value *ActionMountField) *ActionMount {
	return &ActionMount{Type: "field", Field: value}
}

func NewActionMountFromDocument(value *ActionMountDocument) *ActionMount {
	return &ActionMount{Type: "document", Document: value}
}

func NewActionMountFromFile(value *ActionMountFile) *ActionMount {
	return &ActionMount{Type: "file", File: value}
}

func (a *ActionMount) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ActionMount) GetSheet() *ActionMountSheet {
	if a == nil {
		return nil
	}
	return a.Sheet
}

func (a *ActionMount) GetWorkbook() *ActionMountWorkbook {
	if a == nil {
		return nil
	}
	return a.Workbook
}

func (a *ActionMount) GetField() *ActionMountField {
	if a == nil {
		return nil
	}
	return a.Field
}

func (a *ActionMount) GetDocument() *ActionMountDocument {
	if a == nil {
		return nil
	}
	return a.Document
}

func (a *ActionMount) GetFile() *ActionMountFile {
	if a == nil {
		return nil
	}
	return a.File
}

func (a *ActionMount) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "sheet":
		value := new(ActionMountSheet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Sheet = value
	case "workbook":
		value := new(ActionMountWorkbook)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Workbook = value
	case "field":
		value := new(ActionMountField)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Field = value
	case "document":
		value := new(ActionMountDocument)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Document = value
	case "file":
		value := new(ActionMountFile)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.File = value
	}
	return nil
}

func (a ActionMount) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "sheet":
		return internal.MarshalJSONWithExtraProperty(a.Sheet, "type", "sheet")
	case "workbook":
		return internal.MarshalJSONWithExtraProperty(a.Workbook, "type", "workbook")
	case "field":
		return internal.MarshalJSONWithExtraProperty(a.Field, "type", "field")
	case "document":
		return internal.MarshalJSONWithExtraProperty(a.Document, "type", "document")
	case "file":
		return internal.MarshalJSONWithExtraProperty(a.File, "type", "file")
	}
}

type ActionMountVisitor interface {
	VisitSheet(*ActionMountSheet) error
	VisitWorkbook(*ActionMountWorkbook) error
	VisitField(*ActionMountField) error
	VisitDocument(*ActionMountDocument) error
	VisitFile(*ActionMountFile) error
}

func (a *ActionMount) Accept(visitor ActionMountVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "sheet":
		return visitor.VisitSheet(a.Sheet)
	case "workbook":
		return visitor.VisitWorkbook(a.Workbook)
	case "field":
		return visitor.VisitField(a.Field)
	case "document":
		return visitor.VisitDocument(a.Document)
	case "file":
		return visitor.VisitFile(a.File)
	}
}

func (a *ActionMount) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Sheet != nil {
		fields = append(fields, "sheet")
	}
	if a.Workbook != nil {
		fields = append(fields, "workbook")
	}
	if a.Field != nil {
		fields = append(fields, "field")
	}
	if a.Document != nil {
		fields = append(fields, "document")
	}
	if a.File != nil {
		fields = append(fields, "file")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

// Used to mount this action on documents.
type ActionMountDocument struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionMountDocument) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountDocument) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Sheet Columns.
type ActionMountField struct {
	Keys []string `json:"keys,omitempty" url:"keys,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionMountField) GetKeys() []string {
	if a == nil {
		return nil
	}
	return a.Keys
}

func (a *ActionMountField) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountField) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountField) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on files.
type ActionMountFile struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionMountFile) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountFile) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountFile) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Sheets.
type ActionMountSheet struct {
	Slugs []string `json:"slugs,omitempty" url:"slugs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionMountSheet) GetSlugs() []string {
	if a == nil {
		return nil
	}
	return a.Slugs
}

func (a *ActionMountSheet) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountSheet) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountSheet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountSheet(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountSheet) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Workbooks.
type ActionMountWorkbook struct {
	Slugs []string `json:"slugs,omitempty" url:"slugs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionMountWorkbook) GetSlugs() []string {
	if a == nil {
		return nil
	}
	return a.Slugs
}

func (a *ActionMountWorkbook) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountWorkbook) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountWorkbook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountWorkbook(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountWorkbook) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionSchedule string

const (
	ActionScheduleWeekly ActionSchedule = "weekly"
	ActionScheduleDaily  ActionSchedule = "daily"
	ActionScheduleHourly ActionSchedule = "hourly"
)

func NewActionScheduleFromString(s string) (ActionSchedule, error) {
	switch s {
	case "weekly":
		return ActionScheduleWeekly, nil
	case "daily":
		return ActionScheduleDaily, nil
	case "hourly":
		return ActionScheduleHourly, nil
	}
	var t ActionSchedule
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionSchedule) Ptr() *ActionSchedule {
	return &a
}

type ActionUpdate struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`
	Label       *string             `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionUpdate) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *ActionUpdate) GetOperation() *string {
	if a == nil {
		return nil
	}
	return a.Operation
}

func (a *ActionUpdate) GetMode() *ActionMode {
	if a == nil {
		return nil
	}
	return a.Mode
}

func (a *ActionUpdate) GetTooltip() *string {
	if a == nil {
		return nil
	}
	return a.Tooltip
}

func (a *ActionUpdate) GetMessages() []*ActionMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *ActionUpdate) GetType() *string {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *ActionUpdate) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *ActionUpdate) GetSchedule() *ActionSchedule {
	if a == nil {
		return nil
	}
	return a.Schedule
}

func (a *ActionUpdate) GetPrimary() *bool {
	if a == nil {
		return nil
	}
	return a.Primary
}

func (a *ActionUpdate) GetConfirm() *bool {
	if a == nil {
		return nil
	}
	return a.Confirm
}

func (a *ActionUpdate) GetIcon() *string {
	if a == nil {
		return nil
	}
	return a.Icon
}

func (a *ActionUpdate) GetRequireAllValid() *bool {
	if a == nil {
		return nil
	}
	return a.RequireAllValid
}

func (a *ActionUpdate) GetRequireSelection() *bool {
	if a == nil {
		return nil
	}
	return a.RequireSelection
}

func (a *ActionUpdate) GetInputForm() *InputForm {
	if a == nil {
		return nil
	}
	return a.InputForm
}

func (a *ActionUpdate) GetConstraints() []*ActionConstraint {
	if a == nil {
		return nil
	}
	return a.Constraints
}

func (a *ActionUpdate) GetMount() *ActionMount {
	if a == nil {
		return nil
	}
	return a.Mount
}

func (a *ActionUpdate) GetGuide() *Guide {
	if a == nil {
		return nil
	}
	return a.Guide
}

func (a *ActionUpdate) GetGuardrail() *Guardrail {
	if a == nil {
		return nil
	}
	return a.Guardrail
}

func (a *ActionUpdate) GetLabel() *string {
	if a == nil {
		return nil
	}
	return a.Label
}

func (a *ActionUpdate) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionUpdate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionUpdate) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionWithoutLabel struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionWithoutLabel) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *ActionWithoutLabel) GetOperation() *string {
	if a == nil {
		return nil
	}
	return a.Operation
}

func (a *ActionWithoutLabel) GetMode() *ActionMode {
	if a == nil {
		return nil
	}
	return a.Mode
}

func (a *ActionWithoutLabel) GetTooltip() *string {
	if a == nil {
		return nil
	}
	return a.Tooltip
}

func (a *ActionWithoutLabel) GetMessages() []*ActionMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *ActionWithoutLabel) GetType() *string {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *ActionWithoutLabel) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *ActionWithoutLabel) GetSchedule() *ActionSchedule {
	if a == nil {
		return nil
	}
	return a.Schedule
}

func (a *ActionWithoutLabel) GetPrimary() *bool {
	if a == nil {
		return nil
	}
	return a.Primary
}

func (a *ActionWithoutLabel) GetConfirm() *bool {
	if a == nil {
		return nil
	}
	return a.Confirm
}

func (a *ActionWithoutLabel) GetIcon() *string {
	if a == nil {
		return nil
	}
	return a.Icon
}

func (a *ActionWithoutLabel) GetRequireAllValid() *bool {
	if a == nil {
		return nil
	}
	return a.RequireAllValid
}

func (a *ActionWithoutLabel) GetRequireSelection() *bool {
	if a == nil {
		return nil
	}
	return a.RequireSelection
}

func (a *ActionWithoutLabel) GetInputForm() *InputForm {
	if a == nil {
		return nil
	}
	return a.InputForm
}

func (a *ActionWithoutLabel) GetConstraints() []*ActionConstraint {
	if a == nil {
		return nil
	}
	return a.Constraints
}

func (a *ActionWithoutLabel) GetMount() *ActionMount {
	if a == nil {
		return nil
	}
	return a.Mount
}

func (a *ActionWithoutLabel) GetGuide() *Guide {
	if a == nil {
		return nil
	}
	return a.Guide
}

func (a *ActionWithoutLabel) GetGuardrail() *Guardrail {
	if a == nil {
		return nil
	}
	return a.Guardrail
}

func (a *ActionWithoutLabel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionWithoutLabel) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionWithoutLabel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionWithoutLabel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionWithoutLabel) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActorIdUnion struct {
	UserId  UserId
	AgentId AgentId
	GuestId GuestId

	typ string
}

func NewActorIdUnionFromUserId(value UserId) *ActorIdUnion {
	return &ActorIdUnion{typ: "UserId", UserId: value}
}

func NewActorIdUnionFromAgentId(value AgentId) *ActorIdUnion {
	return &ActorIdUnion{typ: "AgentId", AgentId: value}
}

func NewActorIdUnionFromGuestId(value GuestId) *ActorIdUnion {
	return &ActorIdUnion{typ: "GuestId", GuestId: value}
}

func (a *ActorIdUnion) GetUserId() UserId {
	if a == nil {
		return ""
	}
	return a.UserId
}

func (a *ActorIdUnion) GetAgentId() AgentId {
	if a == nil {
		return ""
	}
	return a.AgentId
}

func (a *ActorIdUnion) GetGuestId() GuestId {
	if a == nil {
		return ""
	}
	return a.GuestId
}

func (a *ActorIdUnion) UnmarshalJSON(data []byte) error {
	var valueUserId UserId
	if err := json.Unmarshal(data, &valueUserId); err == nil {
		a.typ = "UserId"
		a.UserId = valueUserId
		return nil
	}
	var valueAgentId AgentId
	if err := json.Unmarshal(data, &valueAgentId); err == nil {
		a.typ = "AgentId"
		a.AgentId = valueAgentId
		return nil
	}
	var valueGuestId GuestId
	if err := json.Unmarshal(data, &valueGuestId); err == nil {
		a.typ = "GuestId"
		a.GuestId = valueGuestId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActorIdUnion) MarshalJSON() ([]byte, error) {
	if a.typ == "UserId" || a.UserId != "" {
		return json.Marshal(a.UserId)
	}
	if a.typ == "AgentId" || a.AgentId != "" {
		return json.Marshal(a.AgentId)
	}
	if a.typ == "GuestId" || a.GuestId != "" {
		return json.Marshal(a.GuestId)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ActorIdUnionVisitor interface {
	VisitUserId(UserId) error
	VisitAgentId(AgentId) error
	VisitGuestId(GuestId) error
}

func (a *ActorIdUnion) Accept(visitor ActorIdUnionVisitor) error {
	if a.typ == "UserId" || a.UserId != "" {
		return visitor.VisitUserId(a.UserId)
	}
	if a.typ == "AgentId" || a.AgentId != "" {
		return visitor.VisitAgentId(a.AgentId)
	}
	if a.typ == "GuestId" || a.GuestId != "" {
		return visitor.VisitGuestId(a.GuestId)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// Actor Role ID
type ActorRoleId = string

// Agent ID
type AgentId = string

// Agent version ID
type AgentVersionId = string

// App ID
type AppId = string

// Commit ID
type CommitId = string

// Constraint ID
type ConstraintId = string

// Data Clip ID
type DataClipId = string

// Data Retention Policy ID
type DataRetentionPolicyId = string

// Document ID
type DocumentId = string

// Environment ID
type EnvironmentId = string

type Error struct {
	Key     *string `json:"key,omitempty" url:"key,omitempty"`
	Message string  `json:"message" url:"message"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Error) GetKey() *string {
	if e == nil {
		return nil
	}
	return e.Key
}

func (e *Error) GetMessage() string {
	if e == nil {
		return ""
	}
	return e.Message
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Errors struct {
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Errors) GetErrors() []*Error {
	if e == nil {
		return nil
	}
	return e.Errors
}

func (e *Errors) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Errors) UnmarshalJSON(data []byte) error {
	type unmarshaler Errors
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Errors(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Errors) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Event ID
type EventId = string

// Mapping Family ID
type FamilyId = string

// File ID
type FileId = string

// Options to filter records
type Filter string

const (
	FilterValid Filter = "valid"
	FilterError Filter = "error"
	FilterAll   Filter = "all"
	FilterNone  Filter = "none"
)

func NewFilterFromString(s string) (Filter, error) {
	switch s {
	case "valid":
		return FilterValid, nil
	case "error":
		return FilterError, nil
	case "all":
		return FilterAll, nil
	case "none":
		return FilterNone, nil
	}
	var t Filter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f Filter) Ptr() *Filter {
	return &f
}

// Use this to narrow the valid/error filter results to a specific field
type FilterField = string

type Guardrail struct {
	// Markdown guardrail for this action
	Content string `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *Guardrail) GetContent() string {
	if g == nil {
		return ""
	}
	return g.Content
}

func (g *Guardrail) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Guardrail) UnmarshalJSON(data []byte) error {
	type unmarshaler Guardrail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Guardrail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *Guardrail) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Guest ID
type GuestId = string

// Guidance ID
type GuidanceId = string

type Guide struct {
	// Markdown guidance for this action
	Content string `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *Guide) GetContent() string {
	if g == nil {
		return ""
	}
	return g.Content
}

func (g *Guide) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Guide) UnmarshalJSON(data []byte) error {
	type unmarshaler Guide
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Guide(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *Guide) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Guide ID
type GuideId = string

type InputConfig struct {
	Options []*InputEnumPropertyOption `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InputConfig) GetOptions() []*InputEnumPropertyOption {
	if i == nil {
		return nil
	}
	return i.Options
}

func (i *InputConfig) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler InputConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputConfig) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputConstraint struct {
	Type InputConstraintType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InputConstraint) GetType() InputConstraintType {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InputConstraint) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler InputConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputConstraint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputConstraint) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputConstraintType string

const (
	InputConstraintTypeRequired InputConstraintType = "required"
)

func NewInputConstraintTypeFromString(s string) (InputConstraintType, error) {
	switch s {
	case "required":
		return InputConstraintTypeRequired, nil
	}
	var t InputConstraintType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InputConstraintType) Ptr() *InputConstraintType {
	return &i
}

type InputEnumPropertyOption struct {
	// A visual label for this option, defaults to value if not provided
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// An optional color to assign this option
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// A reference pointer to a previously registered icon
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// An arbitrary JSON object to be associated with this option and made available to hooks
	Meta map[string]interface{} `json:"meta,omitempty" url:"meta,omitempty"`
	// The value or ID of this option. This value will be sent in egress. The type is a string | integer | boolean.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InputEnumPropertyOption) GetLabel() *string {
	if i == nil {
		return nil
	}
	return i.Label
}

func (i *InputEnumPropertyOption) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEnumPropertyOption) GetColor() *string {
	if i == nil {
		return nil
	}
	return i.Color
}

func (i *InputEnumPropertyOption) GetIcon() *string {
	if i == nil {
		return nil
	}
	return i.Icon
}

func (i *InputEnumPropertyOption) GetMeta() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.Meta
}

func (i *InputEnumPropertyOption) GetValue() interface{} {
	if i == nil {
		return nil
	}
	return i.Value
}

func (i *InputEnumPropertyOption) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputEnumPropertyOption) UnmarshalJSON(data []byte) error {
	type unmarshaler InputEnumPropertyOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputEnumPropertyOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputEnumPropertyOption) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputField struct {
	// Unique key for a Field.
	Key string `json:"key" url:"key"`
	// Visible name of a Field.
	Label string `json:"label" url:"label"`
	// Brief description below the name of the Field.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Field Types inform the user interface how to sort and display data.
	Type string `json:"type" url:"type"`
	// Default value for a Field.
	DefaultValue interface{} `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	// Additional configuration for enum Fields.
	Config *InputConfig `json:"config,omitempty" url:"config,omitempty"`
	// Indicate additional validations that will be applied to the Field.
	Constraints []*InputConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InputField) GetKey() string {
	if i == nil {
		return ""
	}
	return i.Key
}

func (i *InputField) GetLabel() string {
	if i == nil {
		return ""
	}
	return i.Label
}

func (i *InputField) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputField) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InputField) GetDefaultValue() interface{} {
	if i == nil {
		return nil
	}
	return i.DefaultValue
}

func (i *InputField) GetConfig() *InputConfig {
	if i == nil {
		return nil
	}
	return i.Config
}

func (i *InputField) GetConstraints() []*InputConstraint {
	if i == nil {
		return nil
	}
	return i.Constraints
}

func (i *InputField) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputField) UnmarshalJSON(data []byte) error {
	type unmarshaler InputField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputField) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputForm struct {
	Type   InputFormType `json:"type" url:"type"`
	Fields []*InputField `json:"fields,omitempty" url:"fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InputForm) GetType() InputFormType {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InputForm) GetFields() []*InputField {
	if i == nil {
		return nil
	}
	return i.Fields
}

func (i *InputForm) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputForm) UnmarshalJSON(data []byte) error {
	type unmarshaler InputForm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputForm(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputForm) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputFormType string

const (
	InputFormTypeSimple InputFormType = "simple"
)

func NewInputFormTypeFromString(s string) (InputFormType, error) {
	switch s {
	case "simple":
		return InputFormTypeSimple, nil
	}
	var t InputFormType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InputFormType) Ptr() *InputFormType {
	return &i
}

// A JSONPath string - https://www.rfc-editor.org/rfc/rfc9535
type JsonPathString = string

// Pipeline Job ID
type JobId = string

// Mapping Rule ID
type MappingId = string

// Based on pageSize, which page of records to return
type PageNumber = int

// Number of logs to return in a page (default 20)
type PageSize = int

// pagination info
type Pagination struct {
	// current page of results
	CurrentPage int `json:"currentPage" url:"currentPage"`
	// total number of pages of results
	PageCount int `json:"pageCount" url:"pageCount"`
	// total available results
	TotalCount int `json:"totalCount" url:"totalCount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Pagination) GetCurrentPage() int {
	if p == nil {
		return 0
	}
	return p.CurrentPage
}

func (p *Pagination) GetPageCount() int {
	if p == nil {
		return 0
	}
	return p.PageCount
}

func (p *Pagination) GetTotalCount() int {
	if p == nil {
		return 0
	}
	return p.TotalCount
}

func (p *Pagination) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Pagination) UnmarshalJSON(data []byte) error {
	type unmarshaler Pagination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pagination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Pagination) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Mapping Program ID
type ProgramId = string

// Prompt ID
type PromptId = string

// Record ID
type RecordId = string

// Role ID
type RoleId = string

// Use this to narrow the searchValue results to a specific field
type SearchField = string

// Search for the given value, returning matching rows. For exact matches, wrap the value in double quotes ("Bob"). To search for null values, send empty double quotes ("")
type SearchValue = string

// Secret ID
type SecretId = string

// Sheet ID
type SheetId = string

// Snapshot ID
type SnapshotId = string

// Sort direction - asc (ascending) or desc (descending)
type SortDirection string

const (
	SortDirectionAsc  SortDirection = "asc"
	SortDirectionDesc SortDirection = "desc"
)

func NewSortDirectionFromString(s string) (SortDirection, error) {
	switch s {
	case "asc":
		return SortDirectionAsc, nil
	case "desc":
		return SortDirectionDesc, nil
	}
	var t SortDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortDirection) Ptr() *SortDirection {
	return &s
}

// Name of field by which to sort records
type SortField = string

// Space Config ID
type SpaceConfigId = string

// Space ID
type SpaceId = string

// Informs whether or not a request was successful
type Success struct {
	Data *SuccessData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Success) GetData() *SuccessData {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *Success) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Success) UnmarshalJSON(data []byte) error {
	type unmarshaler Success
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Success(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Success) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SuccessData struct {
	Success bool `json:"success" url:"success"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuccessData) GetSuccess() bool {
	if s == nil {
		return false
	}
	return s.Success
}

func (s *SuccessData) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessData) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessData) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Boolean
type SuccessQueryParameter = bool

// User ID
type UserId = string

// Version ID
type VersionId = string

// View ID
type ViewId = string

// Workbook ID
type WorkbookId = string
