// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/FlatFilers/flatfile-go/internal"
)

// Conflict resolutions for a record
type Resolve struct {
	Field              *string      `json:"field,omitempty" url:"field,omitempty"`
	Type               *ResolveType `json:"type,omitempty" url:"type,omitempty"`
	ResolveTo          *ResolveTo   `json:"resolveTo,omitempty" url:"resolveTo,omitempty"`
	ClipValueReference *string      `json:"clip_value_reference,omitempty" url:"clip_value_reference,omitempty"`
	MainValueReference *string      `json:"main_value_reference,omitempty" url:"main_value_reference,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Resolve) GetField() *string {
	if r == nil {
		return nil
	}
	return r.Field
}

func (r *Resolve) GetType() *ResolveType {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *Resolve) GetResolveTo() *ResolveTo {
	if r == nil {
		return nil
	}
	return r.ResolveTo
}

func (r *Resolve) GetClipValueReference() *string {
	if r == nil {
		return nil
	}
	return r.ClipValueReference
}

func (r *Resolve) GetMainValueReference() *string {
	if r == nil {
		return nil
	}
	return r.MainValueReference
}

func (r *Resolve) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Resolve) UnmarshalJSON(data []byte) error {
	type unmarshaler Resolve
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resolve(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Resolve) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolveTo string

const (
	ResolveToClip     ResolveTo = "clip"
	ResolveToMain     ResolveTo = "main"
	ResolveToSnapshot ResolveTo = "snapshot"
)

func NewResolveToFromString(s string) (ResolveTo, error) {
	switch s {
	case "clip":
		return ResolveToClip, nil
	case "main":
		return ResolveToMain, nil
	case "snapshot":
		return ResolveToSnapshot, nil
	}
	var t ResolveTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResolveTo) Ptr() *ResolveTo {
	return &r
}

type ResolveType string

const (
	ResolveTypeConflict ResolveType = "conflict"
	ResolveTypeResolve  ResolveType = "resolve"
)

func NewResolveTypeFromString(s string) (ResolveType, error) {
	switch s {
	case "conflict":
		return ResolveTypeConflict, nil
	case "resolve":
		return ResolveTypeResolve, nil
	}
	var t ResolveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResolveType) Ptr() *ResolveType {
	return &r
}
