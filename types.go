// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/FlatFilers/flatfile-go/core"
	time "time"
)

type Agent struct {
	// The topics the agent should listen for
	Topics []EventTopic `json:"topics,omitempty" url:"topics,omitempty"`
	// The compiler of the agent
	Compiler *Compiler `json:"compiler,omitempty" url:"compiler,omitempty"`
	// The source of the agent
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The source map of the agent
	SourceMap *string `json:"sourceMap,omitempty" url:"sourceMap,omitempty"`
	// The slug of the agent
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Options for the agent
	Options       map[string]interface{} `json:"options,omitempty" url:"options,omitempty"`
	Id            AgentId                `json:"id" url:"id"`
	CreatedAt     time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time              `json:"updatedAt" url:"updatedAt"`
	AccountId     AccountId              `json:"accountId" url:"accountId"`
	EnvironmentId EnvironmentId          `json:"environmentId" url:"environmentId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Agent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Agent) UnmarshalJSON(data []byte) error {
	type embed Agent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Agent(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Agent) MarshalJSON() ([]byte, error) {
	type embed Agent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Agent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Properties used to create a new agent
type AgentConfig struct {
	// The topics the agent should listen for
	Topics []EventTopic `json:"topics,omitempty" url:"topics,omitempty"`
	// The compiler of the agent
	Compiler *Compiler `json:"compiler,omitempty" url:"compiler,omitempty"`
	// The source of the agent
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The source map of the agent
	SourceMap *string `json:"sourceMap,omitempty" url:"sourceMap,omitempty"`
	// The slug of the agent
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Options for the agent
	Options map[string]interface{} `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AgentConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A log of an agent execution
type AgentLog struct {
	EventId EventId `json:"eventId" url:"eventId"`
	// Whether the agent execution was successful
	Success     bool   `json:"success" url:"success"`
	CreatedAt   string `json:"createdAt" url:"createdAt"`
	CompletedAt string `json:"completedAt" url:"completedAt"`
	// The log of the agent execution
	Log *string `json:"log,omitempty" url:"log,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AgentLog) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentLog) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentLog(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentLog) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AgentResponse struct {
	Data *Agent `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AgentResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The compiler of the agent
type Compiler string

const (
	CompilerJs Compiler = "js"
)

func NewCompilerFromString(s string) (Compiler, error) {
	switch s {
	case "js":
		return CompilerJs, nil
	}
	var t Compiler
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Compiler) Ptr() *Compiler {
	return &c
}

type GetAgentLogsResponse struct {
	Pagination *Pagination `json:"pagination,omitempty" url:"pagination,omitempty"`
	Data       []*AgentLog `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetAgentLogsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetAgentLogsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetAgentLogsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetAgentLogsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetAgentLogsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListAgentsResponse struct {
	Data []*Agent `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListAgentsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListAgentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListAgentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListAgentsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListAgentsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A commit version
type Commit struct {
	Id      CommitId `json:"id" url:"id"`
	SheetId SheetId  `json:"sheetId" url:"sheetId"`
	// The actor (user or system) who created the commit
	CreatedBy string `json:"createdBy" url:"createdBy"`
	// The actor (user or system) who completed the commit
	CompletedBy *string `json:"completedBy,omitempty" url:"completedBy,omitempty"`
	// The time the commit was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The time the commit was acknowledged
	CompletedAt *time.Time `json:"completedAt,omitempty" url:"completedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Commit) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Commit) UnmarshalJSON(data []byte) error {
	type embed Commit
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Commit(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.CompletedAt = unmarshaler.CompletedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Commit) MarshalJSON() ([]byte, error) {
	type embed Commit
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt,omitempty"`
	}{
		embed:       embed(*c),
		CreatedAt:   core.NewDateTime(c.CreatedAt),
		CompletedAt: core.NewOptionalDateTime(c.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Commit) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ListCommitsResponse struct {
	Data []*Commit `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCommitsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCommitsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCommitsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCommitsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCommitsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Account ID
type AccountId = string

type Action struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`
	// The text on the Button itself
	Label string `json:"label" url:"label"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Action) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Action) UnmarshalJSON(data []byte) error {
	type unmarshaler Action
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Action(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Action) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionConstraint struct {
	Type             string
	HasAllValid      *ActionConstraintHasAllValid
	HasSelection     *ActionConstraintHasSelection
	HasData          *ActionConstraintHasData
	HasColumnEnabled *ActionConstraintHasColumnEnabled
}

func NewActionConstraintFromHasAllValid(value *ActionConstraintHasAllValid) *ActionConstraint {
	return &ActionConstraint{Type: "hasAllValid", HasAllValid: value}
}

func NewActionConstraintFromHasSelection(value *ActionConstraintHasSelection) *ActionConstraint {
	return &ActionConstraint{Type: "hasSelection", HasSelection: value}
}

func NewActionConstraintFromHasData(value *ActionConstraintHasData) *ActionConstraint {
	return &ActionConstraint{Type: "hasData", HasData: value}
}

func NewActionConstraintFromHasColumnEnabled(value *ActionConstraintHasColumnEnabled) *ActionConstraint {
	return &ActionConstraint{Type: "hasColumnEnabled", HasColumnEnabled: value}
}

func (a *ActionConstraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "hasAllValid":
		value := new(ActionConstraintHasAllValid)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasAllValid = value
	case "hasSelection":
		value := new(ActionConstraintHasSelection)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasSelection = value
	case "hasData":
		value := new(ActionConstraintHasData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasData = value
	case "hasColumnEnabled":
		value := new(ActionConstraintHasColumnEnabled)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasColumnEnabled = value
	}
	return nil
}

func (a ActionConstraint) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "hasAllValid":
		return core.MarshalJSONWithExtraProperty(a.HasAllValid, "type", "hasAllValid")
	case "hasSelection":
		return core.MarshalJSONWithExtraProperty(a.HasSelection, "type", "hasSelection")
	case "hasData":
		return core.MarshalJSONWithExtraProperty(a.HasData, "type", "hasData")
	case "hasColumnEnabled":
		return core.MarshalJSONWithExtraProperty(a.HasColumnEnabled, "type", "hasColumnEnabled")
	}
}

type ActionConstraintVisitor interface {
	VisitHasAllValid(*ActionConstraintHasAllValid) error
	VisitHasSelection(*ActionConstraintHasSelection) error
	VisitHasData(*ActionConstraintHasData) error
	VisitHasColumnEnabled(*ActionConstraintHasColumnEnabled) error
}

func (a *ActionConstraint) Accept(visitor ActionConstraintVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "hasAllValid":
		return visitor.VisitHasAllValid(a.HasAllValid)
	case "hasSelection":
		return visitor.VisitHasSelection(a.HasSelection)
	case "hasData":
		return visitor.VisitHasData(a.HasData)
	case "hasColumnEnabled":
		return visitor.VisitHasColumnEnabled(a.HasColumnEnabled)
	}
}

// This constraint requires that all records are valid before the action can be performed.
type ActionConstraintHasAllValid struct {
	IgnoreSelection *bool `json:"ignoreSelection,omitempty" url:"ignoreSelection,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionConstraintHasAllValid) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasAllValid) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasAllValid
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasAllValid(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasAllValid) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This constraint requires the column to be enabled and not readonly before the action can be performed.
type ActionConstraintHasColumnEnabled struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionConstraintHasColumnEnabled) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasColumnEnabled) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasColumnEnabled
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasColumnEnabled(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasColumnEnabled) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This constraint requires that at least one record exists before the action can be performed.
type ActionConstraintHasData struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionConstraintHasData) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasData) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasData) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This constraint requires that at least one record is selected before the action can be performed.
type ActionConstraintHasSelection struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionConstraintHasSelection) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasSelection) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasSelection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasSelection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasSelection) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Action ID
type ActionId = string

type ActionMessage struct {
	Type    ActionMessageType `json:"type" url:"type"`
	Content string            `json:"content" url:"content"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMessage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMessage) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionMessageType string

const (
	ActionMessageTypeError ActionMessageType = "error"
	ActionMessageTypeInfo  ActionMessageType = "info"
)

func NewActionMessageTypeFromString(s string) (ActionMessageType, error) {
	switch s {
	case "error":
		return ActionMessageTypeError, nil
	case "info":
		return ActionMessageTypeInfo, nil
	}
	var t ActionMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionMessageType) Ptr() *ActionMessageType {
	return &a
}

// Foreground actions will prevent interacting with the resource until complete
type ActionMode string

const (
	ActionModeForeground      ActionMode = "foreground"
	ActionModeBackground      ActionMode = "background"
	ActionModeToolbarBlocking ActionMode = "toolbarBlocking"
)

func NewActionModeFromString(s string) (ActionMode, error) {
	switch s {
	case "foreground":
		return ActionModeForeground, nil
	case "background":
		return ActionModeBackground, nil
	case "toolbarBlocking":
		return ActionModeToolbarBlocking, nil
	}
	var t ActionMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionMode) Ptr() *ActionMode {
	return &a
}

type ActionMount struct {
	Type     string
	Sheet    *ActionMountSheet
	Workbook *ActionMountWorkbook
	Field    *ActionMountField
	Document *ActionMountDocument
	File     *ActionMountFile
}

func NewActionMountFromSheet(value *ActionMountSheet) *ActionMount {
	return &ActionMount{Type: "sheet", Sheet: value}
}

func NewActionMountFromWorkbook(value *ActionMountWorkbook) *ActionMount {
	return &ActionMount{Type: "workbook", Workbook: value}
}

func NewActionMountFromField(value *ActionMountField) *ActionMount {
	return &ActionMount{Type: "field", Field: value}
}

func NewActionMountFromDocument(value *ActionMountDocument) *ActionMount {
	return &ActionMount{Type: "document", Document: value}
}

func NewActionMountFromFile(value *ActionMountFile) *ActionMount {
	return &ActionMount{Type: "file", File: value}
}

func (a *ActionMount) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "sheet":
		value := new(ActionMountSheet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Sheet = value
	case "workbook":
		value := new(ActionMountWorkbook)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Workbook = value
	case "field":
		value := new(ActionMountField)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Field = value
	case "document":
		value := new(ActionMountDocument)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Document = value
	case "file":
		value := new(ActionMountFile)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.File = value
	}
	return nil
}

func (a ActionMount) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "sheet":
		return core.MarshalJSONWithExtraProperty(a.Sheet, "type", "sheet")
	case "workbook":
		return core.MarshalJSONWithExtraProperty(a.Workbook, "type", "workbook")
	case "field":
		return core.MarshalJSONWithExtraProperty(a.Field, "type", "field")
	case "document":
		return core.MarshalJSONWithExtraProperty(a.Document, "type", "document")
	case "file":
		return core.MarshalJSONWithExtraProperty(a.File, "type", "file")
	}
}

type ActionMountVisitor interface {
	VisitSheet(*ActionMountSheet) error
	VisitWorkbook(*ActionMountWorkbook) error
	VisitField(*ActionMountField) error
	VisitDocument(*ActionMountDocument) error
	VisitFile(*ActionMountFile) error
}

func (a *ActionMount) Accept(visitor ActionMountVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "sheet":
		return visitor.VisitSheet(a.Sheet)
	case "workbook":
		return visitor.VisitWorkbook(a.Workbook)
	case "field":
		return visitor.VisitField(a.Field)
	case "document":
		return visitor.VisitDocument(a.Document)
	case "file":
		return visitor.VisitFile(a.File)
	}
}

// Used to mount this action on documents.
type ActionMountDocument struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountDocument) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountDocument(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountDocument) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Sheet Columns.
type ActionMountField struct {
	Keys []string `json:"keys,omitempty" url:"keys,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountField) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountField) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountField) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on files.
type ActionMountFile struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountFile) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountFile) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountFile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountFile) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Sheets.
type ActionMountSheet struct {
	Slugs []string `json:"slugs,omitempty" url:"slugs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountSheet) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountSheet) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountSheet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountSheet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountSheet) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Workbooks.
type ActionMountWorkbook struct {
	Slugs []string `json:"slugs,omitempty" url:"slugs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountWorkbook) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountWorkbook) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountWorkbook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountWorkbook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountWorkbook) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionSchedule string

const (
	ActionScheduleWeekly ActionSchedule = "weekly"
	ActionScheduleDaily  ActionSchedule = "daily"
	ActionScheduleHourly ActionSchedule = "hourly"
)

func NewActionScheduleFromString(s string) (ActionSchedule, error) {
	switch s {
	case "weekly":
		return ActionScheduleWeekly, nil
	case "daily":
		return ActionScheduleDaily, nil
	case "hourly":
		return ActionScheduleHourly, nil
	}
	var t ActionSchedule
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionSchedule) Ptr() *ActionSchedule {
	return &a
}

type ActionWithoutLabel struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionWithoutLabel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionWithoutLabel) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionWithoutLabel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionWithoutLabel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionWithoutLabel) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActorIdUnion struct {
	UserId  UserId
	AgentId AgentId
	GuestId GuestId

	typ string
}

func NewActorIdUnionFromUserId(value UserId) *ActorIdUnion {
	return &ActorIdUnion{typ: "UserId", UserId: value}
}

func NewActorIdUnionFromAgentId(value AgentId) *ActorIdUnion {
	return &ActorIdUnion{typ: "AgentId", AgentId: value}
}

func NewActorIdUnionFromGuestId(value GuestId) *ActorIdUnion {
	return &ActorIdUnion{typ: "GuestId", GuestId: value}
}

func (a *ActorIdUnion) UnmarshalJSON(data []byte) error {
	var valueUserId UserId
	if err := json.Unmarshal(data, &valueUserId); err == nil {
		a.typ = "UserId"
		a.UserId = valueUserId
		return nil
	}
	var valueAgentId AgentId
	if err := json.Unmarshal(data, &valueAgentId); err == nil {
		a.typ = "AgentId"
		a.AgentId = valueAgentId
		return nil
	}
	var valueGuestId GuestId
	if err := json.Unmarshal(data, &valueGuestId); err == nil {
		a.typ = "GuestId"
		a.GuestId = valueGuestId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActorIdUnion) MarshalJSON() ([]byte, error) {
	if a.typ == "UserId" || a.UserId != "" {
		return json.Marshal(a.UserId)
	}
	if a.typ == "AgentId" || a.AgentId != "" {
		return json.Marshal(a.AgentId)
	}
	if a.typ == "GuestId" || a.GuestId != "" {
		return json.Marshal(a.GuestId)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ActorIdUnionVisitor interface {
	VisitUserId(UserId) error
	VisitAgentId(AgentId) error
	VisitGuestId(GuestId) error
}

func (a *ActorIdUnion) Accept(visitor ActorIdUnionVisitor) error {
	if a.typ == "UserId" || a.UserId != "" {
		return visitor.VisitUserId(a.UserId)
	}
	if a.typ == "AgentId" || a.AgentId != "" {
		return visitor.VisitAgentId(a.AgentId)
	}
	if a.typ == "GuestId" || a.GuestId != "" {
		return visitor.VisitGuestId(a.GuestId)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// Actor Role ID
type ActorRoleId = string

// Agent ID
type AgentId = string

// App ID
type AppId = string

// Commit ID
type CommitId = string

// Data Clip ID
type DataClipId = string

// Document ID
type DocumentId = string

// Environment ID
type EnvironmentId = string

type Error struct {
	Key     *string `json:"key,omitempty" url:"key,omitempty"`
	Message string  `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Errors struct {
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Errors) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Errors) UnmarshalJSON(data []byte) error {
	type unmarshaler Errors
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Errors(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Errors) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Event ID
type EventId = string

// File ID
type FileId = string

// Options to filter records
type Filter string

const (
	FilterValid Filter = "valid"
	FilterError Filter = "error"
	FilterAll   Filter = "all"
	FilterNone  Filter = "none"
)

func NewFilterFromString(s string) (Filter, error) {
	switch s {
	case "valid":
		return FilterValid, nil
	case "error":
		return FilterError, nil
	case "all":
		return FilterAll, nil
	case "none":
		return FilterNone, nil
	}
	var t Filter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f Filter) Ptr() *Filter {
	return &f
}

// Use this to narrow the valid/error filter results to a specific field
type FilterField = string

type Guardrail struct {
	// Markdown guardrail for this action
	Content string `json:"content" url:"content"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Guardrail) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Guardrail) UnmarshalJSON(data []byte) error {
	type unmarshaler Guardrail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Guardrail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Guardrail) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Guest ID
type GuestId = string

type Guide struct {
	// Markdown guidance for this action
	Content string `json:"content" url:"content"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Guide) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Guide) UnmarshalJSON(data []byte) error {
	type unmarshaler Guide
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Guide(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Guide) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type InputConfig struct {
	Options []*InputEnumPropertyOption `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputConfig) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler InputConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputConfig) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputConstraint struct {
	Type InputConstraintType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputConstraint) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler InputConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputConstraint) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputConstraintType string

const (
	InputConstraintTypeRequired InputConstraintType = "required"
)

func NewInputConstraintTypeFromString(s string) (InputConstraintType, error) {
	switch s {
	case "required":
		return InputConstraintTypeRequired, nil
	}
	var t InputConstraintType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InputConstraintType) Ptr() *InputConstraintType {
	return &i
}

type InputEnumPropertyOption struct {
	// A visual label for this option, defaults to value if not provided
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// An optional color to assign this option
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// A reference pointer to a previously registered icon
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// An arbitrary JSON object to be associated with this option and made available to hooks
	Meta map[string]interface{} `json:"meta,omitempty" url:"meta,omitempty"`
	// The value or ID of this option. This value will be sent in egress. The type is a string | integer | boolean.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputEnumPropertyOption) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputEnumPropertyOption) UnmarshalJSON(data []byte) error {
	type unmarshaler InputEnumPropertyOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputEnumPropertyOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputEnumPropertyOption) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputField struct {
	// Unique key for a Field.
	Key string `json:"key" url:"key"`
	// Visible name of a Field.
	Label string `json:"label" url:"label"`
	// Brief description below the name of the Field.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Field Types inform the user interface how to sort and display data.
	Type string `json:"type" url:"type"`
	// Default value for a Field.
	DefaultValue interface{} `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	// Additional configuration for enum Fields.
	Config *InputConfig `json:"config,omitempty" url:"config,omitempty"`
	// Indicate additional validations that will be applied to the Field.
	Constraints []*InputConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputField) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputField) UnmarshalJSON(data []byte) error {
	type unmarshaler InputField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputField) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputForm struct {
	Type   InputFormType `json:"type" url:"type"`
	Fields []*InputField `json:"fields,omitempty" url:"fields,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputForm) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputForm) UnmarshalJSON(data []byte) error {
	type unmarshaler InputForm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputForm(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputForm) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputFormType string

const (
	InputFormTypeSimple InputFormType = "simple"
)

func NewInputFormTypeFromString(s string) (InputFormType, error) {
	switch s {
	case "simple":
		return InputFormTypeSimple, nil
	}
	var t InputFormType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InputFormType) Ptr() *InputFormType {
	return &i
}

// A JSONPath string - https://www.rfc-editor.org/rfc/rfc9535
type JsonPathString = string

// Pipeline Job ID
type JobId = string

// Based on pageSize, which page of records to return
type PageNumber = int

// Number of logs to return in a page (default 20)
type PageSize = int

// pagination info
type Pagination struct {
	// current page of results
	CurrentPage int `json:"currentPage" url:"currentPage"`
	// total number of pages of results
	PageCount int `json:"pageCount" url:"pageCount"`
	// total available results
	TotalCount int `json:"totalCount" url:"totalCount"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Pagination) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Pagination) UnmarshalJSON(data []byte) error {
	type unmarshaler Pagination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pagination(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Pagination) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Mapping Program ID
type ProgramId = string

// Record ID
type RecordId = string

// Role ID
type RoleId = string

// Use this to narrow the searchValue results to a specific field
type SearchField = string

// Search for the given value, returning matching rows. For exact matches, wrap the value in double quotes ("Bob"). To search for null values, send empty double quotes ("")
type SearchValue = string

// Sheet ID
type SheetId = string

// Snapshot ID
type SnapshotId = string

// Sort direction - asc (ascending) or desc (descending)
type SortDirection string

const (
	SortDirectionAsc  SortDirection = "asc"
	SortDirectionDesc SortDirection = "desc"
)

func NewSortDirectionFromString(s string) (SortDirection, error) {
	switch s {
	case "asc":
		return SortDirectionAsc, nil
	case "desc":
		return SortDirectionDesc, nil
	}
	var t SortDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortDirection) Ptr() *SortDirection {
	return &s
}

// Name of field by which to sort records
type SortField = string

// Space Config ID
type SpaceConfigId = string

// Space ID
type SpaceId = string

// Informs whether or not a request was successful
type Success struct {
	Data *SuccessData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Success) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Success) UnmarshalJSON(data []byte) error {
	type unmarshaler Success
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Success(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Success) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SuccessData struct {
	Success bool `json:"success" url:"success"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SuccessData) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessData) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessData) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// User ID
type UserId = string

// Version ID
type VersionId = string

// Workbook ID
type WorkbookId = string

// Conflict resolutions for a record
type Resolve struct {
	Field     *string      `json:"field,omitempty" url:"field,omitempty"`
	Type      *ResolveType `json:"type,omitempty" url:"type,omitempty"`
	ResolveTo *ResolveTo   `json:"resolveTo,omitempty" url:"resolveTo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Resolve) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Resolve) UnmarshalJSON(data []byte) error {
	type unmarshaler Resolve
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resolve(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Resolve) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolveTo string

const (
	ResolveToClip     ResolveTo = "clip"
	ResolveToMain     ResolveTo = "main"
	ResolveToSnapshot ResolveTo = "snapshot"
)

func NewResolveToFromString(s string) (ResolveTo, error) {
	switch s {
	case "clip":
		return ResolveToClip, nil
	case "main":
		return ResolveToMain, nil
	case "snapshot":
		return ResolveToSnapshot, nil
	}
	var t ResolveTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResolveTo) Ptr() *ResolveTo {
	return &r
}

type ResolveType string

const (
	ResolveTypeConflict ResolveType = "conflict"
	ResolveTypeResolve  ResolveType = "resolve"
)

func NewResolveTypeFromString(s string) (ResolveType, error) {
	switch s {
	case "conflict":
		return ResolveTypeConflict, nil
	case "resolve":
		return ResolveTypeResolve, nil
	}
	var t ResolveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResolveType) Ptr() *ResolveType {
	return &r
}

// The type of authentication to use for guests
type GuestAuthenticationEnum string

const (
	GuestAuthenticationEnumSharedLink GuestAuthenticationEnum = "shared_link"
	GuestAuthenticationEnumMagicLink  GuestAuthenticationEnum = "magic_link"
)

func NewGuestAuthenticationEnumFromString(s string) (GuestAuthenticationEnum, error) {
	switch s {
	case "shared_link":
		return GuestAuthenticationEnumSharedLink, nil
	case "magic_link":
		return GuestAuthenticationEnumMagicLink, nil
	}
	var t GuestAuthenticationEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GuestAuthenticationEnum) Ptr() *GuestAuthenticationEnum {
	return &g
}

// Name of an action
type ActionName = string

type BaseEvent struct {
	// The domain of the event
	Domain Domain `json:"domain" url:"domain"`
	// The context of the event
	Context *Context `json:"context,omitempty" url:"context,omitempty"`
	// The attributes of the event
	Attributes *EventAttributes `json:"attributes,omitempty" url:"attributes,omitempty"`
	// The callback url to acknowledge the event
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// The url to retrieve the data associated with the event
	DataUrl    *string  `json:"dataUrl,omitempty" url:"dataUrl,omitempty"`
	Target     *string  `json:"target,omitempty" url:"target,omitempty"`
	Origin     *Origin  `json:"origin,omitempty" url:"origin,omitempty"`
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BaseEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseEvent) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The context of the event
type Context struct {
	// The namespaces of the event
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`
	// The slugs of related resources
	Slugs         *EventContextSlugs `json:"slugs,omitempty" url:"slugs,omitempty"`
	ActionName    *ActionName        `json:"actionName,omitempty" url:"actionName,omitempty"`
	AccountId     AccountId          `json:"accountId" url:"accountId"`
	EnvironmentId EnvironmentId      `json:"environmentId" url:"environmentId"`
	SpaceId       *SpaceId           `json:"spaceId,omitempty" url:"spaceId,omitempty"`
	WorkbookId    *WorkbookId        `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	SheetId       *SheetId           `json:"sheetId,omitempty" url:"sheetId,omitempty"`
	SheetSlug     *SheetSlug         `json:"sheetSlug,omitempty" url:"sheetSlug,omitempty"`
	SnapshotId    *SnapshotId        `json:"snapshotId,omitempty" url:"snapshotId,omitempty"`
	// Deprecated, use `commitId` instead.
	VersionId        *VersionId  `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId         *CommitId   `json:"commitId,omitempty" url:"commitId,omitempty"`
	JobId            *JobId      `json:"jobId,omitempty" url:"jobId,omitempty"`
	ProgramId        *ProgramId  `json:"programId,omitempty" url:"programId,omitempty"`
	FileId           *FileId     `json:"fileId,omitempty" url:"fileId,omitempty"`
	DocumentId       *DocumentId `json:"documentId,omitempty" url:"documentId,omitempty"`
	PrecedingEventId *EventId    `json:"precedingEventId,omitempty" url:"precedingEventId,omitempty"`
	// Can be a UserId, GuestId, or AgentId
	ActorId    *string     `json:"actorId,omitempty" url:"actorId,omitempty"`
	AppId      *AppId      `json:"appId,omitempty" url:"appId,omitempty"`
	ActionId   *ActionId   `json:"actionId,omitempty" url:"actionId,omitempty"`
	DataClipId *DataClipId `json:"dataClipId,omitempty" url:"dataClipId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Context) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Context) UnmarshalJSON(data []byte) error {
	type unmarshaler Context
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Context(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Context) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The domain of the event
type Domain string

const (
	DomainFile        Domain = "file"
	DomainSpace       Domain = "space"
	DomainWorkbook    Domain = "workbook"
	DomainJob         Domain = "job"
	DomainDocument    Domain = "document"
	DomainSheet       Domain = "sheet"
	DomainProgram     Domain = "program"
	DomainSecret      Domain = "secret"
	DomainCron        Domain = "cron"
	DomainEnvironment Domain = "environment"
	DomainDataClip    Domain = "data-clip"
)

func NewDomainFromString(s string) (Domain, error) {
	switch s {
	case "file":
		return DomainFile, nil
	case "space":
		return DomainSpace, nil
	case "workbook":
		return DomainWorkbook, nil
	case "job":
		return DomainJob, nil
	case "document":
		return DomainDocument, nil
	case "sheet":
		return DomainSheet, nil
	case "program":
		return DomainProgram, nil
	case "secret":
		return DomainSecret, nil
	case "cron":
		return DomainCron, nil
	case "environment":
		return DomainEnvironment, nil
	case "data-clip":
		return DomainDataClip, nil
	}
	var t Domain
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d Domain) Ptr() *Domain {
	return &d
}

// An event that tracks an activity within an environment
type Event struct {
	Topic                        string
	AgentCreated                 *GenericEvent
	AgentUpdated                 *GenericEvent
	AgentDeleted                 *GenericEvent
	SpaceCreated                 *GenericEvent
	SpaceUpdated                 *GenericEvent
	SpaceDeleted                 *GenericEvent
	SpaceArchived                *GenericEvent
	SpaceExpired                 *GenericEvent
	SpaceGuestAdded              *GenericEvent
	SpaceGuestRemoved            *GenericEvent
	DocumentCreated              *GenericEvent
	DocumentUpdated              *GenericEvent
	DocumentDeleted              *GenericEvent
	WorkbookCreated              *GenericEvent
	WorkbookUpdated              *GenericEvent
	WorkbookDeleted              *GenericEvent
	WorkbookExpired              *GenericEvent
	SheetCreated                 *GenericEvent
	SheetUpdated                 *GenericEvent
	SheetDeleted                 *GenericEvent
	SheetCountsUpdated           *GenericEvent
	SnapshotCreated              *GenericEvent
	RecordsCreated               *GenericEvent
	RecordsUpdated               *GenericEvent
	RecordsDeleted               *GenericEvent
	FileCreated                  *GenericEvent
	FileUpdated                  *GenericEvent
	FileDeleted                  *GenericEvent
	FileExpired                  *GenericEvent
	JobCreated                   *GenericEvent
	JobUpdated                   *GenericEvent
	JobDeleted                   *GenericEvent
	JobFailed                    *GenericEvent
	JobCompleted                 *GenericEvent
	JobReady                     *GenericEvent
	JobScheduled                 *GenericEvent
	JobOutcomeAcknowledged       *GenericEvent
	JobPartsCompleted            *GenericEvent
	ProgramCreated               *GenericEvent
	ProgramUpdated               *GenericEvent
	CommitCreated                *GenericEvent
	CommitUpdated                *GenericEvent
	CommitCompleted              *GenericEvent
	SecretCreated                *GenericEvent
	SecretUpdated                *GenericEvent
	SecretDeleted                *GenericEvent
	LayerCreated                 *GenericEvent
	EnvironmentCreated           *GenericEvent
	EnvironmentUpdated           *GenericEvent
	EnvironmentDeleted           *GenericEvent
	ActionCreated                *GenericEvent
	ActionUpdated                *GenericEvent
	ActionDeleted                *GenericEvent
	DataClipCreated              *GenericEvent
	DataClipUpdated              *GenericEvent
	DataClipDeleted              *GenericEvent
	DataClipCollaboratorUpdated  *GenericEvent
	DataClipResolutionsCreated   *GenericEvent
	DataClipResolutionsUpdated   *GenericEvent
	DataClipResolutionsRefreshed *GenericEvent
}

func NewEventFromAgentCreated(value *GenericEvent) *Event {
	return &Event{Topic: "agent:created", AgentCreated: value}
}

func NewEventFromAgentUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "agent:updated", AgentUpdated: value}
}

func NewEventFromAgentDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "agent:deleted", AgentDeleted: value}
}

func NewEventFromSpaceCreated(value *GenericEvent) *Event {
	return &Event{Topic: "space:created", SpaceCreated: value}
}

func NewEventFromSpaceUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "space:updated", SpaceUpdated: value}
}

func NewEventFromSpaceDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "space:deleted", SpaceDeleted: value}
}

func NewEventFromSpaceArchived(value *GenericEvent) *Event {
	return &Event{Topic: "space:archived", SpaceArchived: value}
}

func NewEventFromSpaceExpired(value *GenericEvent) *Event {
	return &Event{Topic: "space:expired", SpaceExpired: value}
}

func NewEventFromSpaceGuestAdded(value *GenericEvent) *Event {
	return &Event{Topic: "space:guestAdded", SpaceGuestAdded: value}
}

func NewEventFromSpaceGuestRemoved(value *GenericEvent) *Event {
	return &Event{Topic: "space:guestRemoved", SpaceGuestRemoved: value}
}

func NewEventFromDocumentCreated(value *GenericEvent) *Event {
	return &Event{Topic: "document:created", DocumentCreated: value}
}

func NewEventFromDocumentUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "document:updated", DocumentUpdated: value}
}

func NewEventFromDocumentDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "document:deleted", DocumentDeleted: value}
}

func NewEventFromWorkbookCreated(value *GenericEvent) *Event {
	return &Event{Topic: "workbook:created", WorkbookCreated: value}
}

func NewEventFromWorkbookUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "workbook:updated", WorkbookUpdated: value}
}

func NewEventFromWorkbookDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "workbook:deleted", WorkbookDeleted: value}
}

func NewEventFromWorkbookExpired(value *GenericEvent) *Event {
	return &Event{Topic: "workbook:expired", WorkbookExpired: value}
}

func NewEventFromSheetCreated(value *GenericEvent) *Event {
	return &Event{Topic: "sheet:created", SheetCreated: value}
}

func NewEventFromSheetUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "sheet:updated", SheetUpdated: value}
}

func NewEventFromSheetDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "sheet:deleted", SheetDeleted: value}
}

func NewEventFromSheetCountsUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "sheet:counts-updated", SheetCountsUpdated: value}
}

func NewEventFromSnapshotCreated(value *GenericEvent) *Event {
	return &Event{Topic: "snapshot:created", SnapshotCreated: value}
}

func NewEventFromRecordsCreated(value *GenericEvent) *Event {
	return &Event{Topic: "records:created", RecordsCreated: value}
}

func NewEventFromRecordsUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "records:updated", RecordsUpdated: value}
}

func NewEventFromRecordsDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "records:deleted", RecordsDeleted: value}
}

func NewEventFromFileCreated(value *GenericEvent) *Event {
	return &Event{Topic: "file:created", FileCreated: value}
}

func NewEventFromFileUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "file:updated", FileUpdated: value}
}

func NewEventFromFileDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "file:deleted", FileDeleted: value}
}

func NewEventFromFileExpired(value *GenericEvent) *Event {
	return &Event{Topic: "file:expired", FileExpired: value}
}

func NewEventFromJobCreated(value *GenericEvent) *Event {
	return &Event{Topic: "job:created", JobCreated: value}
}

func NewEventFromJobUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "job:updated", JobUpdated: value}
}

func NewEventFromJobDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "job:deleted", JobDeleted: value}
}

func NewEventFromJobFailed(value *GenericEvent) *Event {
	return &Event{Topic: "job:failed", JobFailed: value}
}

func NewEventFromJobCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "job:completed", JobCompleted: value}
}

func NewEventFromJobReady(value *GenericEvent) *Event {
	return &Event{Topic: "job:ready", JobReady: value}
}

func NewEventFromJobScheduled(value *GenericEvent) *Event {
	return &Event{Topic: "job:scheduled", JobScheduled: value}
}

func NewEventFromJobOutcomeAcknowledged(value *GenericEvent) *Event {
	return &Event{Topic: "job:outcome-acknowledged", JobOutcomeAcknowledged: value}
}

func NewEventFromJobPartsCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "job:parts-completed", JobPartsCompleted: value}
}

func NewEventFromProgramCreated(value *GenericEvent) *Event {
	return &Event{Topic: "program:created", ProgramCreated: value}
}

func NewEventFromProgramUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "program:updated", ProgramUpdated: value}
}

func NewEventFromCommitCreated(value *GenericEvent) *Event {
	return &Event{Topic: "commit:created", CommitCreated: value}
}

func NewEventFromCommitUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "commit:updated", CommitUpdated: value}
}

func NewEventFromCommitCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "commit:completed", CommitCompleted: value}
}

func NewEventFromSecretCreated(value *GenericEvent) *Event {
	return &Event{Topic: "secret:created", SecretCreated: value}
}

func NewEventFromSecretUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "secret:updated", SecretUpdated: value}
}

func NewEventFromSecretDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "secret:deleted", SecretDeleted: value}
}

func NewEventFromLayerCreated(value *GenericEvent) *Event {
	return &Event{Topic: "layer:created", LayerCreated: value}
}

func NewEventFromEnvironmentCreated(value *GenericEvent) *Event {
	return &Event{Topic: "environment:created", EnvironmentCreated: value}
}

func NewEventFromEnvironmentUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "environment:updated", EnvironmentUpdated: value}
}

func NewEventFromEnvironmentDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "environment:deleted", EnvironmentDeleted: value}
}

func NewEventFromActionCreated(value *GenericEvent) *Event {
	return &Event{Topic: "action:created", ActionCreated: value}
}

func NewEventFromActionUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "action:updated", ActionUpdated: value}
}

func NewEventFromActionDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "action:deleted", ActionDeleted: value}
}

func NewEventFromDataClipCreated(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:created", DataClipCreated: value}
}

func NewEventFromDataClipUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:updated", DataClipUpdated: value}
}

func NewEventFromDataClipDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:deleted", DataClipDeleted: value}
}

func NewEventFromDataClipCollaboratorUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:collaborator-updated", DataClipCollaboratorUpdated: value}
}

func NewEventFromDataClipResolutionsCreated(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:resolutions-created", DataClipResolutionsCreated: value}
}

func NewEventFromDataClipResolutionsUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:resolutions-updated", DataClipResolutionsUpdated: value}
}

func NewEventFromDataClipResolutionsRefreshed(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:resolutions-refreshed", DataClipResolutionsRefreshed: value}
}

func (e *Event) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Topic string `json:"topic"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Topic = unmarshaler.Topic
	if unmarshaler.Topic == "" {
		return fmt.Errorf("%T did not include discriminant topic", e)
	}
	switch unmarshaler.Topic {
	case "agent:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentCreated = value
	case "agent:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentUpdated = value
	case "agent:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentDeleted = value
	case "space:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceCreated = value
	case "space:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceUpdated = value
	case "space:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceDeleted = value
	case "space:archived":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceArchived = value
	case "space:expired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceExpired = value
	case "space:guestAdded":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceGuestAdded = value
	case "space:guestRemoved":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceGuestRemoved = value
	case "document:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentCreated = value
	case "document:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentUpdated = value
	case "document:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentDeleted = value
	case "workbook:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookCreated = value
	case "workbook:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookUpdated = value
	case "workbook:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookDeleted = value
	case "workbook:expired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookExpired = value
	case "sheet:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetCreated = value
	case "sheet:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetUpdated = value
	case "sheet:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetDeleted = value
	case "sheet:counts-updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetCountsUpdated = value
	case "snapshot:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SnapshotCreated = value
	case "records:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsCreated = value
	case "records:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsUpdated = value
	case "records:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsDeleted = value
	case "file:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileCreated = value
	case "file:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileUpdated = value
	case "file:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileDeleted = value
	case "file:expired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileExpired = value
	case "job:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobCreated = value
	case "job:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobUpdated = value
	case "job:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobDeleted = value
	case "job:failed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobFailed = value
	case "job:completed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobCompleted = value
	case "job:ready":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobReady = value
	case "job:scheduled":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobScheduled = value
	case "job:outcome-acknowledged":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobOutcomeAcknowledged = value
	case "job:parts-completed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobPartsCompleted = value
	case "program:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ProgramCreated = value
	case "program:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ProgramUpdated = value
	case "commit:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitCreated = value
	case "commit:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitUpdated = value
	case "commit:completed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitCompleted = value
	case "secret:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretCreated = value
	case "secret:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretUpdated = value
	case "secret:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretDeleted = value
	case "layer:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.LayerCreated = value
	case "environment:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EnvironmentCreated = value
	case "environment:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EnvironmentUpdated = value
	case "environment:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EnvironmentDeleted = value
	case "action:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ActionCreated = value
	case "action:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ActionUpdated = value
	case "action:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ActionDeleted = value
	case "data-clip:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipCreated = value
	case "data-clip:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipUpdated = value
	case "data-clip:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipDeleted = value
	case "data-clip:collaborator-updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipCollaboratorUpdated = value
	case "data-clip:resolutions-created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipResolutionsCreated = value
	case "data-clip:resolutions-updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipResolutionsUpdated = value
	case "data-clip:resolutions-refreshed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipResolutionsRefreshed = value
	}
	return nil
}

func (e Event) MarshalJSON() ([]byte, error) {
	switch e.Topic {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Topic, e)
	case "agent:created":
		return core.MarshalJSONWithExtraProperty(e.AgentCreated, "topic", "agent:created")
	case "agent:updated":
		return core.MarshalJSONWithExtraProperty(e.AgentUpdated, "topic", "agent:updated")
	case "agent:deleted":
		return core.MarshalJSONWithExtraProperty(e.AgentDeleted, "topic", "agent:deleted")
	case "space:created":
		return core.MarshalJSONWithExtraProperty(e.SpaceCreated, "topic", "space:created")
	case "space:updated":
		return core.MarshalJSONWithExtraProperty(e.SpaceUpdated, "topic", "space:updated")
	case "space:deleted":
		return core.MarshalJSONWithExtraProperty(e.SpaceDeleted, "topic", "space:deleted")
	case "space:archived":
		return core.MarshalJSONWithExtraProperty(e.SpaceArchived, "topic", "space:archived")
	case "space:expired":
		return core.MarshalJSONWithExtraProperty(e.SpaceExpired, "topic", "space:expired")
	case "space:guestAdded":
		return core.MarshalJSONWithExtraProperty(e.SpaceGuestAdded, "topic", "space:guestAdded")
	case "space:guestRemoved":
		return core.MarshalJSONWithExtraProperty(e.SpaceGuestRemoved, "topic", "space:guestRemoved")
	case "document:created":
		return core.MarshalJSONWithExtraProperty(e.DocumentCreated, "topic", "document:created")
	case "document:updated":
		return core.MarshalJSONWithExtraProperty(e.DocumentUpdated, "topic", "document:updated")
	case "document:deleted":
		return core.MarshalJSONWithExtraProperty(e.DocumentDeleted, "topic", "document:deleted")
	case "workbook:created":
		return core.MarshalJSONWithExtraProperty(e.WorkbookCreated, "topic", "workbook:created")
	case "workbook:updated":
		return core.MarshalJSONWithExtraProperty(e.WorkbookUpdated, "topic", "workbook:updated")
	case "workbook:deleted":
		return core.MarshalJSONWithExtraProperty(e.WorkbookDeleted, "topic", "workbook:deleted")
	case "workbook:expired":
		return core.MarshalJSONWithExtraProperty(e.WorkbookExpired, "topic", "workbook:expired")
	case "sheet:created":
		return core.MarshalJSONWithExtraProperty(e.SheetCreated, "topic", "sheet:created")
	case "sheet:updated":
		return core.MarshalJSONWithExtraProperty(e.SheetUpdated, "topic", "sheet:updated")
	case "sheet:deleted":
		return core.MarshalJSONWithExtraProperty(e.SheetDeleted, "topic", "sheet:deleted")
	case "sheet:counts-updated":
		return core.MarshalJSONWithExtraProperty(e.SheetCountsUpdated, "topic", "sheet:counts-updated")
	case "snapshot:created":
		return core.MarshalJSONWithExtraProperty(e.SnapshotCreated, "topic", "snapshot:created")
	case "records:created":
		return core.MarshalJSONWithExtraProperty(e.RecordsCreated, "topic", "records:created")
	case "records:updated":
		return core.MarshalJSONWithExtraProperty(e.RecordsUpdated, "topic", "records:updated")
	case "records:deleted":
		return core.MarshalJSONWithExtraProperty(e.RecordsDeleted, "topic", "records:deleted")
	case "file:created":
		return core.MarshalJSONWithExtraProperty(e.FileCreated, "topic", "file:created")
	case "file:updated":
		return core.MarshalJSONWithExtraProperty(e.FileUpdated, "topic", "file:updated")
	case "file:deleted":
		return core.MarshalJSONWithExtraProperty(e.FileDeleted, "topic", "file:deleted")
	case "file:expired":
		return core.MarshalJSONWithExtraProperty(e.FileExpired, "topic", "file:expired")
	case "job:created":
		return core.MarshalJSONWithExtraProperty(e.JobCreated, "topic", "job:created")
	case "job:updated":
		return core.MarshalJSONWithExtraProperty(e.JobUpdated, "topic", "job:updated")
	case "job:deleted":
		return core.MarshalJSONWithExtraProperty(e.JobDeleted, "topic", "job:deleted")
	case "job:failed":
		return core.MarshalJSONWithExtraProperty(e.JobFailed, "topic", "job:failed")
	case "job:completed":
		return core.MarshalJSONWithExtraProperty(e.JobCompleted, "topic", "job:completed")
	case "job:ready":
		return core.MarshalJSONWithExtraProperty(e.JobReady, "topic", "job:ready")
	case "job:scheduled":
		return core.MarshalJSONWithExtraProperty(e.JobScheduled, "topic", "job:scheduled")
	case "job:outcome-acknowledged":
		return core.MarshalJSONWithExtraProperty(e.JobOutcomeAcknowledged, "topic", "job:outcome-acknowledged")
	case "job:parts-completed":
		return core.MarshalJSONWithExtraProperty(e.JobPartsCompleted, "topic", "job:parts-completed")
	case "program:created":
		return core.MarshalJSONWithExtraProperty(e.ProgramCreated, "topic", "program:created")
	case "program:updated":
		return core.MarshalJSONWithExtraProperty(e.ProgramUpdated, "topic", "program:updated")
	case "commit:created":
		return core.MarshalJSONWithExtraProperty(e.CommitCreated, "topic", "commit:created")
	case "commit:updated":
		return core.MarshalJSONWithExtraProperty(e.CommitUpdated, "topic", "commit:updated")
	case "commit:completed":
		return core.MarshalJSONWithExtraProperty(e.CommitCompleted, "topic", "commit:completed")
	case "secret:created":
		return core.MarshalJSONWithExtraProperty(e.SecretCreated, "topic", "secret:created")
	case "secret:updated":
		return core.MarshalJSONWithExtraProperty(e.SecretUpdated, "topic", "secret:updated")
	case "secret:deleted":
		return core.MarshalJSONWithExtraProperty(e.SecretDeleted, "topic", "secret:deleted")
	case "layer:created":
		return core.MarshalJSONWithExtraProperty(e.LayerCreated, "topic", "layer:created")
	case "environment:created":
		return core.MarshalJSONWithExtraProperty(e.EnvironmentCreated, "topic", "environment:created")
	case "environment:updated":
		return core.MarshalJSONWithExtraProperty(e.EnvironmentUpdated, "topic", "environment:updated")
	case "environment:deleted":
		return core.MarshalJSONWithExtraProperty(e.EnvironmentDeleted, "topic", "environment:deleted")
	case "action:created":
		return core.MarshalJSONWithExtraProperty(e.ActionCreated, "topic", "action:created")
	case "action:updated":
		return core.MarshalJSONWithExtraProperty(e.ActionUpdated, "topic", "action:updated")
	case "action:deleted":
		return core.MarshalJSONWithExtraProperty(e.ActionDeleted, "topic", "action:deleted")
	case "data-clip:created":
		return core.MarshalJSONWithExtraProperty(e.DataClipCreated, "topic", "data-clip:created")
	case "data-clip:updated":
		return core.MarshalJSONWithExtraProperty(e.DataClipUpdated, "topic", "data-clip:updated")
	case "data-clip:deleted":
		return core.MarshalJSONWithExtraProperty(e.DataClipDeleted, "topic", "data-clip:deleted")
	case "data-clip:collaborator-updated":
		return core.MarshalJSONWithExtraProperty(e.DataClipCollaboratorUpdated, "topic", "data-clip:collaborator-updated")
	case "data-clip:resolutions-created":
		return core.MarshalJSONWithExtraProperty(e.DataClipResolutionsCreated, "topic", "data-clip:resolutions-created")
	case "data-clip:resolutions-updated":
		return core.MarshalJSONWithExtraProperty(e.DataClipResolutionsUpdated, "topic", "data-clip:resolutions-updated")
	case "data-clip:resolutions-refreshed":
		return core.MarshalJSONWithExtraProperty(e.DataClipResolutionsRefreshed, "topic", "data-clip:resolutions-refreshed")
	}
}

type EventVisitor interface {
	VisitAgentCreated(*GenericEvent) error
	VisitAgentUpdated(*GenericEvent) error
	VisitAgentDeleted(*GenericEvent) error
	VisitSpaceCreated(*GenericEvent) error
	VisitSpaceUpdated(*GenericEvent) error
	VisitSpaceDeleted(*GenericEvent) error
	VisitSpaceArchived(*GenericEvent) error
	VisitSpaceExpired(*GenericEvent) error
	VisitSpaceGuestAdded(*GenericEvent) error
	VisitSpaceGuestRemoved(*GenericEvent) error
	VisitDocumentCreated(*GenericEvent) error
	VisitDocumentUpdated(*GenericEvent) error
	VisitDocumentDeleted(*GenericEvent) error
	VisitWorkbookCreated(*GenericEvent) error
	VisitWorkbookUpdated(*GenericEvent) error
	VisitWorkbookDeleted(*GenericEvent) error
	VisitWorkbookExpired(*GenericEvent) error
	VisitSheetCreated(*GenericEvent) error
	VisitSheetUpdated(*GenericEvent) error
	VisitSheetDeleted(*GenericEvent) error
	VisitSheetCountsUpdated(*GenericEvent) error
	VisitSnapshotCreated(*GenericEvent) error
	VisitRecordsCreated(*GenericEvent) error
	VisitRecordsUpdated(*GenericEvent) error
	VisitRecordsDeleted(*GenericEvent) error
	VisitFileCreated(*GenericEvent) error
	VisitFileUpdated(*GenericEvent) error
	VisitFileDeleted(*GenericEvent) error
	VisitFileExpired(*GenericEvent) error
	VisitJobCreated(*GenericEvent) error
	VisitJobUpdated(*GenericEvent) error
	VisitJobDeleted(*GenericEvent) error
	VisitJobFailed(*GenericEvent) error
	VisitJobCompleted(*GenericEvent) error
	VisitJobReady(*GenericEvent) error
	VisitJobScheduled(*GenericEvent) error
	VisitJobOutcomeAcknowledged(*GenericEvent) error
	VisitJobPartsCompleted(*GenericEvent) error
	VisitProgramCreated(*GenericEvent) error
	VisitProgramUpdated(*GenericEvent) error
	VisitCommitCreated(*GenericEvent) error
	VisitCommitUpdated(*GenericEvent) error
	VisitCommitCompleted(*GenericEvent) error
	VisitSecretCreated(*GenericEvent) error
	VisitSecretUpdated(*GenericEvent) error
	VisitSecretDeleted(*GenericEvent) error
	VisitLayerCreated(*GenericEvent) error
	VisitEnvironmentCreated(*GenericEvent) error
	VisitEnvironmentUpdated(*GenericEvent) error
	VisitEnvironmentDeleted(*GenericEvent) error
	VisitActionCreated(*GenericEvent) error
	VisitActionUpdated(*GenericEvent) error
	VisitActionDeleted(*GenericEvent) error
	VisitDataClipCreated(*GenericEvent) error
	VisitDataClipUpdated(*GenericEvent) error
	VisitDataClipDeleted(*GenericEvent) error
	VisitDataClipCollaboratorUpdated(*GenericEvent) error
	VisitDataClipResolutionsCreated(*GenericEvent) error
	VisitDataClipResolutionsUpdated(*GenericEvent) error
	VisitDataClipResolutionsRefreshed(*GenericEvent) error
}

func (e *Event) Accept(visitor EventVisitor) error {
	switch e.Topic {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Topic, e)
	case "agent:created":
		return visitor.VisitAgentCreated(e.AgentCreated)
	case "agent:updated":
		return visitor.VisitAgentUpdated(e.AgentUpdated)
	case "agent:deleted":
		return visitor.VisitAgentDeleted(e.AgentDeleted)
	case "space:created":
		return visitor.VisitSpaceCreated(e.SpaceCreated)
	case "space:updated":
		return visitor.VisitSpaceUpdated(e.SpaceUpdated)
	case "space:deleted":
		return visitor.VisitSpaceDeleted(e.SpaceDeleted)
	case "space:archived":
		return visitor.VisitSpaceArchived(e.SpaceArchived)
	case "space:expired":
		return visitor.VisitSpaceExpired(e.SpaceExpired)
	case "space:guestAdded":
		return visitor.VisitSpaceGuestAdded(e.SpaceGuestAdded)
	case "space:guestRemoved":
		return visitor.VisitSpaceGuestRemoved(e.SpaceGuestRemoved)
	case "document:created":
		return visitor.VisitDocumentCreated(e.DocumentCreated)
	case "document:updated":
		return visitor.VisitDocumentUpdated(e.DocumentUpdated)
	case "document:deleted":
		return visitor.VisitDocumentDeleted(e.DocumentDeleted)
	case "workbook:created":
		return visitor.VisitWorkbookCreated(e.WorkbookCreated)
	case "workbook:updated":
		return visitor.VisitWorkbookUpdated(e.WorkbookUpdated)
	case "workbook:deleted":
		return visitor.VisitWorkbookDeleted(e.WorkbookDeleted)
	case "workbook:expired":
		return visitor.VisitWorkbookExpired(e.WorkbookExpired)
	case "sheet:created":
		return visitor.VisitSheetCreated(e.SheetCreated)
	case "sheet:updated":
		return visitor.VisitSheetUpdated(e.SheetUpdated)
	case "sheet:deleted":
		return visitor.VisitSheetDeleted(e.SheetDeleted)
	case "sheet:counts-updated":
		return visitor.VisitSheetCountsUpdated(e.SheetCountsUpdated)
	case "snapshot:created":
		return visitor.VisitSnapshotCreated(e.SnapshotCreated)
	case "records:created":
		return visitor.VisitRecordsCreated(e.RecordsCreated)
	case "records:updated":
		return visitor.VisitRecordsUpdated(e.RecordsUpdated)
	case "records:deleted":
		return visitor.VisitRecordsDeleted(e.RecordsDeleted)
	case "file:created":
		return visitor.VisitFileCreated(e.FileCreated)
	case "file:updated":
		return visitor.VisitFileUpdated(e.FileUpdated)
	case "file:deleted":
		return visitor.VisitFileDeleted(e.FileDeleted)
	case "file:expired":
		return visitor.VisitFileExpired(e.FileExpired)
	case "job:created":
		return visitor.VisitJobCreated(e.JobCreated)
	case "job:updated":
		return visitor.VisitJobUpdated(e.JobUpdated)
	case "job:deleted":
		return visitor.VisitJobDeleted(e.JobDeleted)
	case "job:failed":
		return visitor.VisitJobFailed(e.JobFailed)
	case "job:completed":
		return visitor.VisitJobCompleted(e.JobCompleted)
	case "job:ready":
		return visitor.VisitJobReady(e.JobReady)
	case "job:scheduled":
		return visitor.VisitJobScheduled(e.JobScheduled)
	case "job:outcome-acknowledged":
		return visitor.VisitJobOutcomeAcknowledged(e.JobOutcomeAcknowledged)
	case "job:parts-completed":
		return visitor.VisitJobPartsCompleted(e.JobPartsCompleted)
	case "program:created":
		return visitor.VisitProgramCreated(e.ProgramCreated)
	case "program:updated":
		return visitor.VisitProgramUpdated(e.ProgramUpdated)
	case "commit:created":
		return visitor.VisitCommitCreated(e.CommitCreated)
	case "commit:updated":
		return visitor.VisitCommitUpdated(e.CommitUpdated)
	case "commit:completed":
		return visitor.VisitCommitCompleted(e.CommitCompleted)
	case "secret:created":
		return visitor.VisitSecretCreated(e.SecretCreated)
	case "secret:updated":
		return visitor.VisitSecretUpdated(e.SecretUpdated)
	case "secret:deleted":
		return visitor.VisitSecretDeleted(e.SecretDeleted)
	case "layer:created":
		return visitor.VisitLayerCreated(e.LayerCreated)
	case "environment:created":
		return visitor.VisitEnvironmentCreated(e.EnvironmentCreated)
	case "environment:updated":
		return visitor.VisitEnvironmentUpdated(e.EnvironmentUpdated)
	case "environment:deleted":
		return visitor.VisitEnvironmentDeleted(e.EnvironmentDeleted)
	case "action:created":
		return visitor.VisitActionCreated(e.ActionCreated)
	case "action:updated":
		return visitor.VisitActionUpdated(e.ActionUpdated)
	case "action:deleted":
		return visitor.VisitActionDeleted(e.ActionDeleted)
	case "data-clip:created":
		return visitor.VisitDataClipCreated(e.DataClipCreated)
	case "data-clip:updated":
		return visitor.VisitDataClipUpdated(e.DataClipUpdated)
	case "data-clip:deleted":
		return visitor.VisitDataClipDeleted(e.DataClipDeleted)
	case "data-clip:collaborator-updated":
		return visitor.VisitDataClipCollaboratorUpdated(e.DataClipCollaboratorUpdated)
	case "data-clip:resolutions-created":
		return visitor.VisitDataClipResolutionsCreated(e.DataClipResolutionsCreated)
	case "data-clip:resolutions-updated":
		return visitor.VisitDataClipResolutionsUpdated(e.DataClipResolutionsUpdated)
	case "data-clip:resolutions-refreshed":
		return visitor.VisitDataClipResolutionsRefreshed(e.DataClipResolutionsRefreshed)
	}
}

// The attributes of the event
type EventAttributes struct {
	// Date the related entity was last updated
	TargetUpdatedAt *time.Time `json:"targetUpdatedAt,omitempty" url:"targetUpdatedAt,omitempty"`
	// The progress of the event within a collection of iterable events
	Progress *Progress `json:"progress,omitempty" url:"progress,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventAttributes) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventAttributes) UnmarshalJSON(data []byte) error {
	type embed EventAttributes
	var unmarshaler = struct {
		embed
		TargetUpdatedAt *core.DateTime `json:"targetUpdatedAt,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventAttributes(unmarshaler.embed)
	e.TargetUpdatedAt = unmarshaler.TargetUpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventAttributes) MarshalJSON() ([]byte, error) {
	type embed EventAttributes
	var marshaler = struct {
		embed
		TargetUpdatedAt *core.DateTime `json:"targetUpdatedAt,omitempty"`
	}{
		embed:           embed(*e),
		TargetUpdatedAt: core.NewOptionalDateTime(e.TargetUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EventAttributes) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventContextSlugs struct {
	// The slug of the space
	Space *string `json:"space,omitempty" url:"space,omitempty"`
	// The slug of the workbook
	Workbook *string `json:"workbook,omitempty" url:"workbook,omitempty"`
	// The slug of the sheet
	Sheet *string `json:"sheet,omitempty" url:"sheet,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventContextSlugs) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventContextSlugs) UnmarshalJSON(data []byte) error {
	type unmarshaler EventContextSlugs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventContextSlugs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventContextSlugs) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventResponse struct {
	Data *Event `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The topic of the event
type EventTopic string

const (
	EventTopicAgentCreated                 EventTopic = "agent:created"
	EventTopicAgentUpdated                 EventTopic = "agent:updated"
	EventTopicAgentDeleted                 EventTopic = "agent:deleted"
	EventTopicSpaceCreated                 EventTopic = "space:created"
	EventTopicSpaceUpdated                 EventTopic = "space:updated"
	EventTopicSpaceDeleted                 EventTopic = "space:deleted"
	EventTopicSpaceArchived                EventTopic = "space:archived"
	EventTopicSpaceUnarchived              EventTopic = "space:unarchived"
	EventTopicSpaceExpired                 EventTopic = "space:expired"
	EventTopicSpaceGuestAdded              EventTopic = "space:guestAdded"
	EventTopicSpaceGuestRemoved            EventTopic = "space:guestRemoved"
	EventTopicDocumentCreated              EventTopic = "document:created"
	EventTopicDocumentUpdated              EventTopic = "document:updated"
	EventTopicDocumentDeleted              EventTopic = "document:deleted"
	EventTopicWorkbookCreated              EventTopic = "workbook:created"
	EventTopicWorkbookUpdated              EventTopic = "workbook:updated"
	EventTopicWorkbookDeleted              EventTopic = "workbook:deleted"
	EventTopicWorkbookExpired              EventTopic = "workbook:expired"
	EventTopicSheetCreated                 EventTopic = "sheet:created"
	EventTopicSheetUpdated                 EventTopic = "sheet:updated"
	EventTopicSheetDeleted                 EventTopic = "sheet:deleted"
	EventTopicSheetCountsUpdated           EventTopic = "sheet:counts-updated"
	EventTopicSnapshotCreated              EventTopic = "snapshot:created"
	EventTopicRecordsCreated               EventTopic = "records:created"
	EventTopicRecordsUpdated               EventTopic = "records:updated"
	EventTopicRecordsDeleted               EventTopic = "records:deleted"
	EventTopicFileCreated                  EventTopic = "file:created"
	EventTopicFileUpdated                  EventTopic = "file:updated"
	EventTopicFileDeleted                  EventTopic = "file:deleted"
	EventTopicFileExpired                  EventTopic = "file:expired"
	EventTopicJobCreated                   EventTopic = "job:created"
	EventTopicJobUpdated                   EventTopic = "job:updated"
	EventTopicJobDeleted                   EventTopic = "job:deleted"
	EventTopicJobCompleted                 EventTopic = "job:completed"
	EventTopicJobReady                     EventTopic = "job:ready"
	EventTopicJobScheduled                 EventTopic = "job:scheduled"
	EventTopicJobOutcomeAcknowledged       EventTopic = "job:outcome-acknowledged"
	EventTopicJobPartsCompleted            EventTopic = "job:parts-completed"
	EventTopicJobFailed                    EventTopic = "job:failed"
	EventTopicProgramCreated               EventTopic = "program:created"
	EventTopicProgramUpdated               EventTopic = "program:updated"
	EventTopicCommitCreated                EventTopic = "commit:created"
	EventTopicCommitUpdated                EventTopic = "commit:updated"
	EventTopicCommitCompleted              EventTopic = "commit:completed"
	EventTopicLayerCreated                 EventTopic = "layer:created"
	EventTopicSecretCreated                EventTopic = "secret:created"
	EventTopicSecretUpdated                EventTopic = "secret:updated"
	EventTopicSecretDeleted                EventTopic = "secret:deleted"
	EventTopicCron5Minutes                 EventTopic = "cron:5-minutes"
	EventTopicCronHourly                   EventTopic = "cron:hourly"
	EventTopicCronDaily                    EventTopic = "cron:daily"
	EventTopicCronWeekly                   EventTopic = "cron:weekly"
	EventTopicEnvironmentCreated           EventTopic = "environment:created"
	EventTopicEnvironmentUpdated           EventTopic = "environment:updated"
	EventTopicEnvironmentDeleted           EventTopic = "environment:deleted"
	EventTopicActionCreated                EventTopic = "action:created"
	EventTopicActionUpdated                EventTopic = "action:updated"
	EventTopicActionDeleted                EventTopic = "action:deleted"
	EventTopicDataClipCreated              EventTopic = "data-clip:created"
	EventTopicDataClipUpdated              EventTopic = "data-clip:updated"
	EventTopicDataClipDeleted              EventTopic = "data-clip:deleted"
	EventTopicDataClipCollaboratorUpdated  EventTopic = "data-clip:collaborator-updated"
	EventTopicDataClipResolutionsCreated   EventTopic = "data-clip:resolutions-created"
	EventTopicDataClipResolutionsUpdated   EventTopic = "data-clip:resolutions-updated"
	EventTopicDataClipResolutionsRefreshed EventTopic = "data-clip:resolutions-refreshed"
)

func NewEventTopicFromString(s string) (EventTopic, error) {
	switch s {
	case "agent:created":
		return EventTopicAgentCreated, nil
	case "agent:updated":
		return EventTopicAgentUpdated, nil
	case "agent:deleted":
		return EventTopicAgentDeleted, nil
	case "space:created":
		return EventTopicSpaceCreated, nil
	case "space:updated":
		return EventTopicSpaceUpdated, nil
	case "space:deleted":
		return EventTopicSpaceDeleted, nil
	case "space:archived":
		return EventTopicSpaceArchived, nil
	case "space:unarchived":
		return EventTopicSpaceUnarchived, nil
	case "space:expired":
		return EventTopicSpaceExpired, nil
	case "space:guestAdded":
		return EventTopicSpaceGuestAdded, nil
	case "space:guestRemoved":
		return EventTopicSpaceGuestRemoved, nil
	case "document:created":
		return EventTopicDocumentCreated, nil
	case "document:updated":
		return EventTopicDocumentUpdated, nil
	case "document:deleted":
		return EventTopicDocumentDeleted, nil
	case "workbook:created":
		return EventTopicWorkbookCreated, nil
	case "workbook:updated":
		return EventTopicWorkbookUpdated, nil
	case "workbook:deleted":
		return EventTopicWorkbookDeleted, nil
	case "workbook:expired":
		return EventTopicWorkbookExpired, nil
	case "sheet:created":
		return EventTopicSheetCreated, nil
	case "sheet:updated":
		return EventTopicSheetUpdated, nil
	case "sheet:deleted":
		return EventTopicSheetDeleted, nil
	case "sheet:counts-updated":
		return EventTopicSheetCountsUpdated, nil
	case "snapshot:created":
		return EventTopicSnapshotCreated, nil
	case "records:created":
		return EventTopicRecordsCreated, nil
	case "records:updated":
		return EventTopicRecordsUpdated, nil
	case "records:deleted":
		return EventTopicRecordsDeleted, nil
	case "file:created":
		return EventTopicFileCreated, nil
	case "file:updated":
		return EventTopicFileUpdated, nil
	case "file:deleted":
		return EventTopicFileDeleted, nil
	case "file:expired":
		return EventTopicFileExpired, nil
	case "job:created":
		return EventTopicJobCreated, nil
	case "job:updated":
		return EventTopicJobUpdated, nil
	case "job:deleted":
		return EventTopicJobDeleted, nil
	case "job:completed":
		return EventTopicJobCompleted, nil
	case "job:ready":
		return EventTopicJobReady, nil
	case "job:scheduled":
		return EventTopicJobScheduled, nil
	case "job:outcome-acknowledged":
		return EventTopicJobOutcomeAcknowledged, nil
	case "job:parts-completed":
		return EventTopicJobPartsCompleted, nil
	case "job:failed":
		return EventTopicJobFailed, nil
	case "program:created":
		return EventTopicProgramCreated, nil
	case "program:updated":
		return EventTopicProgramUpdated, nil
	case "commit:created":
		return EventTopicCommitCreated, nil
	case "commit:updated":
		return EventTopicCommitUpdated, nil
	case "commit:completed":
		return EventTopicCommitCompleted, nil
	case "layer:created":
		return EventTopicLayerCreated, nil
	case "secret:created":
		return EventTopicSecretCreated, nil
	case "secret:updated":
		return EventTopicSecretUpdated, nil
	case "secret:deleted":
		return EventTopicSecretDeleted, nil
	case "cron:5-minutes":
		return EventTopicCron5Minutes, nil
	case "cron:hourly":
		return EventTopicCronHourly, nil
	case "cron:daily":
		return EventTopicCronDaily, nil
	case "cron:weekly":
		return EventTopicCronWeekly, nil
	case "environment:created":
		return EventTopicEnvironmentCreated, nil
	case "environment:updated":
		return EventTopicEnvironmentUpdated, nil
	case "environment:deleted":
		return EventTopicEnvironmentDeleted, nil
	case "action:created":
		return EventTopicActionCreated, nil
	case "action:updated":
		return EventTopicActionUpdated, nil
	case "action:deleted":
		return EventTopicActionDeleted, nil
	case "data-clip:created":
		return EventTopicDataClipCreated, nil
	case "data-clip:updated":
		return EventTopicDataClipUpdated, nil
	case "data-clip:deleted":
		return EventTopicDataClipDeleted, nil
	case "data-clip:collaborator-updated":
		return EventTopicDataClipCollaboratorUpdated, nil
	case "data-clip:resolutions-created":
		return EventTopicDataClipResolutionsCreated, nil
	case "data-clip:resolutions-updated":
		return EventTopicDataClipResolutionsUpdated, nil
	case "data-clip:resolutions-refreshed":
		return EventTopicDataClipResolutionsRefreshed, nil
	}
	var t EventTopic
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventTopic) Ptr() *EventTopic {
	return &e
}

type GenericEvent struct {
	// The domain of the event
	Domain Domain `json:"domain" url:"domain"`
	// The context of the event
	Context *Context `json:"context,omitempty" url:"context,omitempty"`
	// The attributes of the event
	Attributes *EventAttributes `json:"attributes,omitempty" url:"attributes,omitempty"`
	// The callback url to acknowledge the event
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// The url to retrieve the data associated with the event
	DataUrl    *string  `json:"dataUrl,omitempty" url:"dataUrl,omitempty"`
	Target     *string  `json:"target,omitempty" url:"target,omitempty"`
	Origin     *Origin  `json:"origin,omitempty" url:"origin,omitempty"`
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`
	Id         EventId  `json:"id" url:"id"`
	// Date the event was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the event was deleted
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`
	// Date the event was acknowledged
	AcknowledgedAt *time.Time `json:"acknowledgedAt,omitempty" url:"acknowledgedAt,omitempty"`
	// The actor (user or system) who acknowledged the event
	AcknowledgedBy *string                `json:"acknowledgedBy,omitempty" url:"acknowledgedBy,omitempty"`
	Payload        map[string]interface{} `json:"payload,omitempty" url:"payload,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GenericEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenericEvent) UnmarshalJSON(data []byte) error {
	type embed GenericEvent
	var unmarshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"createdAt"`
		DeletedAt      *core.DateTime `json:"deletedAt,omitempty"`
		AcknowledgedAt *core.DateTime `json:"acknowledgedAt,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GenericEvent(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	g.AcknowledgedAt = unmarshaler.AcknowledgedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenericEvent) MarshalJSON() ([]byte, error) {
	type embed GenericEvent
	var marshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"createdAt"`
		DeletedAt      *core.DateTime `json:"deletedAt,omitempty"`
		AcknowledgedAt *core.DateTime `json:"acknowledgedAt,omitempty"`
	}{
		embed:          embed(*g),
		CreatedAt:      core.NewDateTime(g.CreatedAt),
		DeletedAt:      core.NewOptionalDateTime(g.DeletedAt),
		AcknowledgedAt: core.NewOptionalDateTime(g.AcknowledgedAt),
	}
	return json.Marshal(marshaler)
}

func (g *GenericEvent) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListAllEventsResponse struct {
	Data []*Event `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListAllEventsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListAllEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListAllEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListAllEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListAllEventsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The origin resource of the event
type Origin struct {
	Id   *string `json:"id,omitempty" url:"id,omitempty"`
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Origin) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Origin) UnmarshalJSON(data []byte) error {
	type unmarshaler Origin
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Origin(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Origin) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The progress of the event within a collection of iterable events
type Progress struct {
	// The current progress of the event
	Current *int `json:"current,omitempty" url:"current,omitempty"`
	// The total number of events in this group
	Total *int `json:"total,omitempty" url:"total,omitempty"`
	// The percent complete of the event group
	Percent *int `json:"percent,omitempty" url:"percent,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Progress) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Progress) UnmarshalJSON(data []byte) error {
	type unmarshaler Progress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Progress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Progress) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Sheet Slug
type SheetSlug = string

type ArrayableProperty struct {
	// Will allow multiple values and store as an array
	IsArray *bool `json:"isArray,omitempty" url:"isArray,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ArrayableProperty) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ArrayableProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ArrayableProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArrayableProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArrayableProperty) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BaseProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BaseProperty) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseProperty) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A `true` or `false` value type. Matching engines should attempt to resolve all common ways of representing this value and it should usually be displayed as a checkbox.
type BooleanProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string               `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string               `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *BooleanPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BooleanProperty) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanProperty) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BooleanPropertyConfig struct {
	// Allow a neither true or false state to be stored as `null`
	AllowIndeterminate bool `json:"allowIndeterminate" url:"allowIndeterminate"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BooleanPropertyConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanPropertyConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanPropertyConfig) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Constraint struct {
	Type     string
	Required interface{}
	Unique   *UniqueConstraint
	Computed interface{}
	External *ExternalConstraint
	Stored   *StoredConstraint
}

func NewConstraintFromRequired(value interface{}) *Constraint {
	return &Constraint{Type: "required", Required: value}
}

func NewConstraintFromUnique(value *UniqueConstraint) *Constraint {
	return &Constraint{Type: "unique", Unique: value}
}

func NewConstraintFromComputed(value interface{}) *Constraint {
	return &Constraint{Type: "computed", Computed: value}
}

func NewConstraintFromExternal(value *ExternalConstraint) *Constraint {
	return &Constraint{Type: "external", External: value}
}

func NewConstraintFromStored(value *StoredConstraint) *Constraint {
	return &Constraint{Type: "stored", Stored: value}
}

func (c *Constraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "required":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Required = value
	case "unique":
		value := new(UniqueConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Unique = value
	case "computed":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Computed = value
	case "external":
		value := new(ExternalConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.External = value
	case "stored":
		value := new(StoredConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Stored = value
	}
	return nil
}

func (c Constraint) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "required":
		var marshaler = struct {
			Type     string      `json:"type"`
			Required interface{} `json:"required,omitempty"`
		}{
			Type:     "required",
			Required: c.Required,
		}
		return json.Marshal(marshaler)
	case "unique":
		return core.MarshalJSONWithExtraProperty(c.Unique, "type", "unique")
	case "computed":
		var marshaler = struct {
			Type     string      `json:"type"`
			Computed interface{} `json:"computed,omitempty"`
		}{
			Type:     "computed",
			Computed: c.Computed,
		}
		return json.Marshal(marshaler)
	case "external":
		return core.MarshalJSONWithExtraProperty(c.External, "type", "external")
	case "stored":
		return core.MarshalJSONWithExtraProperty(c.Stored, "type", "stored")
	}
}

type ConstraintVisitor interface {
	VisitRequired(interface{}) error
	VisitUnique(*UniqueConstraint) error
	VisitComputed(interface{}) error
	VisitExternal(*ExternalConstraint) error
	VisitStored(*StoredConstraint) error
}

func (c *Constraint) Accept(visitor ConstraintVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "required":
		return visitor.VisitRequired(c.Required)
	case "unique":
		return visitor.VisitUnique(c.Unique)
	case "computed":
		return visitor.VisitComputed(c.Computed)
	case "external":
		return visitor.VisitExternal(c.External)
	case "stored":
		return visitor.VisitStored(c.Stored)
	}
}

// Store a field as a GMT date. Data hooks must convert this value into a `YYYY-MM-DD` format in order for it to be considered a valid value. Datetime should be a separate and future supported value as it must consider timezone.
type DateProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DateProperty) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler DateProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateProperty) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines an array of values selected from an enumerated list of options. Matching tooling attempts to resolve incoming data assigment to a valid option. The maximum number of items that can be in this list is `100`.
type EnumListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string            `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string            `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *EnumPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumListProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumListProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumListProperty) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Defines an enumerated list of options for the user to select from. Matching tooling attempts to resolve incoming data assigment to a valid option. The maximum number of options for this list is `100`. For larger lists, users should use the reference or future `lookup` types.
type EnumProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool `json:"isArray,omitempty" url:"isArray,omitempty"`
	// Will allow multiple values and store / provide the values in an array if set. Not all field types support arrays.
	Multi  *bool               `json:"multi,omitempty" url:"multi,omitempty"`
	Config *EnumPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumProperty) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertyConfig struct {
	// Permit the user to create new options for this specific field.
	AllowCustom *bool                 `json:"allowCustom,omitempty" url:"allowCustom,omitempty"`
	Options     []*EnumPropertyOption `json:"options,omitempty" url:"options,omitempty"`
	// Sort the options by the value of this property. Defaults to `label`.
	SortBy *EnumPropertySortBy `json:"sortBy,omitempty" url:"sortBy,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumPropertyConfig) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumPropertyConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumPropertyConfig) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertyOption struct {
	// A visual label for this option
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// An optional color to assign this option
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// A reference pointer to a previously registered icon
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// An arbitrary JSON object to be associated with this option and made available to hooks
	Meta map[string]interface{} `json:"meta,omitempty" url:"meta,omitempty"`
	// The value or ID of this option. This value will be sent in egress. The type is a string | integer | boolean.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Alternative names to match this enum option to
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// The order of this option in the list. SortBy must be set to `ordinal` to use this.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumPropertyOption) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumPropertyOption) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumPropertyOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumPropertyOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumPropertyOption) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertySortBy string

const (
	EnumPropertySortByLabel   EnumPropertySortBy = "label"
	EnumPropertySortByValue   EnumPropertySortBy = "value"
	EnumPropertySortByOrdinal EnumPropertySortBy = "ordinal"
)

func NewEnumPropertySortByFromString(s string) (EnumPropertySortBy, error) {
	switch s {
	case "label":
		return EnumPropertySortByLabel, nil
	case "value":
		return EnumPropertySortByValue, nil
	case "ordinal":
		return EnumPropertySortByOrdinal, nil
	}
	var t EnumPropertySortBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnumPropertySortBy) Ptr() *EnumPropertySortBy {
	return &e
}

type ExternalConstraint struct {
	Validator string      `json:"validator" url:"validator"`
	Config    interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExternalConstraint) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalConstraint) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Control the appearance of this field when it's displayed in a table or input
type FieldAppearance struct {
	Size *FieldSize `json:"size,omitempty" url:"size,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FieldAppearance) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldAppearance) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldAppearance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldAppearance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldAppearance) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The default visual sizing. This sizing may be overridden by a user
type FieldSize string

const (
	FieldSizeXs FieldSize = "xs"
	FieldSizeS  FieldSize = "s"
	FieldSizeM  FieldSize = "m"
	FieldSizeL  FieldSize = "l"
	FieldSizeXl FieldSize = "xl"
)

func NewFieldSizeFromString(s string) (FieldSize, error) {
	switch s {
	case "xs":
		return FieldSizeXs, nil
	case "s":
		return FieldSizeS, nil
	case "m":
		return FieldSizeM, nil
	case "l":
		return FieldSizeL, nil
	case "xl":
		return FieldSizeXl, nil
	}
	var t FieldSize
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldSize) Ptr() *FieldSize {
	return &f
}

type NumberConfig struct {
	// Number of decimal places to round data to
	DecimalPlaces *int `json:"decimalPlaces,omitempty" url:"decimalPlaces,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NumberConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberConfig) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Defines a property that should be stored and read as either an integer or floating point number. Database engines should look at the configuration to determine ideal storage format.
type NumberProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool         `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *NumberConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NumberProperty) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberProperty) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type Property struct {
	Type          string
	String        *StringProperty
	Number        *NumberProperty
	Boolean       *BooleanProperty
	Date          *DateProperty
	Enum          *EnumProperty
	Reference     *ReferenceProperty
	ReferenceList *ReferenceListProperty
	StringList    *StringListProperty
	EnumList      *EnumListProperty
}

func NewPropertyFromString(value *StringProperty) *Property {
	return &Property{Type: "string", String: value}
}

func NewPropertyFromNumber(value *NumberProperty) *Property {
	return &Property{Type: "number", Number: value}
}

func NewPropertyFromBoolean(value *BooleanProperty) *Property {
	return &Property{Type: "boolean", Boolean: value}
}

func NewPropertyFromDate(value *DateProperty) *Property {
	return &Property{Type: "date", Date: value}
}

func NewPropertyFromEnum(value *EnumProperty) *Property {
	return &Property{Type: "enum", Enum: value}
}

func NewPropertyFromReference(value *ReferenceProperty) *Property {
	return &Property{Type: "reference", Reference: value}
}

func NewPropertyFromReferenceList(value *ReferenceListProperty) *Property {
	return &Property{Type: "reference-list", ReferenceList: value}
}

func NewPropertyFromStringList(value *StringListProperty) *Property {
	return &Property{Type: "string-list", StringList: value}
}

func NewPropertyFromEnumList(value *EnumListProperty) *Property {
	return &Property{Type: "enum-list", EnumList: value}
}

func (p *Property) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "string":
		value := new(StringProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.String = value
	case "number":
		value := new(NumberProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Number = value
	case "boolean":
		value := new(BooleanProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Boolean = value
	case "date":
		value := new(DateProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Date = value
	case "enum":
		value := new(EnumProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Enum = value
	case "reference":
		value := new(ReferenceProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Reference = value
	case "reference-list":
		value := new(ReferenceListProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ReferenceList = value
	case "string-list":
		value := new(StringListProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StringList = value
	case "enum-list":
		value := new(EnumListProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EnumList = value
	}
	return nil
}

func (p Property) MarshalJSON() ([]byte, error) {
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "string":
		return core.MarshalJSONWithExtraProperty(p.String, "type", "string")
	case "number":
		return core.MarshalJSONWithExtraProperty(p.Number, "type", "number")
	case "boolean":
		return core.MarshalJSONWithExtraProperty(p.Boolean, "type", "boolean")
	case "date":
		return core.MarshalJSONWithExtraProperty(p.Date, "type", "date")
	case "enum":
		return core.MarshalJSONWithExtraProperty(p.Enum, "type", "enum")
	case "reference":
		return core.MarshalJSONWithExtraProperty(p.Reference, "type", "reference")
	case "reference-list":
		return core.MarshalJSONWithExtraProperty(p.ReferenceList, "type", "reference-list")
	case "string-list":
		return core.MarshalJSONWithExtraProperty(p.StringList, "type", "string-list")
	case "enum-list":
		return core.MarshalJSONWithExtraProperty(p.EnumList, "type", "enum-list")
	}
}

type PropertyVisitor interface {
	VisitString(*StringProperty) error
	VisitNumber(*NumberProperty) error
	VisitBoolean(*BooleanProperty) error
	VisitDate(*DateProperty) error
	VisitEnum(*EnumProperty) error
	VisitReference(*ReferenceProperty) error
	VisitReferenceList(*ReferenceListProperty) error
	VisitStringList(*StringListProperty) error
	VisitEnumList(*EnumListProperty) error
}

func (p *Property) Accept(visitor PropertyVisitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "string":
		return visitor.VisitString(p.String)
	case "number":
		return visitor.VisitNumber(p.Number)
	case "boolean":
		return visitor.VisitBoolean(p.Boolean)
	case "date":
		return visitor.VisitDate(p.Date)
	case "enum":
		return visitor.VisitEnum(p.Enum)
	case "reference":
		return visitor.VisitReference(p.Reference)
	case "reference-list":
		return visitor.VisitReferenceList(p.ReferenceList)
	case "string-list":
		return visitor.VisitStringList(p.StringList)
	case "enum-list":
		return visitor.VisitEnumList(p.EnumList)
	}
}

// Defines an array of values referenced from another sheet. Links should be established automatically by the matching engine or similar upon an evaluation of unique or similar columns between datasets.
type ReferenceListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool                        `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *ReferenceListPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferenceListProperty) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceListProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceListProperty) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferenceListPropertyConfig struct {
	// Full path reference to a sheet configuration. Must be in the same workbook.
	Ref string `json:"ref" url:"ref"`
	// Key of the property to use as the reference key. Defaults to `id`
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferenceListPropertyConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceListPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceListPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceListPropertyConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceListPropertyConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines a reference to another sheet. Links should be established automatically by the matching engine or similar upon an evaluation of unique or similar columns between datasets.
type ReferenceProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool                    `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *ReferencePropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferenceProperty) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceProperty) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencePropertyConfig struct {
	// Full path reference to a sheet configuration. Must be in the same workbook.
	Ref string `json:"ref" url:"ref"`
	// Key of the property to use as the reference key. Defaults to `id`
	Key string `json:"key" url:"key"`
	// The type of relationship this defines
	Relationship *ReferencePropertyRelationship `json:"relationship,omitempty" url:"relationship,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferencePropertyConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferencePropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencePropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencePropertyConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferencePropertyConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencePropertyRelationship string

const (
	ReferencePropertyRelationshipHasOne  ReferencePropertyRelationship = "has-one"
	ReferencePropertyRelationshipHasMany ReferencePropertyRelationship = "has-many"
)

func NewReferencePropertyRelationshipFromString(s string) (ReferencePropertyRelationship, error) {
	switch s {
	case "has-one":
		return ReferencePropertyRelationshipHasOne, nil
	case "has-many":
		return ReferencePropertyRelationshipHasMany, nil
	}
	var t ReferencePropertyRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReferencePropertyRelationship) Ptr() *ReferencePropertyRelationship {
	return &r
}

type StoredConstraint struct {
	// Must match the constraint validator name.
	Validator string `json:"validator" url:"validator"`
	// The version of the stored constraint to use. (Defaults to version 1.)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A full description of what this constraint configuration does
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A short description of what this constraint constraint should do, example - values between 1 and 100
	Label  *string     `json:"label,omitempty" url:"label,omitempty"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StoredConstraint) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StoredConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler StoredConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StoredConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StoredConstraint) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StringConfig struct {
	Size StringConfigOptions `json:"size" url:"size"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StringConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler StringConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// How much text should be storeable in this field
type StringConfigOptions string

const (
	// up to 255 characters
	StringConfigOptionsTiny StringConfigOptions = "tiny"
	// 64kb (default)
	StringConfigOptionsNormal StringConfigOptions = "normal"
	// 16mb
	StringConfigOptionsMedium StringConfigOptions = "medium"
	// 4gb
	StringConfigOptionsLong StringConfigOptions = "long"
)

func NewStringConfigOptionsFromString(s string) (StringConfigOptions, error) {
	switch s {
	case "tiny":
		return StringConfigOptionsTiny, nil
	case "normal":
		return StringConfigOptionsNormal, nil
	case "medium":
		return StringConfigOptionsMedium, nil
	case "long":
		return StringConfigOptionsLong, nil
	}
	var t StringConfigOptions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StringConfigOptions) Ptr() *StringConfigOptions {
	return &s
}

// Defines a property that should be stored and read as an array of strings. Database engines should expect any number of items to be provided here. The maximum number of items that can be in this list is `100`.
type StringListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StringListProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler StringListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringListProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringListProperty) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines a property that should be stored and read as a basic string. Database engines should expect any length of text to be provided here unless explicitly defined in the config.
type StringProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string      `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string      `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *StringConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StringProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler StringProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringProperty) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UniqueConstraint struct {
	Config *UniqueConstraintConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UniqueConstraint) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UniqueConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler UniqueConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UniqueConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UniqueConstraint) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UniqueConstraintConfig struct {
	// Ignore casing when determining uniqueness
	CaseSensitive *bool `json:"caseSensitive,omitempty" url:"caseSensitive,omitempty"`
	// Do not flag empty values as duplicate
	IgnoreEmpty *bool `json:"ignoreEmpty,omitempty" url:"ignoreEmpty,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UniqueConstraintConfig) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UniqueConstraintConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler UniqueConstraintConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UniqueConstraintConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UniqueConstraintConfig) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// CellConfig
type CellConfig struct {
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CellConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CellConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CellConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CellConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CellValue struct {
	Valid    *bool                `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// Deprecated, use record level metadata instead.
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value     *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer     *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CellValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CellValue) UnmarshalJSON(data []byte) error {
	type embed CellValue
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CellValue(unmarshaler.embed)
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellValue) MarshalJSON() ([]byte, error) {
	type embed CellValue
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CellValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CellValueUnion struct {
	String     string
	Integer    int
	Long       int64
	Double     float64
	Boolean    bool
	Date       time.Time
	DateTime   time.Time
	StringList []string

	typ string
}

func NewCellValueUnionFromString(value string) *CellValueUnion {
	return &CellValueUnion{typ: "String", String: value}
}

func NewCellValueUnionFromInteger(value int) *CellValueUnion {
	return &CellValueUnion{typ: "Integer", Integer: value}
}

func NewCellValueUnionFromLong(value int64) *CellValueUnion {
	return &CellValueUnion{typ: "Long", Long: value}
}

func NewCellValueUnionFromDouble(value float64) *CellValueUnion {
	return &CellValueUnion{typ: "Double", Double: value}
}

func NewCellValueUnionFromBoolean(value bool) *CellValueUnion {
	return &CellValueUnion{typ: "Boolean", Boolean: value}
}

func NewCellValueUnionFromDate(value time.Time) *CellValueUnion {
	return &CellValueUnion{typ: "Date", Date: value}
}

func NewCellValueUnionFromDateTime(value time.Time) *CellValueUnion {
	return &CellValueUnion{typ: "DateTime", DateTime: value}
}

func NewCellValueUnionFromStringList(value []string) *CellValueUnion {
	return &CellValueUnion{typ: "StringList", StringList: value}
}

func (c *CellValueUnion) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		c.typ = "Integer"
		c.Integer = valueInteger
		return nil
	}
	var valueLong int64
	if err := json.Unmarshal(data, &valueLong); err == nil {
		c.typ = "Long"
		c.Long = valueLong
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		c.typ = "Double"
		c.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		c.typ = "Boolean"
		c.Boolean = valueBoolean
		return nil
	}
	var valueDate *core.Date
	if err := json.Unmarshal(data, &valueDate); err == nil {
		c.typ = "Date"
		c.Date = valueDate.Time()
		return nil
	}
	var valueDateTime *core.DateTime
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		c.typ = "DateTime"
		c.DateTime = valueDateTime.Time()
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typ = "StringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CellValueUnion) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Integer" || c.Integer != 0 {
		return json.Marshal(c.Integer)
	}
	if c.typ == "Long" || c.Long != 0 {
		return json.Marshal(c.Long)
	}
	if c.typ == "Double" || c.Double != 0 {
		return json.Marshal(c.Double)
	}
	if c.typ == "Boolean" || c.Boolean != false {
		return json.Marshal(c.Boolean)
	}
	if c.typ == "Date" || !c.Date.IsZero() {
		return json.Marshal(core.NewDate(c.Date))
	}
	if c.typ == "DateTime" || !c.DateTime.IsZero() {
		return json.Marshal(core.NewDateTime(c.DateTime))
	}
	if c.typ == "StringList" || c.StringList != nil {
		return json.Marshal(c.StringList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CellValueUnionVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
	VisitLong(int64) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitDate(time.Time) error
	VisitDateTime(time.Time) error
	VisitStringList([]string) error
}

func (c *CellValueUnion) Accept(visitor CellValueUnionVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Integer" || c.Integer != 0 {
		return visitor.VisitInteger(c.Integer)
	}
	if c.typ == "Long" || c.Long != 0 {
		return visitor.VisitLong(c.Long)
	}
	if c.typ == "Double" || c.Double != 0 {
		return visitor.VisitDouble(c.Double)
	}
	if c.typ == "Boolean" || c.Boolean != false {
		return visitor.VisitBoolean(c.Boolean)
	}
	if c.typ == "Date" || !c.Date.IsZero() {
		return visitor.VisitDate(c.Date)
	}
	if c.typ == "DateTime" || !c.DateTime.IsZero() {
		return visitor.VisitDateTime(c.DateTime)
	}
	if c.typ == "StringList" || c.StringList != nil {
		return visitor.VisitStringList(c.StringList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CellValueWithLinks struct {
	Valid    *bool                `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// Deprecated, use record level metadata instead.
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value     *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer     *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	Links     *Records               `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CellValueWithLinks) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CellValueWithLinks) UnmarshalJSON(data []byte) error {
	type embed CellValueWithLinks
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CellValueWithLinks(unmarshaler.embed)
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellValueWithLinks) MarshalJSON() ([]byte, error) {
	type embed CellValueWithLinks
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CellValueWithLinks) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DiffData = map[string]*DiffValue

type DiffRecord struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`
	Values   DiffData               `json:"values,omitempty" url:"values,omitempty"`
	Resolves []*Resolve             `json:"resolves,omitempty" url:"resolves,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DiffRecord) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiffRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler DiffRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiffRecord(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffRecord) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// List of DiffRecord objects
type DiffRecords = []*DiffRecord

type DiffRecordsResponse struct {
	Data DiffRecords `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DiffRecordsResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiffRecordsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DiffRecordsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiffRecordsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffRecordsResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DiffValue struct {
	Valid    *bool                `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// Deprecated, use record level metadata instead.
	Metadata      map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value         *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer         *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt     *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	SnapshotValue *CellValueUnion        `json:"snapshotValue,omitempty" url:"snapshotValue,omitempty"`
	ClipValue     *CellValueUnion        `json:"clipValue,omitempty" url:"clipValue,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DiffValue) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiffValue) UnmarshalJSON(data []byte) error {
	type embed DiffValue
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DiffValue(unmarshaler.embed)
	d.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffValue) MarshalJSON() ([]byte, error) {
	type embed DiffValue
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*d),
		UpdatedAt: core.NewOptionalDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DiffValue) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type FieldRecordCounts struct {
	Total int `json:"total" url:"total"`
	Valid int `json:"valid" url:"valid"`
	Error int `json:"error" url:"error"`
	Empty int `json:"empty" url:"empty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FieldRecordCounts) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldRecordCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldRecordCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldRecordCounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldRecordCounts) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A single row of data in a Sheet
type Record struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`
	Values   RecordData             `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Record) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Record) UnmarshalJSON(data []byte) error {
	type unmarshaler Record
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Record(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Record) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordBase struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordBase) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordBase) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordBase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordBase) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Configuration of a record or specific fields in the record
type RecordConfig struct {
	Readonly          *bool                  `json:"readonly,omitempty" url:"readonly,omitempty"`
	Fields            map[string]*CellConfig `json:"fields,omitempty" url:"fields,omitempty"`
	MarkedForDeletion *bool                  `json:"markedForDeletion,omitempty" url:"markedForDeletion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordCounts struct {
	Total         int            `json:"total" url:"total"`
	Valid         int            `json:"valid" url:"valid"`
	Error         int            `json:"error" url:"error"`
	ErrorsByField map[string]int `json:"errorsByField,omitempty" url:"errorsByField,omitempty"`
	// Counts for valid, error, and total records grouped by field key
	ByField map[string]*FieldRecordCounts `json:"byField,omitempty" url:"byField,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordCounts) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordCounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordCounts) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A single row of data in a Sheet
type RecordData = map[string]*CellValue

// A single row of data in a Sheet, including links to related rows
type RecordDataWithLinks = map[string]*CellValueWithLinks

// A single row of data in a Sheet, including links to related rows
type RecordWithLinks struct {
	Id       RecordId               `json:"id" url:"id"`
	Values   RecordDataWithLinks    `json:"values,omitempty" url:"values,omitempty"`
	Valid    *bool                  `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordWithLinks) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordWithLinks) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordWithLinks
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordWithLinks(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordWithLinks) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// List of Record objects
type Records = []*Record

type RecordsResponse struct {
	Data *RecordsResponseData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordsResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordsResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordsResponseData struct {
	Success bool              `json:"success" url:"success"`
	Records *RecordsWithLinks `json:"records,omitempty" url:"records,omitempty"`
	Counts  *RecordCounts     `json:"counts,omitempty" url:"counts,omitempty"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordsResponseData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordsResponseData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordsResponseData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// List of Record objects, including links to related rows
type RecordsWithLinks = []*RecordWithLinks

// Record data validation messages
type ValidationMessage struct {
	Field   *string           `json:"field,omitempty" url:"field,omitempty"`
	Type    *ValidationType   `json:"type,omitempty" url:"type,omitempty"`
	Source  *ValidationSource `json:"source,omitempty" url:"source,omitempty"`
	Message *string           `json:"message,omitempty" url:"message,omitempty"`
	// This JSONPath is based on the root of mapped cell object.
	Path *JsonPathString `json:"path,omitempty" url:"path,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *ValidationMessage) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationMessage) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationSource string

const (
	ValidationSourceRequiredConstraint ValidationSource = "required-constraint"
	ValidationSourceUniqueConstraint   ValidationSource = "unique-constraint"
	ValidationSourceCustomLogic        ValidationSource = "custom-logic"
	ValidationSourceUnlinked           ValidationSource = "unlinked"
	ValidationSourceInvalidOption      ValidationSource = "invalid-option"
	ValidationSourceIsArtifact         ValidationSource = "is-artifact"
)

func NewValidationSourceFromString(s string) (ValidationSource, error) {
	switch s {
	case "required-constraint":
		return ValidationSourceRequiredConstraint, nil
	case "unique-constraint":
		return ValidationSourceUniqueConstraint, nil
	case "custom-logic":
		return ValidationSourceCustomLogic, nil
	case "unlinked":
		return ValidationSourceUnlinked, nil
	case "invalid-option":
		return ValidationSourceInvalidOption, nil
	case "is-artifact":
		return ValidationSourceIsArtifact, nil
	}
	var t ValidationSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v ValidationSource) Ptr() *ValidationSource {
	return &v
}

type ValidationType string

const (
	ValidationTypeError ValidationType = "error"
	ValidationTypeWarn  ValidationType = "warn"
	ValidationTypeInfo  ValidationType = "info"
)

func NewValidationTypeFromString(s string) (ValidationType, error) {
	switch s {
	case "error":
		return ValidationTypeError, nil
	case "warn":
		return ValidationTypeWarn, nil
	case "info":
		return ValidationTypeInfo, nil
	}
	var t ValidationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v ValidationType) Ptr() *ValidationType {
	return &v
}

type ActorRoleResponse struct {
	Id         ActorRoleId      `json:"id" url:"id"`
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ActorId    *ActorIdUnion    `json:"actorId,omitempty" url:"actorId,omitempty"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`
	CreatedAt  time.Time        `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time        `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActorRoleResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActorRoleResponse) UnmarshalJSON(data []byte) error {
	type embed ActorRoleResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ActorRoleResponse(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActorRoleResponse) MarshalJSON() ([]byte, error) {
	type embed ActorRoleResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ActorRoleResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignActorRoleRequest struct {
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssignActorRoleRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssignActorRoleRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AssignActorRoleRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssignActorRoleRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignActorRoleRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignRoleResponse struct {
	Data *AssignRoleResponseData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssignRoleResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssignRoleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AssignRoleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssignRoleResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignRoleResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignRoleResponseData struct {
	Id         ActorRoleId      `json:"id" url:"id"`
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ActorId    *ActorIdUnion    `json:"actorId,omitempty" url:"actorId,omitempty"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`
	CreatedAt  time.Time        `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time        `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssignRoleResponseData) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssignRoleResponseData) UnmarshalJSON(data []byte) error {
	type embed AssignRoleResponseData
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssignRoleResponseData(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignRoleResponseData) MarshalJSON() ([]byte, error) {
	type embed AssignRoleResponseData
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *AssignRoleResponseData) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ListActorRolesResponse struct {
	Data []*ActorRoleResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListActorRolesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListActorRolesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListActorRolesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListActorRolesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListActorRolesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ResourceIdUnion struct {
	AccountId     AccountId
	EnvironmentId EnvironmentId
	SpaceId       SpaceId

	typ string
}

func NewResourceIdUnionFromAccountId(value AccountId) *ResourceIdUnion {
	return &ResourceIdUnion{typ: "AccountId", AccountId: value}
}

func NewResourceIdUnionFromEnvironmentId(value EnvironmentId) *ResourceIdUnion {
	return &ResourceIdUnion{typ: "EnvironmentId", EnvironmentId: value}
}

func NewResourceIdUnionFromSpaceId(value SpaceId) *ResourceIdUnion {
	return &ResourceIdUnion{typ: "SpaceId", SpaceId: value}
}

func (r *ResourceIdUnion) UnmarshalJSON(data []byte) error {
	var valueAccountId AccountId
	if err := json.Unmarshal(data, &valueAccountId); err == nil {
		r.typ = "AccountId"
		r.AccountId = valueAccountId
		return nil
	}
	var valueEnvironmentId EnvironmentId
	if err := json.Unmarshal(data, &valueEnvironmentId); err == nil {
		r.typ = "EnvironmentId"
		r.EnvironmentId = valueEnvironmentId
		return nil
	}
	var valueSpaceId SpaceId
	if err := json.Unmarshal(data, &valueSpaceId); err == nil {
		r.typ = "SpaceId"
		r.SpaceId = valueSpaceId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r ResourceIdUnion) MarshalJSON() ([]byte, error) {
	if r.typ == "AccountId" || r.AccountId != "" {
		return json.Marshal(r.AccountId)
	}
	if r.typ == "EnvironmentId" || r.EnvironmentId != "" {
		return json.Marshal(r.EnvironmentId)
	}
	if r.typ == "SpaceId" || r.SpaceId != "" {
		return json.Marshal(r.SpaceId)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type ResourceIdUnionVisitor interface {
	VisitAccountId(AccountId) error
	VisitEnvironmentId(EnvironmentId) error
	VisitSpaceId(SpaceId) error
}

func (r *ResourceIdUnion) Accept(visitor ResourceIdUnionVisitor) error {
	if r.typ == "AccountId" || r.AccountId != "" {
		return visitor.VisitAccountId(r.AccountId)
	}
	if r.typ == "EnvironmentId" || r.EnvironmentId != "" {
		return visitor.VisitEnvironmentId(r.EnvironmentId)
	}
	if r.typ == "SpaceId" || r.SpaceId != "" {
		return visitor.VisitSpaceId(r.SpaceId)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type CompositeUniqueConstraint struct {
	// The name of the constraint
	Name string `json:"name" url:"name"`
	// The fields that must be unique together
	Fields []string `json:"fields,omitempty" url:"fields,omitempty"`
	// Fields that, when empty, will cause this unique constraint to be ignored
	RequiredFields []string                          `json:"requiredFields,omitempty" url:"requiredFields,omitempty"`
	Strategy       CompositeUniqueConstraintStrategy `json:"strategy" url:"strategy"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CompositeUniqueConstraint) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompositeUniqueConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler CompositeUniqueConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompositeUniqueConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompositeUniqueConstraint) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CompositeUniqueConstraintStrategy string

const (
	// A hash of the fields will be used to determine uniqueness
	CompositeUniqueConstraintStrategyHash CompositeUniqueConstraintStrategy = "hash"
	// The values of the fields will be concatenated to determine uniqueness
	CompositeUniqueConstraintStrategyConcat CompositeUniqueConstraintStrategy = "concat"
)

func NewCompositeUniqueConstraintStrategyFromString(s string) (CompositeUniqueConstraintStrategy, error) {
	switch s {
	case "hash":
		return CompositeUniqueConstraintStrategyHash, nil
	case "concat":
		return CompositeUniqueConstraintStrategyConcat, nil
	}
	var t CompositeUniqueConstraintStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CompositeUniqueConstraintStrategy) Ptr() *CompositeUniqueConstraintStrategy {
	return &c
}

type ExternalSheetConstraint struct {
	Validator string `json:"validator" url:"validator"`
	// The fields that must be unique together
	Fields []string    `json:"fields,omitempty" url:"fields,omitempty"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExternalSheetConstraint) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalSheetConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalSheetConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalSheetConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalSheetConstraint) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ListSheetsResponse struct {
	Data []*Sheet `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListSheetsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSheetsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSheetsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSheetsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSheetsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A place to store tabular data
type Sheet struct {
	// The ID of the Sheet.
	Id SheetId `json:"id" url:"id"`
	// The ID of the Workbook.
	WorkbookId WorkbookId `json:"workbookId" url:"workbookId"`
	// The name of the Sheet.
	Name string `json:"name" url:"name"`
	// The slug of the Sheet.
	Slug string `json:"slug" url:"slug"`
	// Describes shape of data as well as behavior
	Config *SheetConfig `json:"config,omitempty" url:"config,omitempty"`
	// Useful for any contextual metadata regarding the sheet. Store any valid json
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The scoped namespace of the Sheet.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// The actor who locked the Sheet.
	LockedBy *string `json:"lockedBy,omitempty" url:"lockedBy,omitempty"`
	// Date the sheet was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date the sheet was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The time the Sheet was locked.
	LockedAt *time.Time `json:"lockedAt,omitempty" url:"lockedAt,omitempty"`
	// The precomputed counts of records in the Sheet (may not exist).
	RecordCounts *RecordCounts `json:"recordCounts,omitempty" url:"recordCounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Sheet) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Sheet) UnmarshalJSON(data []byte) error {
	type embed Sheet
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		LockedAt  *core.DateTime `json:"lockedAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Sheet(unmarshaler.embed)
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.LockedAt = unmarshaler.LockedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Sheet) MarshalJSON() ([]byte, error) {
	type embed Sheet
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		LockedAt  *core.DateTime `json:"lockedAt,omitempty"`
	}{
		embed:     embed(*s),
		UpdatedAt: core.NewDateTime(s.UpdatedAt),
		CreatedAt: core.NewDateTime(s.CreatedAt),
		LockedAt:  core.NewOptionalDateTime(s.LockedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Sheet) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SheetAccess string

const (
	SheetAccessAll    SheetAccess = "*"
	SheetAccessAdd    SheetAccess = "add"
	SheetAccessEdit   SheetAccess = "edit"
	SheetAccessDelete SheetAccess = "delete"
	SheetAccessImport SheetAccess = "import"
)

func NewSheetAccessFromString(s string) (SheetAccess, error) {
	switch s {
	case "*":
		return SheetAccessAll, nil
	case "add":
		return SheetAccessAdd, nil
	case "edit":
		return SheetAccessEdit, nil
	case "delete":
		return SheetAccessDelete, nil
	case "import":
		return SheetAccessImport, nil
	}
	var t SheetAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SheetAccess) Ptr() *SheetAccess {
	return &s
}

// Describes shape of data as well as behavior
type SheetConfig struct {
	// The name of your Sheet as it will appear to your end users.
	Name string `json:"name" url:"name"`
	// A sentence or two describing the purpose of your Sheet.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A unique identifier for your Sheet.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// A boolean specifying whether or not this sheet is read only. Read only sheets are not editable by end users.
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`
	// Allow end users to add fields during mapping.
	AllowAdditionalFields *bool `json:"allowAdditionalFields,omitempty" url:"allowAdditionalFields,omitempty"`
	// The minimum confidence required to automatically map a field
	MappingConfidenceThreshold *float64 `json:"mappingConfidenceThreshold,omitempty" url:"mappingConfidenceThreshold,omitempty"`
	// Control Sheet-level access for all users.
	Access []SheetAccess `json:"access,omitempty" url:"access,omitempty"`
	// Where you define your Sheets data schema.
	Fields []*Property `json:"fields,omitempty" url:"fields,omitempty"`
	// An array of actions that end users can perform on this Sheet.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// An array of constraints that end users can perform on this Sheet.
	Constraints []*SheetConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SheetConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SheetConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SheetConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SheetConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SheetConstraint struct {
	Type     string
	Unique   *CompositeUniqueConstraint
	External *ExternalSheetConstraint
}

func NewSheetConstraintFromUnique(value *CompositeUniqueConstraint) *SheetConstraint {
	return &SheetConstraint{Type: "unique", Unique: value}
}

func NewSheetConstraintFromExternal(value *ExternalSheetConstraint) *SheetConstraint {
	return &SheetConstraint{Type: "external", External: value}
}

func (s *SheetConstraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "unique":
		value := new(CompositeUniqueConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Unique = value
	case "external":
		value := new(ExternalSheetConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.External = value
	}
	return nil
}

func (s SheetConstraint) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "unique":
		return core.MarshalJSONWithExtraProperty(s.Unique, "type", "unique")
	case "external":
		return core.MarshalJSONWithExtraProperty(s.External, "type", "external")
	}
}

type SheetConstraintVisitor interface {
	VisitUnique(*CompositeUniqueConstraint) error
	VisitExternal(*ExternalSheetConstraint) error
}

func (s *SheetConstraint) Accept(visitor SheetConstraintVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "unique":
		return visitor.VisitUnique(s.Unique)
	case "external":
		return visitor.VisitExternal(s.External)
	}
}

// Properties used to allow users to connect to the event bus
type EventToken struct {
	// The ID of the Account.
	AccountId *AccountId `json:"accountId,omitempty" url:"accountId,omitempty"`
	// The id of the event bus to subscribe to
	SubscribeKey *string `json:"subscribeKey,omitempty" url:"subscribeKey,omitempty"`
	// Time to live in minutes
	Ttl *int `json:"ttl,omitempty" url:"ttl,omitempty"`
	// This should be your API key.
	Token *string `json:"token,omitempty" url:"token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventToken) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventToken) UnmarshalJSON(data []byte) error {
	type unmarshaler EventToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventToken(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventToken) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventTokenResponse struct {
	Data *EventToken `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventTokenResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTokenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTokenResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type SpaceAccess string

const (
	SpaceAccessAll    SpaceAccess = "*"
	SpaceAccessUpload SpaceAccess = "upload"
)

func NewSpaceAccessFromString(s string) (SpaceAccess, error) {
	switch s {
	case "*":
		return SpaceAccessAll, nil
	case "upload":
		return SpaceAccessUpload, nil
	}
	var t SpaceAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SpaceAccess) Ptr() *SpaceAccess {
	return &s
}

// Configurations for the user
type User struct {
	Email      string                 `json:"email" url:"email"`
	Name       string                 `json:"name" url:"name"`
	AccountId  AccountId              `json:"accountId" url:"accountId"`
	Id         UserId                 `json:"id" url:"id"`
	Idp        string                 `json:"idp" url:"idp"`
	IdpRef     *string                `json:"idpRef,omitempty" url:"idpRef,omitempty"`
	Metadata   map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt  time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time              `json:"updatedAt" url:"updatedAt"`
	LastSeenAt *time.Time             `json:"lastSeenAt,omitempty" url:"lastSeenAt,omitempty"`
	Dashboard  *int                   `json:"dashboard,omitempty" url:"dashboard,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type embed User
	var unmarshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = User(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()
	u.LastSeenAt = unmarshaler.LastSeenAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed:      embed(*u),
		CreatedAt:  core.NewDateTime(u.CreatedAt),
		UpdatedAt:  core.NewDateTime(u.UpdatedAt),
		LastSeenAt: core.NewOptionalDateTime(u.LastSeenAt),
	}
	return json.Marshal(marshaler)
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Properties used to create a new user
type UserConfig struct {
	Email     string    `json:"email" url:"email"`
	Name      string    `json:"name" url:"name"`
	AccountId AccountId `json:"accountId" url:"accountId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserConfig) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler UserConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserConfig) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserResponse struct {
	Data *User `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type Version struct {
	VersionId VersionId `json:"versionId" url:"versionId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *Version) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *Version) UnmarshalJSON(data []byte) error {
	type unmarshaler Version
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = Version(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *Version) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VersionResponse struct {
	Data *Version `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VersionResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VersionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VersionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VersionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VersionResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
