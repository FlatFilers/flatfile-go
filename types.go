// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/FlatFilers/flatfile-go/core"
	time "time"
)

// An account
type Account struct {
	Id                      AccountId              `json:"id" url:"id"`
	Name                    string                 `json:"name" url:"name"`
	Subdomain               *string                `json:"subdomain,omitempty" url:"subdomain,omitempty"`
	VanityDomainDashboard   *string                `json:"vanityDomainDashboard,omitempty" url:"vanityDomainDashboard,omitempty"`
	VanityDomainSpaces      *string                `json:"vanityDomainSpaces,omitempty" url:"vanityDomainSpaces,omitempty"`
	EmbeddedDomainWhitelist []string               `json:"embeddedDomainWhitelist,omitempty" url:"embeddedDomainWhitelist,omitempty"`
	CustomFromEmail         *string                `json:"customFromEmail,omitempty" url:"customFromEmail,omitempty"`
	StripeCustomerId        *string                `json:"stripeCustomerId,omitempty" url:"stripeCustomerId,omitempty"`
	Metadata                map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt               time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt               time.Time              `json:"updatedAt" url:"updatedAt"`
	DefaultAppId            *AppId                 `json:"defaultAppId,omitempty" url:"defaultAppId,omitempty"`
	Dashboard               *int                   `json:"dashboard,omitempty" url:"dashboard,omitempty"`

	_rawJSON json.RawMessage
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type embed Account
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Account(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Account) MarshalJSON() ([]byte, error) {
	type embed Account
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Account) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Agent struct {
	// The topics the agent should listen for
	Topics []EventTopic `json:"topics,omitempty" url:"topics,omitempty"`
	// The compiler of the agent
	Compiler *Compiler `json:"compiler,omitempty" url:"compiler,omitempty"`
	// The source of the agent
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The slug of the agent
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	Id   AgentId `json:"id" url:"id"`

	_rawJSON json.RawMessage
}

func (a *Agent) UnmarshalJSON(data []byte) error {
	type unmarshaler Agent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Agent(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Agent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Properties used to create a new agent
type AgentConfig struct {
	// The topics the agent should listen for
	Topics []EventTopic `json:"topics,omitempty" url:"topics,omitempty"`
	// The compiler of the agent
	Compiler *Compiler `json:"compiler,omitempty" url:"compiler,omitempty"`
	// The source of the agent
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The slug of the agent
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AgentConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentConfig(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A log of an agent execution
type AgentLog struct {
	EventId EventId `json:"eventId" url:"eventId"`
	// Whether the agent execution was successful
	Success     bool   `json:"success" url:"success"`
	CreatedAt   string `json:"createdAt" url:"createdAt"`
	CompletedAt string `json:"completedAt" url:"completedAt"`
	// The log of the agent execution
	Log *string `json:"log,omitempty" url:"log,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AgentLog) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentLog(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentLog) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AgentResponse struct {
	Data *Agent `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AgentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentResponse(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The compiler of the agent
type Compiler string

const (
	CompilerJs Compiler = "js"
)

func NewCompilerFromString(s string) (Compiler, error) {
	switch s {
	case "js":
		return CompilerJs, nil
	}
	var t Compiler
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Compiler) Ptr() *Compiler {
	return &c
}

// A log of an agent execution
type DetailedAgentLog struct {
	EventId EventId `json:"eventId" url:"eventId"`
	// Whether the agent execution was successful
	Success     bool      `json:"success" url:"success"`
	CreatedAt   time.Time `json:"createdAt" url:"createdAt"`
	CompletedAt time.Time `json:"completedAt" url:"completedAt"`
	// The duration of the agent execution
	Duration int `json:"duration" url:"duration"`
	// The topics of the agent execution
	Topic string `json:"topic" url:"topic"`
	// The context of the agent execution
	Context map[string]interface{} `json:"context,omitempty" url:"context,omitempty"`
	// The log of the agent execution
	Log *string `json:"log,omitempty" url:"log,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DetailedAgentLog) UnmarshalJSON(data []byte) error {
	type embed DetailedAgentLog
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DetailedAgentLog(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.CompletedAt = unmarshaler.CompletedAt.Time()
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetailedAgentLog) MarshalJSON() ([]byte, error) {
	type embed DetailedAgentLog
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt"`
	}{
		embed:       embed(*d),
		CreatedAt:   core.NewDateTime(d.CreatedAt),
		CompletedAt: core.NewDateTime(d.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DetailedAgentLog) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// An execution of an agent
type Execution struct {
	EventId EventId `json:"eventId" url:"eventId"`
	// Whether the agent execution was successful
	Success     bool      `json:"success" url:"success"`
	CreatedAt   time.Time `json:"createdAt" url:"createdAt"`
	CompletedAt time.Time `json:"completedAt" url:"completedAt"`
	// The duration of the agent execution
	Duration int `json:"duration" url:"duration"`
	// The topics of the agent execution
	Topic string `json:"topic" url:"topic"`

	_rawJSON json.RawMessage
}

func (e *Execution) UnmarshalJSON(data []byte) error {
	type embed Execution
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Execution(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.CompletedAt = unmarshaler.CompletedAt.Time()
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Execution) MarshalJSON() ([]byte, error) {
	type embed Execution
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt"`
	}{
		embed:       embed(*e),
		CreatedAt:   core.NewDateTime(e.CreatedAt),
		CompletedAt: core.NewDateTime(e.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (e *Execution) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type GetAgentLogsResponse struct {
	Pagination *Pagination `json:"pagination,omitempty" url:"pagination,omitempty"`
	Data       []*AgentLog `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetAgentLogsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetAgentLogsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetAgentLogsResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetAgentLogsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListAgentsResponse struct {
	Data []*Agent `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListAgentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListAgentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListAgentsResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListAgentsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// An app
type App struct {
	Id                 AppId       `json:"id" url:"id"`
	Name               string      `json:"name" url:"name"`
	Namespace          string      `json:"namespace" url:"namespace"`
	Type               AppType     `json:"type,omitempty" url:"type,omitempty"`
	Entity             string      `json:"entity" url:"entity"`
	EntityPlural       string      `json:"entityPlural" url:"entityPlural"`
	Icon               *string     `json:"icon,omitempty" url:"icon,omitempty"`
	Metadata           interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	EnvironmentFilters interface{} `json:"environmentFilters,omitempty" url:"environmentFilters,omitempty"`
	CreatedAt          time.Time   `json:"createdAt" url:"createdAt"`
	UpdatedAt          time.Time   `json:"updatedAt" url:"updatedAt"`
	DeletedAt          *time.Time  `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`
	ActivatedAt        *time.Time  `json:"activatedAt,omitempty" url:"activatedAt,omitempty"`

	_rawJSON json.RawMessage
}

func (a *App) UnmarshalJSON(data []byte) error {
	type embed App
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		UpdatedAt   *core.DateTime `json:"updatedAt"`
		DeletedAt   *core.DateTime `json:"deletedAt,omitempty"`
		ActivatedAt *core.DateTime `json:"activatedAt,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = App(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	a.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	a.ActivatedAt = unmarshaler.ActivatedAt.TimePtr()
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *App) MarshalJSON() ([]byte, error) {
	type embed App
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		UpdatedAt   *core.DateTime `json:"updatedAt"`
		DeletedAt   *core.DateTime `json:"deletedAt,omitempty"`
		ActivatedAt *core.DateTime `json:"activatedAt,omitempty"`
	}{
		embed:       embed(*a),
		CreatedAt:   core.NewDateTime(a.CreatedAt),
		UpdatedAt:   core.NewDateTime(a.UpdatedAt),
		DeletedAt:   core.NewOptionalDateTime(a.DeletedAt),
		ActivatedAt: core.NewOptionalDateTime(a.ActivatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *App) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppType string

const (
	AppTypePortal    AppType = "PORTAL"
	AppTypeProjects  AppType = "PROJECTS"
	AppTypeMapping   AppType = "MAPPING"
	AppTypeWorkbooks AppType = "WORKBOOKS"
	AppTypeCustom    AppType = "CUSTOM"
)

func NewAppTypeFromString(s string) (AppType, error) {
	switch s {
	case "PORTAL":
		return AppTypePortal, nil
	case "PROJECTS":
		return AppTypeProjects, nil
	case "MAPPING":
		return AppTypeMapping, nil
	case "WORKBOOKS":
		return AppTypeWorkbooks, nil
	case "CUSTOM":
		return AppTypeCustom, nil
	}
	var t AppType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppType) Ptr() *AppType {
	return &a
}

type Prompt struct {
	Id PromptId `json:"id" url:"id"`
	// ID of the user/guest who created the prompt
	CreatedById string    `json:"createdById" url:"createdById"`
	AccountId   AccountId `json:"accountId" url:"accountId"`
	// Text for prompts for AI Assist
	Prompt    string     `json:"prompt" url:"prompt"`
	CreatedAt time.Time  `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time  `json:"updatedAt" url:"updatedAt"`
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Prompt) UnmarshalJSON(data []byte) error {
	type embed Prompt
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Prompt(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	p.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Prompt) MarshalJSON() ([]byte, error) {
	type embed Prompt
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed:     embed(*p),
		CreatedAt: core.NewDateTime(p.CreatedAt),
		UpdatedAt: core.NewDateTime(p.UpdatedAt),
		DeletedAt: core.NewOptionalDateTime(p.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (p *Prompt) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A commit version
type Commit struct {
	Id      CommitId `json:"id" url:"id"`
	SheetId SheetId  `json:"sheetId" url:"sheetId"`
	// The actor (user or system) who created the commit
	CreatedBy string `json:"createdBy" url:"createdBy"`
	// The actor (user or system) who completed the commit
	CompletedBy *string `json:"completedBy,omitempty" url:"completedBy,omitempty"`
	// The time the commit was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The time the commit was acknowledged
	CompletedAt *time.Time `json:"completedAt,omitempty" url:"completedAt,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Commit) UnmarshalJSON(data []byte) error {
	type embed Commit
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Commit(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Commit) MarshalJSON() ([]byte, error) {
	type embed Commit
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt,omitempty"`
	}{
		embed:       embed(*c),
		CreatedAt:   core.NewDateTime(c.CreatedAt),
		CompletedAt: core.NewOptionalDateTime(c.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Commit) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ListCommitsResponse struct {
	Data []*Commit `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListCommitsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCommitsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCommitsResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCommitsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Account ID
type AccountId = string

type ActionConstraint struct {
	Type ActionConstraintType `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ActionConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraint(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraint) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionConstraintType string

const (
	ActionConstraintTypeHasAllValid  ActionConstraintType = "hasAllValid"
	ActionConstraintTypeHasSelection ActionConstraintType = "hasSelection"
	ActionConstraintTypeHasData      ActionConstraintType = "hasData"
)

func NewActionConstraintTypeFromString(s string) (ActionConstraintType, error) {
	switch s {
	case "hasAllValid":
		return ActionConstraintTypeHasAllValid, nil
	case "hasSelection":
		return ActionConstraintTypeHasSelection, nil
	case "hasData":
		return ActionConstraintTypeHasData, nil
	}
	var t ActionConstraintType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionConstraintType) Ptr() *ActionConstraintType {
	return &a
}

type ActionMessage struct {
	Type    ActionMessageType `json:"type,omitempty" url:"type,omitempty"`
	Content string            `json:"content" url:"content"`

	_rawJSON json.RawMessage
}

func (a *ActionMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMessage(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMessage) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionMessageType string

const (
	ActionMessageTypeError ActionMessageType = "error"
	ActionMessageTypeInfo  ActionMessageType = "info"
)

func NewActionMessageTypeFromString(s string) (ActionMessageType, error) {
	switch s {
	case "error":
		return ActionMessageTypeError, nil
	case "info":
		return ActionMessageTypeInfo, nil
	}
	var t ActionMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionMessageType) Ptr() *ActionMessageType {
	return &a
}

// Foreground actions will prevent interacting with the resource until complete
type ActionMode string

const (
	ActionModeForeground      ActionMode = "foreground"
	ActionModeBackground      ActionMode = "background"
	ActionModeToolbarBlocking ActionMode = "toolbarBlocking"
)

func NewActionModeFromString(s string) (ActionMode, error) {
	switch s {
	case "foreground":
		return ActionModeForeground, nil
	case "background":
		return ActionModeBackground, nil
	case "toolbarBlocking":
		return ActionModeToolbarBlocking, nil
	}
	var t ActionMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionMode) Ptr() *ActionMode {
	return &a
}

type ActionSchedule string

const (
	ActionScheduleWeekly ActionSchedule = "weekly"
	ActionScheduleDaily  ActionSchedule = "daily"
	ActionScheduleHourly ActionSchedule = "hourly"
)

func NewActionScheduleFromString(s string) (ActionSchedule, error) {
	switch s {
	case "weekly":
		return ActionScheduleWeekly, nil
	case "daily":
		return ActionScheduleDaily, nil
	case "hourly":
		return ActionScheduleHourly, nil
	}
	var t ActionSchedule
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionSchedule) Ptr() *ActionSchedule {
	return &a
}

// Actor Role ID
type ActorRoleId = string

// Agent ID
type AgentId = string

// App ID
type AppId = string

// Commit ID
type CommitId = string

// Environment ID
type EnvironmentId = string

type Error struct {
	Key     *string `json:"key,omitempty" url:"key,omitempty"`
	Message string  `json:"message" url:"message"`

	_rawJSON json.RawMessage
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Errors struct {
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Errors) UnmarshalJSON(data []byte) error {
	type unmarshaler Errors
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Errors(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Errors) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Event ID
type EventId = string

// File ID
type FileId = string

// Options to filter records
type Filter string

const (
	FilterValid Filter = "valid"
	FilterError Filter = "error"
	FilterAll   Filter = "all"
	FilterNone  Filter = "none"
)

func NewFilterFromString(s string) (Filter, error) {
	switch s {
	case "valid":
		return FilterValid, nil
	case "error":
		return FilterError, nil
	case "all":
		return FilterAll, nil
	case "none":
		return FilterNone, nil
	}
	var t Filter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f Filter) Ptr() *Filter {
	return &f
}

// Use this to narrow the valid/error filter results to a specific field
type FilterField = string

type InputConfig struct {
	Options []*InputEnumPropertyOption `json:"options,omitempty" url:"options,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InputConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler InputConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputConfig(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputConfig) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputConstraint struct {
	Type InputConstraintType `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InputConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler InputConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputConstraint(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputConstraint) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputConstraintType string

const (
	InputConstraintTypeRequired InputConstraintType = "required"
)

func NewInputConstraintTypeFromString(s string) (InputConstraintType, error) {
	switch s {
	case "required":
		return InputConstraintTypeRequired, nil
	}
	var t InputConstraintType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InputConstraintType) Ptr() *InputConstraintType {
	return &i
}

type InputEnumPropertyOption struct {
	// A visual label for this option, defaults to value if not provided
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// An optional color to assign this option
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// A reference pointer to a previously registered icon
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// An arbitrary JSON object to be associated with this option and made available to hooks
	Meta map[string]interface{} `json:"meta,omitempty" url:"meta,omitempty"`
	// The value or ID of this option. This value will be sent in egress. The type is a string | integer | boolean.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InputEnumPropertyOption) UnmarshalJSON(data []byte) error {
	type unmarshaler InputEnumPropertyOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputEnumPropertyOption(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputEnumPropertyOption) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputField struct {
	// Unique key for a Field.
	Key string `json:"key" url:"key"`
	// Visible name of a Field.
	Label string `json:"label" url:"label"`
	// Brief description below the name of the Field.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Field Types inform the user interface how to sort and display data.
	Type string `json:"type" url:"type"`
	// Default value for a Field.
	DefaultValue interface{} `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	// Additional configuration for enum Fields.
	Config *InputConfig `json:"config,omitempty" url:"config,omitempty"`
	// Indicate additional validations that will be applied to the Field.
	Constraints []*InputConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InputField) UnmarshalJSON(data []byte) error {
	type unmarshaler InputField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputField(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputField) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputForm struct {
	Type   InputFormType `json:"type,omitempty" url:"type,omitempty"`
	Fields []*InputField `json:"fields,omitempty" url:"fields,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InputForm) UnmarshalJSON(data []byte) error {
	type unmarshaler InputForm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputForm(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputForm) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputFormType string

const (
	InputFormTypeSimple InputFormType = "simple"
)

func NewInputFormTypeFromString(s string) (InputFormType, error) {
	switch s {
	case "simple":
		return InputFormTypeSimple, nil
	}
	var t InputFormType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InputFormType) Ptr() *InputFormType {
	return &i
}

// Based on pageSize, which page of records to return
type PageNumber = int

// Number of logs to return in a page (default 20)
type PageSize = int

// pagination info
type Pagination struct {
	// current page of results
	CurrentPage int `json:"currentPage" url:"currentPage"`
	// total number of pages of results
	PageCount int `json:"pageCount" url:"pageCount"`
	// total available results
	TotalCount int `json:"totalCount" url:"totalCount"`

	_rawJSON json.RawMessage
}

func (p *Pagination) UnmarshalJSON(data []byte) error {
	type unmarshaler Pagination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pagination(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Pagination) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Prompt ID
type PromptId = string

// Record ID
type RecordId = string

// Role ID
type RoleId = string

// Use this to narrow the searchValue results to a specific field
type SearchField = string

// Search for the given value, returning matching rows. For exact matches, wrap the value in double quotes ("Bob"). To search for null values, send empty double quotes ("")
type SearchValue = string

// Sheet ID
type SheetId = string

// Sort direction - asc (ascending) or desc (descending)
type SortDirection string

const (
	SortDirectionAsc  SortDirection = "asc"
	SortDirectionDesc SortDirection = "desc"
)

func NewSortDirectionFromString(s string) (SortDirection, error) {
	switch s {
	case "asc":
		return SortDirectionAsc, nil
	case "desc":
		return SortDirectionDesc, nil
	}
	var t SortDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortDirection) Ptr() *SortDirection {
	return &s
}

// Name of field by which to sort records
type SortField = string

// Space Config ID
type SpaceConfigId = string

// Space ID
type SpaceId = string

// Informs whether or not a request was successful
type Success struct {
	Data *SuccessData `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Success) UnmarshalJSON(data []byte) error {
	type unmarshaler Success
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Success(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Success) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SuccessData struct {
	Success bool `json:"success" url:"success"`

	_rawJSON json.RawMessage
}

func (s *SuccessData) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessData(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessData) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Boolean
type SuccessQueryParameter = bool

// User ID
type UserId = string

// Version ID
type VersionId = string

// Workbook ID
type WorkbookId = string

// A data retention policy belonging to an environment
type DataRetentionPolicy struct {
	Type          DataRetentionPolicyEnum `json:"type,omitempty" url:"type,omitempty"`
	Period        int                     `json:"period" url:"period"`
	EnvironmentId EnvironmentId           `json:"environmentId" url:"environmentId"`
	Id            DataRetentionPolicyId   `json:"id" url:"id"`
	// Date the policy was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the policy was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (d *DataRetentionPolicy) UnmarshalJSON(data []byte) error {
	type embed DataRetentionPolicy
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DataRetentionPolicy(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataRetentionPolicy) MarshalJSON() ([]byte, error) {
	type embed DataRetentionPolicy
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DataRetentionPolicy) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The type of data retention policy on an environment
type DataRetentionPolicyEnum string

const (
	DataRetentionPolicyEnumLastActivity DataRetentionPolicyEnum = "lastActivity"
	DataRetentionPolicyEnumSinceCreated DataRetentionPolicyEnum = "sinceCreated"
)

func NewDataRetentionPolicyEnumFromString(s string) (DataRetentionPolicyEnum, error) {
	switch s {
	case "lastActivity":
		return DataRetentionPolicyEnumLastActivity, nil
	case "sinceCreated":
		return DataRetentionPolicyEnumSinceCreated, nil
	}
	var t DataRetentionPolicyEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DataRetentionPolicyEnum) Ptr() *DataRetentionPolicyEnum {
	return &d
}

// A document (markdown components) belong to a space
type Document struct {
	Title string `json:"title" url:"title"`
	Body  string `json:"body" url:"body"`
	// Certain treatments will cause your Document to look or behave differently.
	Treatments    []string       `json:"treatments,omitempty" url:"treatments,omitempty"`
	Actions       []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Id            DocumentId     `json:"id" url:"id"`
	SpaceId       *SpaceId       `json:"spaceId,omitempty" url:"spaceId,omitempty"`
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// Date the document was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the document was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (d *Document) UnmarshalJSON(data []byte) error {
	type embed Document
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Document(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Document) MarshalJSON() ([]byte, error) {
	type embed Document
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *Document) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// An entitlement belonging to a resource
type Entitlement struct {
	// Short name for the entitlement
	Key string `json:"key" url:"key"`
	// Contains conditions or limits for an entitlement
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Entitlement) UnmarshalJSON(data []byte) error {
	type unmarshaler Entitlement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Entitlement(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Entitlement) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The type of authentication to use for guests
type GuestAuthenticationEnum string

const (
	GuestAuthenticationEnumSharedLink GuestAuthenticationEnum = "shared_link"
	GuestAuthenticationEnumMagicLink  GuestAuthenticationEnum = "magic_link"
)

func NewGuestAuthenticationEnumFromString(s string) (GuestAuthenticationEnum, error) {
	switch s {
	case "shared_link":
		return GuestAuthenticationEnumSharedLink, nil
	case "magic_link":
		return GuestAuthenticationEnumMagicLink, nil
	}
	var t GuestAuthenticationEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GuestAuthenticationEnum) Ptr() *GuestAuthenticationEnum {
	return &g
}

// Name of an action
type ActionName = string

type BaseEvent struct {
	// The domain of the event
	Domain Domain `json:"domain,omitempty" url:"domain,omitempty"`
	// The context of the event
	Context *Context `json:"context,omitempty" url:"context,omitempty"`
	// The attributes of the event
	Attributes *EventAttributes `json:"attributes,omitempty" url:"attributes,omitempty"`
	// The callback url to acknowledge the event
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// The url to retrieve the data associated with the event
	DataUrl    *string  `json:"dataUrl,omitempty" url:"dataUrl,omitempty"`
	Target     *string  `json:"target,omitempty" url:"target,omitempty"`
	Origin     *Origin  `json:"origin,omitempty" url:"origin,omitempty"`
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BaseEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseEvent(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseEvent) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The context of the event
type Context struct {
	// The namespaces of the event
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`
	// The slugs of related resources
	Slugs         *EventContextSlugs `json:"slugs,omitempty" url:"slugs,omitempty"`
	ActionName    *ActionName        `json:"actionName,omitempty" url:"actionName,omitempty"`
	AccountId     AccountId          `json:"accountId" url:"accountId"`
	EnvironmentId EnvironmentId      `json:"environmentId" url:"environmentId"`
	SpaceId       *SpaceId           `json:"spaceId,omitempty" url:"spaceId,omitempty"`
	WorkbookId    *WorkbookId        `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	SheetId       *SheetId           `json:"sheetId,omitempty" url:"sheetId,omitempty"`
	SheetSlug     *SheetSlug         `json:"sheetSlug,omitempty" url:"sheetSlug,omitempty"`
	SnapshotId    *SnapshotId        `json:"snapshotId,omitempty" url:"snapshotId,omitempty"`
	// Deprecated, use `commitId` instead.
	VersionId        *VersionId  `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId         *CommitId   `json:"commitId,omitempty" url:"commitId,omitempty"`
	JobId            *JobId      `json:"jobId,omitempty" url:"jobId,omitempty"`
	ProgramId        *ProgramId  `json:"programId,omitempty" url:"programId,omitempty"`
	FileId           *FileId     `json:"fileId,omitempty" url:"fileId,omitempty"`
	DocumentId       *DocumentId `json:"documentId,omitempty" url:"documentId,omitempty"`
	PrecedingEventId *EventId    `json:"precedingEventId,omitempty" url:"precedingEventId,omitempty"`
	// Can be a UserId, GuestId, or AgentId
	ActorId *string `json:"actorId,omitempty" url:"actorId,omitempty"`
	AppId   *AppId  `json:"appId,omitempty" url:"appId,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Context) UnmarshalJSON(data []byte) error {
	type unmarshaler Context
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Context(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Context) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The domain of the event
type Domain string

const (
	DomainFile     Domain = "file"
	DomainSpace    Domain = "space"
	DomainWorkbook Domain = "workbook"
	DomainJob      Domain = "job"
	DomainDocument Domain = "document"
	DomainSheet    Domain = "sheet"
	DomainProgram  Domain = "program"
	DomainSecret   Domain = "secret"
	DomainCron     Domain = "cron"
)

func NewDomainFromString(s string) (Domain, error) {
	switch s {
	case "file":
		return DomainFile, nil
	case "space":
		return DomainSpace, nil
	case "workbook":
		return DomainWorkbook, nil
	case "job":
		return DomainJob, nil
	case "document":
		return DomainDocument, nil
	case "sheet":
		return DomainSheet, nil
	case "program":
		return DomainProgram, nil
	case "secret":
		return DomainSecret, nil
	case "cron":
		return DomainCron, nil
	}
	var t Domain
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d Domain) Ptr() *Domain {
	return &d
}

// An event that tracks an activity within an environment
type Event struct {
	Topic                  string
	AgentCreated           *GenericEvent
	AgentUpdated           *GenericEvent
	AgentDeleted           *GenericEvent
	SpaceCreated           *GenericEvent
	SpaceUpdated           *GenericEvent
	SpaceDeleted           *GenericEvent
	SpaceArchived          *GenericEvent
	SpaceExpired           *GenericEvent
	SpaceGuestAdded        *GenericEvent
	SpaceGuestRemoved      *GenericEvent
	DocumentCreated        *GenericEvent
	DocumentUpdated        *GenericEvent
	DocumentDeleted        *GenericEvent
	WorkbookCreated        *GenericEvent
	WorkbookUpdated        *GenericEvent
	WorkbookDeleted        *GenericEvent
	WorkbookExpired        *GenericEvent
	SheetCreated           *GenericEvent
	SheetUpdated           *GenericEvent
	SheetDeleted           *GenericEvent
	SheetCountsUpdated     *GenericEvent
	SnapshotCreated        *GenericEvent
	RecordsCreated         *GenericEvent
	RecordsUpdated         *GenericEvent
	RecordsDeleted         *GenericEvent
	FileCreated            *GenericEvent
	FileUpdated            *GenericEvent
	FileDeleted            *GenericEvent
	FileExpired            *GenericEvent
	JobCreated             *GenericEvent
	JobUpdated             *GenericEvent
	JobDeleted             *GenericEvent
	JobFailed              *GenericEvent
	JobCompleted           *GenericEvent
	JobReady               *GenericEvent
	JobScheduled           *GenericEvent
	JobOutcomeAcknowledged *GenericEvent
	JobPartsCompleted      *GenericEvent
	ProgramCreated         *GenericEvent
	ProgramUpdated         *GenericEvent
	CommitCreated          *GenericEvent
	CommitUpdated          *GenericEvent
	CommitCompleted        *GenericEvent
	SecretCreated          *GenericEvent
	SecretUpdated          *GenericEvent
	SecretDeleted          *GenericEvent
	LayerCreated           *GenericEvent
}

func NewEventFromAgentCreated(value *GenericEvent) *Event {
	return &Event{Topic: "agentCreated", AgentCreated: value}
}

func NewEventFromAgentUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "agentUpdated", AgentUpdated: value}
}

func NewEventFromAgentDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "agentDeleted", AgentDeleted: value}
}

func NewEventFromSpaceCreated(value *GenericEvent) *Event {
	return &Event{Topic: "spaceCreated", SpaceCreated: value}
}

func NewEventFromSpaceUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "spaceUpdated", SpaceUpdated: value}
}

func NewEventFromSpaceDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "spaceDeleted", SpaceDeleted: value}
}

func NewEventFromSpaceArchived(value *GenericEvent) *Event {
	return &Event{Topic: "spaceArchived", SpaceArchived: value}
}

func NewEventFromSpaceExpired(value *GenericEvent) *Event {
	return &Event{Topic: "spaceExpired", SpaceExpired: value}
}

func NewEventFromSpaceGuestAdded(value *GenericEvent) *Event {
	return &Event{Topic: "spaceGuestAdded", SpaceGuestAdded: value}
}

func NewEventFromSpaceGuestRemoved(value *GenericEvent) *Event {
	return &Event{Topic: "spaceGuestRemoved", SpaceGuestRemoved: value}
}

func NewEventFromDocumentCreated(value *GenericEvent) *Event {
	return &Event{Topic: "documentCreated", DocumentCreated: value}
}

func NewEventFromDocumentUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "documentUpdated", DocumentUpdated: value}
}

func NewEventFromDocumentDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "documentDeleted", DocumentDeleted: value}
}

func NewEventFromWorkbookCreated(value *GenericEvent) *Event {
	return &Event{Topic: "workbookCreated", WorkbookCreated: value}
}

func NewEventFromWorkbookUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "workbookUpdated", WorkbookUpdated: value}
}

func NewEventFromWorkbookDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "workbookDeleted", WorkbookDeleted: value}
}

func NewEventFromWorkbookExpired(value *GenericEvent) *Event {
	return &Event{Topic: "workbookExpired", WorkbookExpired: value}
}

func NewEventFromSheetCreated(value *GenericEvent) *Event {
	return &Event{Topic: "sheetCreated", SheetCreated: value}
}

func NewEventFromSheetUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "sheetUpdated", SheetUpdated: value}
}

func NewEventFromSheetDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "sheetDeleted", SheetDeleted: value}
}

func NewEventFromSheetCountsUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "sheetCountsUpdated", SheetCountsUpdated: value}
}

func NewEventFromSnapshotCreated(value *GenericEvent) *Event {
	return &Event{Topic: "snapshotCreated", SnapshotCreated: value}
}

func NewEventFromRecordsCreated(value *GenericEvent) *Event {
	return &Event{Topic: "recordsCreated", RecordsCreated: value}
}

func NewEventFromRecordsUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "recordsUpdated", RecordsUpdated: value}
}

func NewEventFromRecordsDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "recordsDeleted", RecordsDeleted: value}
}

func NewEventFromFileCreated(value *GenericEvent) *Event {
	return &Event{Topic: "fileCreated", FileCreated: value}
}

func NewEventFromFileUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "fileUpdated", FileUpdated: value}
}

func NewEventFromFileDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "fileDeleted", FileDeleted: value}
}

func NewEventFromFileExpired(value *GenericEvent) *Event {
	return &Event{Topic: "fileExpired", FileExpired: value}
}

func NewEventFromJobCreated(value *GenericEvent) *Event {
	return &Event{Topic: "jobCreated", JobCreated: value}
}

func NewEventFromJobUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "jobUpdated", JobUpdated: value}
}

func NewEventFromJobDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "jobDeleted", JobDeleted: value}
}

func NewEventFromJobFailed(value *GenericEvent) *Event {
	return &Event{Topic: "jobFailed", JobFailed: value}
}

func NewEventFromJobCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "jobCompleted", JobCompleted: value}
}

func NewEventFromJobReady(value *GenericEvent) *Event {
	return &Event{Topic: "jobReady", JobReady: value}
}

func NewEventFromJobScheduled(value *GenericEvent) *Event {
	return &Event{Topic: "jobScheduled", JobScheduled: value}
}

func NewEventFromJobOutcomeAcknowledged(value *GenericEvent) *Event {
	return &Event{Topic: "jobOutcomeAcknowledged", JobOutcomeAcknowledged: value}
}

func NewEventFromJobPartsCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "jobPartsCompleted", JobPartsCompleted: value}
}

func NewEventFromProgramCreated(value *GenericEvent) *Event {
	return &Event{Topic: "programCreated", ProgramCreated: value}
}

func NewEventFromProgramUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "programUpdated", ProgramUpdated: value}
}

func NewEventFromCommitCreated(value *GenericEvent) *Event {
	return &Event{Topic: "commitCreated", CommitCreated: value}
}

func NewEventFromCommitUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "commitUpdated", CommitUpdated: value}
}

func NewEventFromCommitCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "commitCompleted", CommitCompleted: value}
}

func NewEventFromSecretCreated(value *GenericEvent) *Event {
	return &Event{Topic: "secretCreated", SecretCreated: value}
}

func NewEventFromSecretUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "secretUpdated", SecretUpdated: value}
}

func NewEventFromSecretDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "secretDeleted", SecretDeleted: value}
}

func NewEventFromLayerCreated(value *GenericEvent) *Event {
	return &Event{Topic: "layerCreated", LayerCreated: value}
}

func (e *Event) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Topic string `json:"topic"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Topic = unmarshaler.Topic
	switch unmarshaler.Topic {
	case "agentCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentCreated = value
	case "agentUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentUpdated = value
	case "agentDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentDeleted = value
	case "spaceCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceCreated = value
	case "spaceUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceUpdated = value
	case "spaceDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceDeleted = value
	case "spaceArchived":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceArchived = value
	case "spaceExpired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceExpired = value
	case "spaceGuestAdded":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceGuestAdded = value
	case "spaceGuestRemoved":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceGuestRemoved = value
	case "documentCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentCreated = value
	case "documentUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentUpdated = value
	case "documentDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentDeleted = value
	case "workbookCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookCreated = value
	case "workbookUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookUpdated = value
	case "workbookDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookDeleted = value
	case "workbookExpired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookExpired = value
	case "sheetCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetCreated = value
	case "sheetUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetUpdated = value
	case "sheetDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetDeleted = value
	case "sheetCountsUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetCountsUpdated = value
	case "snapshotCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SnapshotCreated = value
	case "recordsCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsCreated = value
	case "recordsUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsUpdated = value
	case "recordsDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsDeleted = value
	case "fileCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileCreated = value
	case "fileUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileUpdated = value
	case "fileDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileDeleted = value
	case "fileExpired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileExpired = value
	case "jobCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobCreated = value
	case "jobUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobUpdated = value
	case "jobDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobDeleted = value
	case "jobFailed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobFailed = value
	case "jobCompleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobCompleted = value
	case "jobReady":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobReady = value
	case "jobScheduled":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobScheduled = value
	case "jobOutcomeAcknowledged":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobOutcomeAcknowledged = value
	case "jobPartsCompleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobPartsCompleted = value
	case "programCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ProgramCreated = value
	case "programUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ProgramUpdated = value
	case "commitCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitCreated = value
	case "commitUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitUpdated = value
	case "commitCompleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitCompleted = value
	case "secretCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretCreated = value
	case "secretUpdated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretUpdated = value
	case "secretDeleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretDeleted = value
	case "layerCreated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.LayerCreated = value
	}
	return nil
}

func (e Event) MarshalJSON() ([]byte, error) {
	switch e.Topic {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Topic, e)
	case "agentCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.AgentCreated,
		}
		return json.Marshal(marshaler)
	case "agentUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.AgentUpdated,
		}
		return json.Marshal(marshaler)
	case "agentDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.AgentDeleted,
		}
		return json.Marshal(marshaler)
	case "spaceCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SpaceCreated,
		}
		return json.Marshal(marshaler)
	case "spaceUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SpaceUpdated,
		}
		return json.Marshal(marshaler)
	case "spaceDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SpaceDeleted,
		}
		return json.Marshal(marshaler)
	case "spaceArchived":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SpaceArchived,
		}
		return json.Marshal(marshaler)
	case "spaceExpired":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SpaceExpired,
		}
		return json.Marshal(marshaler)
	case "spaceGuestAdded":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SpaceGuestAdded,
		}
		return json.Marshal(marshaler)
	case "spaceGuestRemoved":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SpaceGuestRemoved,
		}
		return json.Marshal(marshaler)
	case "documentCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.DocumentCreated,
		}
		return json.Marshal(marshaler)
	case "documentUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.DocumentUpdated,
		}
		return json.Marshal(marshaler)
	case "documentDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.DocumentDeleted,
		}
		return json.Marshal(marshaler)
	case "workbookCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.WorkbookCreated,
		}
		return json.Marshal(marshaler)
	case "workbookUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.WorkbookUpdated,
		}
		return json.Marshal(marshaler)
	case "workbookDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.WorkbookDeleted,
		}
		return json.Marshal(marshaler)
	case "workbookExpired":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.WorkbookExpired,
		}
		return json.Marshal(marshaler)
	case "sheetCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SheetCreated,
		}
		return json.Marshal(marshaler)
	case "sheetUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SheetUpdated,
		}
		return json.Marshal(marshaler)
	case "sheetDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SheetDeleted,
		}
		return json.Marshal(marshaler)
	case "sheetCountsUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SheetCountsUpdated,
		}
		return json.Marshal(marshaler)
	case "snapshotCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SnapshotCreated,
		}
		return json.Marshal(marshaler)
	case "recordsCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.RecordsCreated,
		}
		return json.Marshal(marshaler)
	case "recordsUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.RecordsUpdated,
		}
		return json.Marshal(marshaler)
	case "recordsDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.RecordsDeleted,
		}
		return json.Marshal(marshaler)
	case "fileCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.FileCreated,
		}
		return json.Marshal(marshaler)
	case "fileUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.FileUpdated,
		}
		return json.Marshal(marshaler)
	case "fileDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.FileDeleted,
		}
		return json.Marshal(marshaler)
	case "fileExpired":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.FileExpired,
		}
		return json.Marshal(marshaler)
	case "jobCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobCreated,
		}
		return json.Marshal(marshaler)
	case "jobUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobUpdated,
		}
		return json.Marshal(marshaler)
	case "jobDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobDeleted,
		}
		return json.Marshal(marshaler)
	case "jobFailed":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobFailed,
		}
		return json.Marshal(marshaler)
	case "jobCompleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobCompleted,
		}
		return json.Marshal(marshaler)
	case "jobReady":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobReady,
		}
		return json.Marshal(marshaler)
	case "jobScheduled":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobScheduled,
		}
		return json.Marshal(marshaler)
	case "jobOutcomeAcknowledged":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobOutcomeAcknowledged,
		}
		return json.Marshal(marshaler)
	case "jobPartsCompleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.JobPartsCompleted,
		}
		return json.Marshal(marshaler)
	case "programCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.ProgramCreated,
		}
		return json.Marshal(marshaler)
	case "programUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.ProgramUpdated,
		}
		return json.Marshal(marshaler)
	case "commitCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.CommitCreated,
		}
		return json.Marshal(marshaler)
	case "commitUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.CommitUpdated,
		}
		return json.Marshal(marshaler)
	case "commitCompleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.CommitCompleted,
		}
		return json.Marshal(marshaler)
	case "secretCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SecretCreated,
		}
		return json.Marshal(marshaler)
	case "secretUpdated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SecretUpdated,
		}
		return json.Marshal(marshaler)
	case "secretDeleted":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.SecretDeleted,
		}
		return json.Marshal(marshaler)
	case "layerCreated":
		var marshaler = struct {
			Topic string `json:"topic"`
			*GenericEvent
		}{
			Topic:        e.Topic,
			GenericEvent: e.LayerCreated,
		}
		return json.Marshal(marshaler)
	}
}

type EventVisitor interface {
	VisitAgentCreated(*GenericEvent) error
	VisitAgentUpdated(*GenericEvent) error
	VisitAgentDeleted(*GenericEvent) error
	VisitSpaceCreated(*GenericEvent) error
	VisitSpaceUpdated(*GenericEvent) error
	VisitSpaceDeleted(*GenericEvent) error
	VisitSpaceArchived(*GenericEvent) error
	VisitSpaceExpired(*GenericEvent) error
	VisitSpaceGuestAdded(*GenericEvent) error
	VisitSpaceGuestRemoved(*GenericEvent) error
	VisitDocumentCreated(*GenericEvent) error
	VisitDocumentUpdated(*GenericEvent) error
	VisitDocumentDeleted(*GenericEvent) error
	VisitWorkbookCreated(*GenericEvent) error
	VisitWorkbookUpdated(*GenericEvent) error
	VisitWorkbookDeleted(*GenericEvent) error
	VisitWorkbookExpired(*GenericEvent) error
	VisitSheetCreated(*GenericEvent) error
	VisitSheetUpdated(*GenericEvent) error
	VisitSheetDeleted(*GenericEvent) error
	VisitSheetCountsUpdated(*GenericEvent) error
	VisitSnapshotCreated(*GenericEvent) error
	VisitRecordsCreated(*GenericEvent) error
	VisitRecordsUpdated(*GenericEvent) error
	VisitRecordsDeleted(*GenericEvent) error
	VisitFileCreated(*GenericEvent) error
	VisitFileUpdated(*GenericEvent) error
	VisitFileDeleted(*GenericEvent) error
	VisitFileExpired(*GenericEvent) error
	VisitJobCreated(*GenericEvent) error
	VisitJobUpdated(*GenericEvent) error
	VisitJobDeleted(*GenericEvent) error
	VisitJobFailed(*GenericEvent) error
	VisitJobCompleted(*GenericEvent) error
	VisitJobReady(*GenericEvent) error
	VisitJobScheduled(*GenericEvent) error
	VisitJobOutcomeAcknowledged(*GenericEvent) error
	VisitJobPartsCompleted(*GenericEvent) error
	VisitProgramCreated(*GenericEvent) error
	VisitProgramUpdated(*GenericEvent) error
	VisitCommitCreated(*GenericEvent) error
	VisitCommitUpdated(*GenericEvent) error
	VisitCommitCompleted(*GenericEvent) error
	VisitSecretCreated(*GenericEvent) error
	VisitSecretUpdated(*GenericEvent) error
	VisitSecretDeleted(*GenericEvent) error
	VisitLayerCreated(*GenericEvent) error
}

func (e *Event) Accept(visitor EventVisitor) error {
	switch e.Topic {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Topic, e)
	case "agentCreated":
		return visitor.VisitAgentCreated(e.AgentCreated)
	case "agentUpdated":
		return visitor.VisitAgentUpdated(e.AgentUpdated)
	case "agentDeleted":
		return visitor.VisitAgentDeleted(e.AgentDeleted)
	case "spaceCreated":
		return visitor.VisitSpaceCreated(e.SpaceCreated)
	case "spaceUpdated":
		return visitor.VisitSpaceUpdated(e.SpaceUpdated)
	case "spaceDeleted":
		return visitor.VisitSpaceDeleted(e.SpaceDeleted)
	case "spaceArchived":
		return visitor.VisitSpaceArchived(e.SpaceArchived)
	case "spaceExpired":
		return visitor.VisitSpaceExpired(e.SpaceExpired)
	case "spaceGuestAdded":
		return visitor.VisitSpaceGuestAdded(e.SpaceGuestAdded)
	case "spaceGuestRemoved":
		return visitor.VisitSpaceGuestRemoved(e.SpaceGuestRemoved)
	case "documentCreated":
		return visitor.VisitDocumentCreated(e.DocumentCreated)
	case "documentUpdated":
		return visitor.VisitDocumentUpdated(e.DocumentUpdated)
	case "documentDeleted":
		return visitor.VisitDocumentDeleted(e.DocumentDeleted)
	case "workbookCreated":
		return visitor.VisitWorkbookCreated(e.WorkbookCreated)
	case "workbookUpdated":
		return visitor.VisitWorkbookUpdated(e.WorkbookUpdated)
	case "workbookDeleted":
		return visitor.VisitWorkbookDeleted(e.WorkbookDeleted)
	case "workbookExpired":
		return visitor.VisitWorkbookExpired(e.WorkbookExpired)
	case "sheetCreated":
		return visitor.VisitSheetCreated(e.SheetCreated)
	case "sheetUpdated":
		return visitor.VisitSheetUpdated(e.SheetUpdated)
	case "sheetDeleted":
		return visitor.VisitSheetDeleted(e.SheetDeleted)
	case "sheetCountsUpdated":
		return visitor.VisitSheetCountsUpdated(e.SheetCountsUpdated)
	case "snapshotCreated":
		return visitor.VisitSnapshotCreated(e.SnapshotCreated)
	case "recordsCreated":
		return visitor.VisitRecordsCreated(e.RecordsCreated)
	case "recordsUpdated":
		return visitor.VisitRecordsUpdated(e.RecordsUpdated)
	case "recordsDeleted":
		return visitor.VisitRecordsDeleted(e.RecordsDeleted)
	case "fileCreated":
		return visitor.VisitFileCreated(e.FileCreated)
	case "fileUpdated":
		return visitor.VisitFileUpdated(e.FileUpdated)
	case "fileDeleted":
		return visitor.VisitFileDeleted(e.FileDeleted)
	case "fileExpired":
		return visitor.VisitFileExpired(e.FileExpired)
	case "jobCreated":
		return visitor.VisitJobCreated(e.JobCreated)
	case "jobUpdated":
		return visitor.VisitJobUpdated(e.JobUpdated)
	case "jobDeleted":
		return visitor.VisitJobDeleted(e.JobDeleted)
	case "jobFailed":
		return visitor.VisitJobFailed(e.JobFailed)
	case "jobCompleted":
		return visitor.VisitJobCompleted(e.JobCompleted)
	case "jobReady":
		return visitor.VisitJobReady(e.JobReady)
	case "jobScheduled":
		return visitor.VisitJobScheduled(e.JobScheduled)
	case "jobOutcomeAcknowledged":
		return visitor.VisitJobOutcomeAcknowledged(e.JobOutcomeAcknowledged)
	case "jobPartsCompleted":
		return visitor.VisitJobPartsCompleted(e.JobPartsCompleted)
	case "programCreated":
		return visitor.VisitProgramCreated(e.ProgramCreated)
	case "programUpdated":
		return visitor.VisitProgramUpdated(e.ProgramUpdated)
	case "commitCreated":
		return visitor.VisitCommitCreated(e.CommitCreated)
	case "commitUpdated":
		return visitor.VisitCommitUpdated(e.CommitUpdated)
	case "commitCompleted":
		return visitor.VisitCommitCompleted(e.CommitCompleted)
	case "secretCreated":
		return visitor.VisitSecretCreated(e.SecretCreated)
	case "secretUpdated":
		return visitor.VisitSecretUpdated(e.SecretUpdated)
	case "secretDeleted":
		return visitor.VisitSecretDeleted(e.SecretDeleted)
	case "layerCreated":
		return visitor.VisitLayerCreated(e.LayerCreated)
	}
}

// The attributes of the event
type EventAttributes struct {
	// Date the related entity was last updated
	TargetUpdatedAt *time.Time `json:"targetUpdatedAt,omitempty" url:"targetUpdatedAt,omitempty"`
	// The progress of the event within a collection of iterable events
	Progress *Progress `json:"progress,omitempty" url:"progress,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EventAttributes) UnmarshalJSON(data []byte) error {
	type embed EventAttributes
	var unmarshaler = struct {
		embed
		TargetUpdatedAt *core.DateTime `json:"targetUpdatedAt,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventAttributes(unmarshaler.embed)
	e.TargetUpdatedAt = unmarshaler.TargetUpdatedAt.TimePtr()
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventAttributes) MarshalJSON() ([]byte, error) {
	type embed EventAttributes
	var marshaler = struct {
		embed
		TargetUpdatedAt *core.DateTime `json:"targetUpdatedAt,omitempty"`
	}{
		embed:           embed(*e),
		TargetUpdatedAt: core.NewOptionalDateTime(e.TargetUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EventAttributes) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventContextSlugs struct {
	// The slug of the space
	Space *string `json:"space,omitempty" url:"space,omitempty"`
	// The slug of the workbook
	Workbook *string `json:"workbook,omitempty" url:"workbook,omitempty"`
	// The slug of the sheet
	Sheet *string `json:"sheet,omitempty" url:"sheet,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EventContextSlugs) UnmarshalJSON(data []byte) error {
	type unmarshaler EventContextSlugs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventContextSlugs(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventContextSlugs) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventResponse struct {
	Data *Event `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EventResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type GenericEvent struct {
	// The domain of the event
	Domain Domain `json:"domain,omitempty" url:"domain,omitempty"`
	// The context of the event
	Context *Context `json:"context,omitempty" url:"context,omitempty"`
	// The attributes of the event
	Attributes *EventAttributes `json:"attributes,omitempty" url:"attributes,omitempty"`
	// The callback url to acknowledge the event
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// The url to retrieve the data associated with the event
	DataUrl    *string  `json:"dataUrl,omitempty" url:"dataUrl,omitempty"`
	Target     *string  `json:"target,omitempty" url:"target,omitempty"`
	Origin     *Origin  `json:"origin,omitempty" url:"origin,omitempty"`
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`
	Id         EventId  `json:"id" url:"id"`
	// Date the event was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the event was deleted
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`
	// Date the event was acknowledged
	AcknowledgedAt *time.Time `json:"acknowledgedAt,omitempty" url:"acknowledgedAt,omitempty"`
	// The actor (user or system) who acknowledged the event
	AcknowledgedBy *string                `json:"acknowledgedBy,omitempty" url:"acknowledgedBy,omitempty"`
	Payload        map[string]interface{} `json:"payload,omitempty" url:"payload,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GenericEvent) UnmarshalJSON(data []byte) error {
	type embed GenericEvent
	var unmarshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"createdAt"`
		DeletedAt      *core.DateTime `json:"deletedAt,omitempty"`
		AcknowledgedAt *core.DateTime `json:"acknowledgedAt,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GenericEvent(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	g.AcknowledgedAt = unmarshaler.AcknowledgedAt.TimePtr()
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenericEvent) MarshalJSON() ([]byte, error) {
	type embed GenericEvent
	var marshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"createdAt"`
		DeletedAt      *core.DateTime `json:"deletedAt,omitempty"`
		AcknowledgedAt *core.DateTime `json:"acknowledgedAt,omitempty"`
	}{
		embed:          embed(*g),
		CreatedAt:      core.NewDateTime(g.CreatedAt),
		DeletedAt:      core.NewOptionalDateTime(g.DeletedAt),
		AcknowledgedAt: core.NewOptionalDateTime(g.AcknowledgedAt),
	}
	return json.Marshal(marshaler)
}

func (g *GenericEvent) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListAllEventsResponse struct {
	Data []*Event `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListAllEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListAllEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListAllEventsResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListAllEventsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The origin resource of the event
type Origin struct {
	Id   *string `json:"id,omitempty" url:"id,omitempty"`
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	_rawJSON json.RawMessage
}

func (o *Origin) UnmarshalJSON(data []byte) error {
	type unmarshaler Origin
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Origin(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Origin) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The progress of the event within a collection of iterable events
type Progress struct {
	// The current progress of the event
	Current *int `json:"current,omitempty" url:"current,omitempty"`
	// The total number of events in this group
	Total *int `json:"total,omitempty" url:"total,omitempty"`
	// The percent complete of the event group
	Percent *int `json:"percent,omitempty" url:"percent,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Progress) UnmarshalJSON(data []byte) error {
	type unmarshaler Progress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Progress(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Progress) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Sheet Slug
type SheetSlug = string

// Any uploaded file of any type
type File struct {
	Id FileId `json:"id" url:"id"`
	// Original filename
	Name string `json:"name" url:"name"`
	// Extension of the file
	Ext string `json:"ext" url:"ext"`
	// MIME Type of the file
	Mimetype string `json:"mimetype" url:"mimetype"`
	// Text encoding of the file
	Encoding string `json:"encoding" url:"encoding"`
	// Status of the file
	Status ModelFileStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// The storage mode of file
	Mode *Mode `json:"mode,omitempty" url:"mode,omitempty"`
	// Size of file in bytes
	Size int `json:"size" url:"size"`
	// Number of bytes that have been uploaded so far (useful for progress tracking)
	BytesReceived int `json:"bytesReceived" url:"bytesReceived"`
	// Date the file was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the file was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date the file was expired
	ExpiredAt  *time.Time  `json:"expiredAt,omitempty" url:"expiredAt,omitempty"`
	SpaceId    SpaceId     `json:"spaceId" url:"spaceId"`
	WorkbookId *WorkbookId `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	SheetId    *SheetId    `json:"sheetId,omitempty" url:"sheetId,omitempty"`
	Actions    []*Action   `json:"actions,omitempty" url:"actions,omitempty"`
	Origin     *FileOrigin `json:"origin,omitempty" url:"origin,omitempty"`

	_rawJSON json.RawMessage
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		ExpiredAt *core.DateTime `json:"expiredAt,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.Time()
	f.UpdatedAt = unmarshaler.UpdatedAt.Time()
	f.ExpiredAt = unmarshaler.ExpiredAt.TimePtr()
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		ExpiredAt *core.DateTime `json:"expiredAt,omitempty"`
	}{
		embed:     embed(*f),
		CreatedAt: core.NewDateTime(f.CreatedAt),
		UpdatedAt: core.NewDateTime(f.UpdatedAt),
		ExpiredAt: core.NewOptionalDateTime(f.ExpiredAt),
	}
	return json.Marshal(marshaler)
}

func (f *File) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Guest struct {
	EnvironmentId EnvironmentId `json:"environmentId" url:"environmentId"`
	Email         string        `json:"email" url:"email"`
	Name          string        `json:"name" url:"name"`
	Spaces        []*GuestSpace `json:"spaces,omitempty" url:"spaces,omitempty"`
	Id            GuestId       `json:"id" url:"id"`
	// Date the guest object was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the guest object was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (g *Guest) UnmarshalJSON(data []byte) error {
	type embed Guest
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = Guest(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Guest) MarshalJSON() ([]byte, error) {
	type embed Guest
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*g),
		CreatedAt: core.NewDateTime(g.CreatedAt),
		UpdatedAt: core.NewDateTime(g.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (g *Guest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuestSpace struct {
	Id           SpaceId          `json:"id" url:"id"`
	Workbooks    []*GuestWorkbook `json:"workbooks,omitempty" url:"workbooks,omitempty"`
	LastAccessed *time.Time       `json:"lastAccessed,omitempty" url:"lastAccessed,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GuestSpace) UnmarshalJSON(data []byte) error {
	type embed GuestSpace
	var unmarshaler = struct {
		embed
		LastAccessed *core.DateTime `json:"lastAccessed,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GuestSpace(unmarshaler.embed)
	g.LastAccessed = unmarshaler.LastAccessed.TimePtr()
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuestSpace) MarshalJSON() ([]byte, error) {
	type embed GuestSpace
	var marshaler = struct {
		embed
		LastAccessed *core.DateTime `json:"lastAccessed,omitempty"`
	}{
		embed:        embed(*g),
		LastAccessed: core.NewOptionalDateTime(g.LastAccessed),
	}
	return json.Marshal(marshaler)
}

func (g *GuestSpace) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuestToken struct {
	// The token used to authenticate the guest
	Token string `json:"token" url:"token"`
	Valid bool   `json:"valid" url:"valid"`

	_rawJSON json.RawMessage
}

func (g *GuestToken) UnmarshalJSON(data []byte) error {
	type unmarshaler GuestToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuestToken(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuestToken) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuestWorkbook struct {
	Id WorkbookId `json:"id" url:"id"`

	_rawJSON json.RawMessage
}

func (g *GuestWorkbook) UnmarshalJSON(data []byte) error {
	type unmarshaler GuestWorkbook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuestWorkbook(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuestWorkbook) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type CategoryMapping struct {
	// The source value to map from
	SourceValue *EnumValue `json:"sourceValue,omitempty" url:"sourceValue,omitempty"`
	// The destination value to map to
	DestinationValue *EnumValue `json:"destinationValue,omitempty" url:"destinationValue,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CategoryMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CategoryMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CategoryMapping(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CategoryMapping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Certainty string

const (
	CertaintyAbsolute Certainty = "absolute"
	CertaintyStrong   Certainty = "strong"
	CertaintyModerate Certainty = "moderate"
	CertaintyWeak     Certainty = "weak"
)

func NewCertaintyFromString(s string) (Certainty, error) {
	switch s {
	case "absolute":
		return CertaintyAbsolute, nil
	case "strong":
		return CertaintyStrong, nil
	case "moderate":
		return CertaintyModerate, nil
	case "weak":
		return CertaintyWeak, nil
	}
	var t Certainty
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Certainty) Ptr() *Certainty {
	return &c
}

type CollectionJobSubject struct {
	Resource string                 `json:"resource" url:"resource"`
	Params   map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`
	Query    map[string]interface{} `json:"query,omitempty" url:"query,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CollectionJobSubject) UnmarshalJSON(data []byte) error {
	type unmarshaler CollectionJobSubject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CollectionJobSubject(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CollectionJobSubject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The configuration for a delete job
type DeleteRecordsJobConfig struct {
	Filter      *Filter      `json:"filter,omitempty" url:"filter,omitempty"`
	FilterField *FilterField `json:"filterField,omitempty" url:"filterField,omitempty"`
	SearchValue *SearchValue `json:"searchValue,omitempty" url:"searchValue,omitempty"`
	SearchField *SearchField `json:"searchField,omitempty" url:"searchField,omitempty"`
	// FFQL query to filter records
	Q     *string `json:"q,omitempty" url:"q,omitempty"`
	Sheet SheetId `json:"sheet" url:"sheet"`
	// List of record ids to exclude from deletion
	Exceptions []RecordId `json:"exceptions,omitempty" url:"exceptions,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteRecordsJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteRecordsJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteRecordsJobConfig(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteRecordsJobConfig) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DestinationField struct {
	// The description of the destination field
	DestinationField *Property `json:"destinationField,omitempty" url:"destinationField,omitempty"`
	// A list of preview values of the data in the destination field
	Preview []string `json:"preview,omitempty" url:"preview,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DestinationField) UnmarshalJSON(data []byte) error {
	type unmarshaler DestinationField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DestinationField(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DestinationField) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The driver to use for extracting data from the file
type Driver string

const (
	DriverCsv Driver = "csv"
)

func NewDriverFromString(s string) (Driver, error) {
	switch s {
	case "csv":
		return DriverCsv, nil
	}
	var t Driver
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d Driver) Ptr() *Driver {
	return &d
}

type Edge struct {
	// The description of the source field
	SourceField *Property `json:"sourceField,omitempty" url:"sourceField,omitempty"`
	// The description of the destination field
	DestinationField *Property `json:"destinationField,omitempty" url:"destinationField,omitempty"`
	// A list of preview values of the data in the destination field
	Preview []string `json:"preview,omitempty" url:"preview,omitempty"`
	// Only available if one or more of the destination fields is of type enum. Provides category mapping.
	EnumDetails *EnumDetails `json:"enumDetails,omitempty" url:"enumDetails,omitempty"`
	// Metadata about the edge
	Metadata *Metadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Edge) UnmarshalJSON(data []byte) error {
	type unmarshaler Edge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Edge(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Edge) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmptyObject struct {
	_rawJSON json.RawMessage
}

func (e *EmptyObject) UnmarshalJSON(data []byte) error {
	type unmarshaler EmptyObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmptyObject(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmptyObject) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Only available if one or more of the destination fields is of type enum. Provides category mapping.
type EnumDetails struct {
	// The mapping of source values to destination values
	Mapping []*CategoryMapping `json:"mapping,omitempty" url:"mapping,omitempty"`
	// A list of source values that are not mapped from
	UnusedSourceValues []*EnumValue `json:"unusedSourceValues,omitempty" url:"unusedSourceValues,omitempty"`
	// A list of destination values that are not mapped to
	UnusedDestinationValues []*EnumValue `json:"unusedDestinationValues,omitempty" url:"unusedDestinationValues,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EnumDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumDetails(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumDetails) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumValue struct {
	typeName string
	String   string
	Integer  int
	Boolean  bool
}

func NewEnumValueFromString(value string) *EnumValue {
	return &EnumValue{typeName: "string", String: value}
}

func NewEnumValueFromInteger(value int) *EnumValue {
	return &EnumValue{typeName: "integer", Integer: value}
}

func NewEnumValueFromBoolean(value bool) *EnumValue {
	return &EnumValue{typeName: "boolean", Boolean: value}
}

func (e *EnumValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		e.typeName = "boolean"
		e.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EnumValue) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "integer":
		return json.Marshal(e.Integer)
	case "boolean":
		return json.Marshal(e.Boolean)
	}
}

type EnumValueVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
	VisitBoolean(bool) error
}

func (e *EnumValue) Accept(visitor EnumValueVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "boolean":
		return visitor.VisitBoolean(e.Boolean)
	}
}

type ExportJobConfig struct {
	Options *ExportOptions `json:"options,omitempty" url:"options,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExportJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ExportJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExportJobConfig(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExportJobConfig) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExportOptions struct {
	// Deprecated, use `commitId` instead
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	// If provided, the snapshot version of the workbook will be used for the export
	CommitId *CommitId `json:"commitId,omitempty" url:"commitId,omitempty"`
	// The field to sort the records on
	SortField *SortField `json:"sortField,omitempty" url:"sortField,omitempty"`
	// The direction to sort the records
	SortDirection *SortDirection `json:"sortDirection,omitempty" url:"sortDirection,omitempty"`
	// The filter to apply to the records
	Filter *Filter `json:"filter,omitempty" url:"filter,omitempty"`
	// The field to filter on
	FilterField *FilterField `json:"filterField,omitempty" url:"filterField,omitempty"`
	// The value to search for
	SearchValue *SearchValue `json:"searchValue,omitempty" url:"searchValue,omitempty"`
	// The field to search for the search value in
	SearchField *SearchField `json:"searchField,omitempty" url:"searchField,omitempty"`
	// The FFQL query to filter records
	Q *string `json:"q,omitempty" url:"q,omitempty"`
	// The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records
	Ids []RecordId `json:"ids,omitempty" url:"ids,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExportOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ExportOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExportOptions(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExportOptions) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FileJobConfig struct {
	// The driver to use for extracting data from the file
	Driver Driver `json:"driver,omitempty" url:"driver,omitempty"`
	// The options to use for extracting data from the file
	Options map[string]interface{} `json:"options,omitempty" url:"options,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FileJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler FileJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileJobConfig(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileJobConfig) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindAndReplaceJobConfig struct {
	// The filter to apply to the records
	Filter *Filter `json:"filter,omitempty" url:"filter,omitempty"`
	// The field to filter on
	FilterField *FilterField `json:"filterField,omitempty" url:"filterField,omitempty"`
	// The value to search for
	SearchValue *SearchValue `json:"searchValue,omitempty" url:"searchValue,omitempty"`
	// The field to search for the search value in
	SearchField *SearchField `json:"searchField,omitempty" url:"searchField,omitempty"`
	// The FFQL query to filter records
	Q *string `json:"q,omitempty" url:"q,omitempty"`
	// The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records
	Ids []RecordId `json:"ids,omitempty" url:"ids,omitempty"`
	// A value to find for a given field in a sheet. Wrap the value in "" for exact match
	Find *CellValueUnion `json:"find,omitempty" url:"find,omitempty"`
	// The value to replace found values with
	Replace *CellValueUnion `json:"replace,omitempty" url:"replace,omitempty"`
	// A unique key used to identify a field in a sheet
	FieldKey string `json:"fieldKey" url:"fieldKey"`

	_rawJSON json.RawMessage
}

func (f *FindAndReplaceJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler FindAndReplaceJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindAndReplaceJobConfig(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindAndReplaceJobConfig) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A single unit of work that will execute asynchronously
type Job struct {
	// The type of job
	Type JobType `json:"type,omitempty" url:"type,omitempty"`
	// the type of operation to perform on the data. For example, "export".
	Operation   string           `json:"operation" url:"operation"`
	Source      JobSource        `json:"source" url:"source"`
	Destination *JobDestination  `json:"destination,omitempty" url:"destination,omitempty"`
	Config      *JobUpdateConfig `json:"config,omitempty" url:"config,omitempty"`
	// the type of trigger to use for this job
	Trigger *Trigger `json:"trigger,omitempty" url:"trigger,omitempty"`
	// the status of the job
	Status *JobStatus `json:"status,omitempty" url:"status,omitempty"`
	// the progress of the job. Whole number between 0 and 100
	Progress *int    `json:"progress,omitempty" url:"progress,omitempty"`
	FileId   *FileId `json:"fileId,omitempty" url:"fileId,omitempty"`
	// the mode of the job
	Mode *JobMode `json:"mode,omitempty" url:"mode,omitempty"`
	// Input parameters for this job type.
	Input map[string]interface{} `json:"input,omitempty" url:"input,omitempty"`
	// Subject parameters for this job type.
	Subject *JobSubject `json:"subject,omitempty" url:"subject,omitempty"`
	// Outcome summary of job.
	Outcome map[string]interface{} `json:"outcome,omitempty" url:"outcome,omitempty"`
	// Current status of job in text
	Info *string `json:"info,omitempty" url:"info,omitempty"`
	// Indicates if Flatfile is managing the control flow of this job or if it is being manually tracked.
	Managed *bool `json:"managed,omitempty" url:"managed,omitempty"`
	// The id of the environment this job belongs to
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The part number of this job
	Part *int `json:"part,omitempty" url:"part,omitempty"`
	// The data for this part of the job
	PartData map[string]interface{} `json:"partData,omitempty" url:"partData,omitempty"`
	// The execution mode for this part of the job
	PartExecution *JobPartExecution `json:"partExecution,omitempty" url:"partExecution,omitempty"`
	// The id of the parent job
	ParentId *JobId `json:"parentId,omitempty" url:"parentId,omitempty"`
	Id       JobId  `json:"id" url:"id"`
	// Date the item was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the item was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// the time that the job started at
	StartedAt *time.Time `json:"startedAt,omitempty" url:"startedAt,omitempty"`
	// the time that the job finished at
	FinishedAt *time.Time `json:"finishedAt,omitempty" url:"finishedAt,omitempty"`
	// the time that the job's outcome has been acknowledged by a user
	OutcomeAcknowledgedAt *time.Time `json:"outcomeAcknowledgedAt,omitempty" url:"outcomeAcknowledgedAt,omitempty"`

	_rawJSON json.RawMessage
}

func (j *Job) UnmarshalJSON(data []byte) error {
	type embed Job
	var unmarshaler = struct {
		embed
		CreatedAt             *core.DateTime `json:"createdAt"`
		UpdatedAt             *core.DateTime `json:"updatedAt"`
		StartedAt             *core.DateTime `json:"startedAt,omitempty"`
		FinishedAt            *core.DateTime `json:"finishedAt,omitempty"`
		OutcomeAcknowledgedAt *core.DateTime `json:"outcomeAcknowledgedAt,omitempty"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = Job(unmarshaler.embed)
	j.CreatedAt = unmarshaler.CreatedAt.Time()
	j.UpdatedAt = unmarshaler.UpdatedAt.Time()
	j.StartedAt = unmarshaler.StartedAt.TimePtr()
	j.FinishedAt = unmarshaler.FinishedAt.TimePtr()
	j.OutcomeAcknowledgedAt = unmarshaler.OutcomeAcknowledgedAt.TimePtr()
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *Job) MarshalJSON() ([]byte, error) {
	type embed Job
	var marshaler = struct {
		embed
		CreatedAt             *core.DateTime `json:"createdAt"`
		UpdatedAt             *core.DateTime `json:"updatedAt"`
		StartedAt             *core.DateTime `json:"startedAt,omitempty"`
		FinishedAt            *core.DateTime `json:"finishedAt,omitempty"`
		OutcomeAcknowledgedAt *core.DateTime `json:"outcomeAcknowledgedAt,omitempty"`
	}{
		embed:                 embed(*j),
		CreatedAt:             core.NewDateTime(j.CreatedAt),
		UpdatedAt:             core.NewDateTime(j.UpdatedAt),
		StartedAt:             core.NewOptionalDateTime(j.StartedAt),
		FinishedAt:            core.NewOptionalDateTime(j.FinishedAt),
		OutcomeAcknowledgedAt: core.NewOptionalDateTime(j.OutcomeAcknowledgedAt),
	}
	return json.Marshal(marshaler)
}

func (j *Job) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The id of the workbook where extracted file data will be sent
type JobDestination = WorkbookId

// The execution plan for a job, for example, for a map job, the execution plan is the mapping of the source sheet to the destination sheet.
type JobExecutionPlan struct {
	FieldMapping              []*Edge             `json:"fieldMapping,omitempty" url:"fieldMapping,omitempty"`
	UnmappedSourceFields      []*SourceField      `json:"unmappedSourceFields,omitempty" url:"unmappedSourceFields,omitempty"`
	UnmappedDestinationFields []*DestinationField `json:"unmappedDestinationFields,omitempty" url:"unmappedDestinationFields,omitempty"`
	ProgramId                 *string             `json:"programId,omitempty" url:"programId,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobExecutionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler JobExecutionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobExecutionPlan(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobExecutionPlan) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The execution plan for a job, for example, for a map job, the execution plan is the mapping of the source sheet to the destination sheet.
type JobExecutionPlanConfig struct {
	FieldMapping              []*Edge             `json:"fieldMapping,omitempty" url:"fieldMapping,omitempty"`
	UnmappedSourceFields      []*SourceField      `json:"unmappedSourceFields,omitempty" url:"unmappedSourceFields,omitempty"`
	UnmappedDestinationFields []*DestinationField `json:"unmappedDestinationFields,omitempty" url:"unmappedDestinationFields,omitempty"`
	ProgramId                 *string             `json:"programId,omitempty" url:"programId,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobExecutionPlanConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler JobExecutionPlanConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobExecutionPlanConfig(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobExecutionPlanConfig) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// the mode of the job
type JobMode string

const (
	JobModeForeground      JobMode = "foreground"
	JobModeBackground      JobMode = "background"
	JobModeToolbarBlocking JobMode = "toolbarBlocking"
)

func NewJobModeFromString(s string) (JobMode, error) {
	switch s {
	case "foreground":
		return JobModeForeground, nil
	case "background":
		return JobModeBackground, nil
	case "toolbarBlocking":
		return JobModeToolbarBlocking, nil
	}
	var t JobMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobMode) Ptr() *JobMode {
	return &j
}

// Outcome summary of a job
type JobOutcome struct {
	Acknowledge       *bool           `json:"acknowledge,omitempty" url:"acknowledge,omitempty"`
	ButtonText        *string         `json:"buttonText,omitempty" url:"buttonText,omitempty"`
	Next              *JobOutcomeNext `json:"next,omitempty" url:"next,omitempty"`
	Heading           *string         `json:"heading,omitempty" url:"heading,omitempty"`
	Message           *string         `json:"message,omitempty" url:"message,omitempty"`
	HideDefaultButton *bool           `json:"hideDefaultButton,omitempty" url:"hideDefaultButton,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobOutcome) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcome
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcome(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcome) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNext struct {
	Type     string
	Id       *JobOutcomeNextId
	Url      *JobOutcomeNextUrl
	Download *JobOutcomeNextDownload
	Wait     *JobOutcomeNextWait
	Snapshot *JobOutcomeNextSnapshot
	Retry    *JobOutcomeNextRetry
}

func NewJobOutcomeNextFromId(value *JobOutcomeNextId) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "id", Id: value}
}

func NewJobOutcomeNextFromUrl(value *JobOutcomeNextUrl) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "url", Url: value}
}

func NewJobOutcomeNextFromDownload(value *JobOutcomeNextDownload) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "download", Download: value}
}

func NewJobOutcomeNextFromWait(value *JobOutcomeNextWait) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "wait", Wait: value}
}

func NewJobOutcomeNextFromSnapshot(value *JobOutcomeNextSnapshot) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "snapshot", Snapshot: value}
}

func NewJobOutcomeNextFromRetry(value *JobOutcomeNextRetry) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "retry", Retry: value}
}

func (j *JobOutcomeNext) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "id":
		value := new(JobOutcomeNextId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Id = value
	case "url":
		value := new(JobOutcomeNextUrl)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Url = value
	case "download":
		value := new(JobOutcomeNextDownload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Download = value
	case "wait":
		value := new(JobOutcomeNextWait)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Wait = value
	case "snapshot":
		value := new(JobOutcomeNextSnapshot)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Snapshot = value
	case "retry":
		value := new(JobOutcomeNextRetry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Retry = value
	}
	return nil
}

func (j JobOutcomeNext) MarshalJSON() ([]byte, error) {
	switch j.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "id":
		var marshaler = struct {
			Type string `json:"type"`
			*JobOutcomeNextId
		}{
			Type:             j.Type,
			JobOutcomeNextId: j.Id,
		}
		return json.Marshal(marshaler)
	case "url":
		var marshaler = struct {
			Type string `json:"type"`
			*JobOutcomeNextUrl
		}{
			Type:              j.Type,
			JobOutcomeNextUrl: j.Url,
		}
		return json.Marshal(marshaler)
	case "download":
		var marshaler = struct {
			Type string `json:"type"`
			*JobOutcomeNextDownload
		}{
			Type:                   j.Type,
			JobOutcomeNextDownload: j.Download,
		}
		return json.Marshal(marshaler)
	case "wait":
		var marshaler = struct {
			Type string `json:"type"`
			*JobOutcomeNextWait
		}{
			Type:               j.Type,
			JobOutcomeNextWait: j.Wait,
		}
		return json.Marshal(marshaler)
	case "snapshot":
		var marshaler = struct {
			Type string `json:"type"`
			*JobOutcomeNextSnapshot
		}{
			Type:                   j.Type,
			JobOutcomeNextSnapshot: j.Snapshot,
		}
		return json.Marshal(marshaler)
	case "retry":
		var marshaler = struct {
			Type string `json:"type"`
			*JobOutcomeNextRetry
		}{
			Type:                j.Type,
			JobOutcomeNextRetry: j.Retry,
		}
		return json.Marshal(marshaler)
	}
}

type JobOutcomeNextVisitor interface {
	VisitId(*JobOutcomeNextId) error
	VisitUrl(*JobOutcomeNextUrl) error
	VisitDownload(*JobOutcomeNextDownload) error
	VisitWait(*JobOutcomeNextWait) error
	VisitSnapshot(*JobOutcomeNextSnapshot) error
	VisitRetry(*JobOutcomeNextRetry) error
}

func (j *JobOutcomeNext) Accept(visitor JobOutcomeNextVisitor) error {
	switch j.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "id":
		return visitor.VisitId(j.Id)
	case "url":
		return visitor.VisitUrl(j.Url)
	case "download":
		return visitor.VisitDownload(j.Download)
	case "wait":
		return visitor.VisitWait(j.Wait)
	case "snapshot":
		return visitor.VisitSnapshot(j.Snapshot)
	case "retry":
		return visitor.VisitRetry(j.Retry)
	}
}

type JobOutcomeNextDownload struct {
	Url      string  `json:"url" url:"url"`
	Label    *string `json:"label,omitempty" url:"label,omitempty"`
	FileName *string `json:"fileName,omitempty" url:"fileName,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobOutcomeNextDownload) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextDownload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextDownload(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextDownload) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextId struct {
	Id    string  `json:"id" url:"id"`
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	Path  *string `json:"path,omitempty" url:"path,omitempty"`
	Query *string `json:"query,omitempty" url:"query,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobOutcomeNextId) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextId(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextId) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextRetry struct {
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobOutcomeNextRetry) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextRetry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextRetry(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextRetry) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextSnapshot struct {
	SnapshotId string `json:"snapshotId" url:"snapshotId"`
	SheetId    string `json:"sheetId" url:"sheetId"`

	_rawJSON json.RawMessage
}

func (j *JobOutcomeNextSnapshot) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextSnapshot
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextSnapshot(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextSnapshot) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextUrl struct {
	Url   string  `json:"url" url:"url"`
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobOutcomeNextUrl) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextUrl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextUrl(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextUrl) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextWait struct {
	Fade     *bool `json:"fade,omitempty" url:"fade,omitempty"`
	Confetti *bool `json:"confetti,omitempty" url:"confetti,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobOutcomeNextWait) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextWait
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextWait(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextWait) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobPartExecution string

const (
	JobPartExecutionSequential JobPartExecution = "sequential"
	JobPartExecutionParallel   JobPartExecution = "parallel"
)

func NewJobPartExecutionFromString(s string) (JobPartExecution, error) {
	switch s {
	case "sequential":
		return JobPartExecutionSequential, nil
	case "parallel":
		return JobPartExecutionParallel, nil
	}
	var t JobPartExecution
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobPartExecution) Ptr() *JobPartExecution {
	return &j
}

// Info about the number of parts to create
type JobParts struct {
	typeName      string
	Integer       int
	JobPartsArray JobPartsArray
}

func NewJobPartsFromInteger(value int) *JobParts {
	return &JobParts{typeName: "integer", Integer: value}
}

func NewJobPartsFromJobPartsArray(value JobPartsArray) *JobParts {
	return &JobParts{typeName: "jobPartsArray", JobPartsArray: value}
}

func (j *JobParts) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		j.typeName = "integer"
		j.Integer = valueInteger
		return nil
	}
	var valueJobPartsArray JobPartsArray
	if err := json.Unmarshal(data, &valueJobPartsArray); err == nil {
		j.typeName = "jobPartsArray"
		j.JobPartsArray = valueJobPartsArray
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobParts) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "integer":
		return json.Marshal(j.Integer)
	case "jobPartsArray":
		return json.Marshal(j.JobPartsArray)
	}
}

type JobPartsVisitor interface {
	VisitInteger(int) error
	VisitJobPartsArray(JobPartsArray) error
}

func (j *JobParts) Accept(visitor JobPartsVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "integer":
		return visitor.VisitInteger(j.Integer)
	case "jobPartsArray":
		return visitor.VisitJobPartsArray(j.JobPartsArray)
	}
}

// Data for each of the job parts
type JobPartsArray = []map[string]interface{}

// The job/plan tuple that contains the full plan and the jobs status
type JobPlan struct {
	Job  *Job              `json:"job,omitempty" url:"job,omitempty"`
	Plan *JobExecutionPlan `json:"plan,omitempty" url:"plan,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler JobPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobPlan(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobPlan) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The id of a file, workbook, or sheet
type JobSource = string

// the status of the job
type JobStatus string

const (
	JobStatusCreated   JobStatus = "created"
	JobStatusPlanning  JobStatus = "planning"
	JobStatusScheduled JobStatus = "scheduled"
	JobStatusReady     JobStatus = "ready"
	JobStatusExecuting JobStatus = "executing"
	JobStatusComplete  JobStatus = "complete"
	JobStatusFailed    JobStatus = "failed"
	JobStatusCanceled  JobStatus = "canceled"
)

func NewJobStatusFromString(s string) (JobStatus, error) {
	switch s {
	case "created":
		return JobStatusCreated, nil
	case "planning":
		return JobStatusPlanning, nil
	case "scheduled":
		return JobStatusScheduled, nil
	case "ready":
		return JobStatusReady, nil
	case "executing":
		return JobStatusExecuting, nil
	case "complete":
		return JobStatusComplete, nil
	case "failed":
		return JobStatusFailed, nil
	case "canceled":
		return JobStatusCanceled, nil
	}
	var t JobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobStatus) Ptr() *JobStatus {
	return &j
}

// Subject parameters for this job type
type JobSubject struct {
	Type       string
	Resource   *ResourceJobSubject
	Collection *CollectionJobSubject
}

func NewJobSubjectFromResource(value *ResourceJobSubject) *JobSubject {
	return &JobSubject{Type: "resource", Resource: value}
}

func NewJobSubjectFromCollection(value *CollectionJobSubject) *JobSubject {
	return &JobSubject{Type: "collection", Collection: value}
}

func (j *JobSubject) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "resource":
		value := new(ResourceJobSubject)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Resource = value
	case "collection":
		value := new(CollectionJobSubject)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Collection = value
	}
	return nil
}

func (j JobSubject) MarshalJSON() ([]byte, error) {
	switch j.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "resource":
		var marshaler = struct {
			Type string `json:"type"`
			*ResourceJobSubject
		}{
			Type:               j.Type,
			ResourceJobSubject: j.Resource,
		}
		return json.Marshal(marshaler)
	case "collection":
		var marshaler = struct {
			Type string `json:"type"`
			*CollectionJobSubject
		}{
			Type:                 j.Type,
			CollectionJobSubject: j.Collection,
		}
		return json.Marshal(marshaler)
	}
}

type JobSubjectVisitor interface {
	VisitResource(*ResourceJobSubject) error
	VisitCollection(*CollectionJobSubject) error
}

func (j *JobSubject) Accept(visitor JobSubjectVisitor) error {
	switch j.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "resource":
		return visitor.VisitResource(j.Resource)
	case "collection":
		return visitor.VisitCollection(j.Collection)
	}
}

// The type of job
type JobType string

const (
	JobTypeFile     JobType = "file"
	JobTypeWorkbook JobType = "workbook"
	JobTypeSheet    JobType = "sheet"
	JobTypeSpace    JobType = "space"
	JobTypeDocument JobType = "document"
)

func NewJobTypeFromString(s string) (JobType, error) {
	switch s {
	case "file":
		return JobTypeFile, nil
	case "workbook":
		return JobTypeWorkbook, nil
	case "sheet":
		return JobTypeSheet, nil
	case "space":
		return JobTypeSpace, nil
	case "document":
		return JobTypeDocument, nil
	}
	var t JobType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobType) Ptr() *JobType {
	return &j
}

type JobUpdateConfig struct {
	typeName                string
	DeleteRecordsJobConfig  *DeleteRecordsJobConfig
	FileJobConfig           *FileJobConfig
	PipelineJobConfig       *PipelineJobConfig
	ExportJobConfig         *ExportJobConfig
	MutateJobConfig         *MutateJobConfig
	FindAndReplaceJobConfig *FindAndReplaceJobConfig
	MappingProgramJobConfig *MappingProgramJobConfig
	EmptyObject             *EmptyObject
}

func NewJobUpdateConfigFromDeleteRecordsJobConfig(value *DeleteRecordsJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typeName: "deleteRecordsJobConfig", DeleteRecordsJobConfig: value}
}

func NewJobUpdateConfigFromFileJobConfig(value *FileJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typeName: "fileJobConfig", FileJobConfig: value}
}

func NewJobUpdateConfigFromPipelineJobConfig(value *PipelineJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typeName: "pipelineJobConfig", PipelineJobConfig: value}
}

func NewJobUpdateConfigFromExportJobConfig(value *ExportJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typeName: "exportJobConfig", ExportJobConfig: value}
}

func NewJobUpdateConfigFromMutateJobConfig(value *MutateJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typeName: "mutateJobConfig", MutateJobConfig: value}
}

func NewJobUpdateConfigFromFindAndReplaceJobConfig(value *FindAndReplaceJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typeName: "findAndReplaceJobConfig", FindAndReplaceJobConfig: value}
}

func NewJobUpdateConfigFromMappingProgramJobConfig(value *MappingProgramJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typeName: "mappingProgramJobConfig", MappingProgramJobConfig: value}
}

func NewJobUpdateConfigFromEmptyObject(value *EmptyObject) *JobUpdateConfig {
	return &JobUpdateConfig{typeName: "emptyObject", EmptyObject: value}
}

func (j *JobUpdateConfig) UnmarshalJSON(data []byte) error {
	valueDeleteRecordsJobConfig := new(DeleteRecordsJobConfig)
	if err := json.Unmarshal(data, &valueDeleteRecordsJobConfig); err == nil {
		j.typeName = "deleteRecordsJobConfig"
		j.DeleteRecordsJobConfig = valueDeleteRecordsJobConfig
		return nil
	}
	valueFileJobConfig := new(FileJobConfig)
	if err := json.Unmarshal(data, &valueFileJobConfig); err == nil {
		j.typeName = "fileJobConfig"
		j.FileJobConfig = valueFileJobConfig
		return nil
	}
	valuePipelineJobConfig := new(PipelineJobConfig)
	if err := json.Unmarshal(data, &valuePipelineJobConfig); err == nil {
		j.typeName = "pipelineJobConfig"
		j.PipelineJobConfig = valuePipelineJobConfig
		return nil
	}
	valueExportJobConfig := new(ExportJobConfig)
	if err := json.Unmarshal(data, &valueExportJobConfig); err == nil {
		j.typeName = "exportJobConfig"
		j.ExportJobConfig = valueExportJobConfig
		return nil
	}
	valueMutateJobConfig := new(MutateJobConfig)
	if err := json.Unmarshal(data, &valueMutateJobConfig); err == nil {
		j.typeName = "mutateJobConfig"
		j.MutateJobConfig = valueMutateJobConfig
		return nil
	}
	valueFindAndReplaceJobConfig := new(FindAndReplaceJobConfig)
	if err := json.Unmarshal(data, &valueFindAndReplaceJobConfig); err == nil {
		j.typeName = "findAndReplaceJobConfig"
		j.FindAndReplaceJobConfig = valueFindAndReplaceJobConfig
		return nil
	}
	valueMappingProgramJobConfig := new(MappingProgramJobConfig)
	if err := json.Unmarshal(data, &valueMappingProgramJobConfig); err == nil {
		j.typeName = "mappingProgramJobConfig"
		j.MappingProgramJobConfig = valueMappingProgramJobConfig
		return nil
	}
	valueEmptyObject := new(EmptyObject)
	if err := json.Unmarshal(data, &valueEmptyObject); err == nil {
		j.typeName = "emptyObject"
		j.EmptyObject = valueEmptyObject
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobUpdateConfig) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "deleteRecordsJobConfig":
		return json.Marshal(j.DeleteRecordsJobConfig)
	case "fileJobConfig":
		return json.Marshal(j.FileJobConfig)
	case "pipelineJobConfig":
		return json.Marshal(j.PipelineJobConfig)
	case "exportJobConfig":
		return json.Marshal(j.ExportJobConfig)
	case "mutateJobConfig":
		return json.Marshal(j.MutateJobConfig)
	case "findAndReplaceJobConfig":
		return json.Marshal(j.FindAndReplaceJobConfig)
	case "mappingProgramJobConfig":
		return json.Marshal(j.MappingProgramJobConfig)
	case "emptyObject":
		return json.Marshal(j.EmptyObject)
	}
}

type JobUpdateConfigVisitor interface {
	VisitDeleteRecordsJobConfig(*DeleteRecordsJobConfig) error
	VisitFileJobConfig(*FileJobConfig) error
	VisitPipelineJobConfig(*PipelineJobConfig) error
	VisitExportJobConfig(*ExportJobConfig) error
	VisitMutateJobConfig(*MutateJobConfig) error
	VisitFindAndReplaceJobConfig(*FindAndReplaceJobConfig) error
	VisitMappingProgramJobConfig(*MappingProgramJobConfig) error
	VisitEmptyObject(*EmptyObject) error
}

func (j *JobUpdateConfig) Accept(visitor JobUpdateConfigVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "deleteRecordsJobConfig":
		return visitor.VisitDeleteRecordsJobConfig(j.DeleteRecordsJobConfig)
	case "fileJobConfig":
		return visitor.VisitFileJobConfig(j.FileJobConfig)
	case "pipelineJobConfig":
		return visitor.VisitPipelineJobConfig(j.PipelineJobConfig)
	case "exportJobConfig":
		return visitor.VisitExportJobConfig(j.ExportJobConfig)
	case "mutateJobConfig":
		return visitor.VisitMutateJobConfig(j.MutateJobConfig)
	case "findAndReplaceJobConfig":
		return visitor.VisitFindAndReplaceJobConfig(j.FindAndReplaceJobConfig)
	case "mappingProgramJobConfig":
		return visitor.VisitMappingProgramJobConfig(j.MappingProgramJobConfig)
	case "emptyObject":
		return visitor.VisitEmptyObject(j.EmptyObject)
	}
}

type MappingProgramJobConfig struct {
	SourceSheetId      SheetId                  `json:"sourceSheetId" url:"sourceSheetId"`
	DestinationSheetId SheetId                  `json:"destinationSheetId" url:"destinationSheetId"`
	MappingRules       []map[string]interface{} `json:"mappingRules,omitempty" url:"mappingRules,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MappingProgramJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler MappingProgramJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MappingProgramJobConfig(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MappingProgramJobConfig) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Metadata struct {
	Certainty  *Certainty `json:"certainty,omitempty" url:"certainty,omitempty"`
	Confidence *float64   `json:"confidence,omitempty" url:"confidence,omitempty"`
	Source     *string    `json:"source,omitempty" url:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type unmarshaler Metadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metadata(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PipelineJobConfig struct {
	SourceSheetId      SheetId `json:"sourceSheetId" url:"sourceSheetId"`
	DestinationSheetId SheetId `json:"destinationSheetId" url:"destinationSheetId"`

	_rawJSON json.RawMessage
}

func (p *PipelineJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PipelineJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PipelineJobConfig(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PipelineJobConfig) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResourceJobSubject struct {
	Id string `json:"id" url:"id"`

	_rawJSON json.RawMessage
}

func (r *ResourceJobSubject) UnmarshalJSON(data []byte) error {
	type unmarshaler ResourceJobSubject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResourceJobSubject(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResourceJobSubject) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SourceField struct {
	// The description of the source field
	SourceField *Property `json:"sourceField,omitempty" url:"sourceField,omitempty"`
	// A list of preview values of the data in the source field
	Preview []string `json:"preview,omitempty" url:"preview,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SourceField) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceField(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceField) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The type of trigger to use for this job
type Trigger string

const (
	TriggerManual    Trigger = "manual"
	TriggerImmediate Trigger = "immediate"
)

func NewTriggerFromString(s string) (Trigger, error) {
	switch s {
	case "manual":
		return TriggerManual, nil
	case "immediate":
		return TriggerImmediate, nil
	}
	var t Trigger
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t Trigger) Ptr() *Trigger {
	return &t
}

type MappingRule struct {
	// Name of the mapping rule
	Name   string      `json:"name" url:"name"`
	Type   string      `json:"type" url:"type"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`
	// Time the mapping rule was last updated
	AcceptedAt *time.Time `json:"acceptedAt,omitempty" url:"acceptedAt,omitempty"`
	// User ID of the contributor of the mapping rule
	AcceptedBy *UserId `json:"acceptedBy,omitempty" url:"acceptedBy,omitempty"`
	// ID of the mapping rule
	Id MappingId `json:"id" url:"id"`
	// Confidence of the mapping rule
	Confidence *int `json:"confidence,omitempty" url:"confidence,omitempty"`
	// User ID of the user who suggested the mapping rule
	CreatedBy *UserId `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Time the mapping rule was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Time the mapping rule was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Time the mapping rule was deleted
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MappingRule) UnmarshalJSON(data []byte) error {
	type embed MappingRule
	var unmarshaler = struct {
		embed
		AcceptedAt *core.DateTime `json:"acceptedAt,omitempty"`
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		DeletedAt  *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MappingRule(unmarshaler.embed)
	m.AcceptedAt = unmarshaler.AcceptedAt.TimePtr()
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	m.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MappingRule) MarshalJSON() ([]byte, error) {
	type embed MappingRule
	var marshaler = struct {
		embed
		AcceptedAt *core.DateTime `json:"acceptedAt,omitempty"`
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		DeletedAt  *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed:      embed(*m),
		AcceptedAt: core.NewOptionalDateTime(m.AcceptedAt),
		CreatedAt:  core.NewDateTime(m.CreatedAt),
		UpdatedAt:  core.NewDateTime(m.UpdatedAt),
		DeletedAt:  core.NewOptionalDateTime(m.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (m *MappingRule) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MappingRuleOrConfig struct {
	// Name of the mapping rule
	Name   string      `json:"name" url:"name"`
	Type   string      `json:"type" url:"type"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`
	// Time the mapping rule was last updated
	AcceptedAt *time.Time `json:"acceptedAt,omitempty" url:"acceptedAt,omitempty"`
	// User ID of the contributor of the mapping rule
	AcceptedBy *UserId `json:"acceptedBy,omitempty" url:"acceptedBy,omitempty"`
	// ID of the mapping rule
	Id *MappingId `json:"id,omitempty" url:"id,omitempty"`
	// Confidence of the mapping rule
	Confidence *int `json:"confidence,omitempty" url:"confidence,omitempty"`
	// User ID of the creator of the mapping rule
	CreatedBy *UserId `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Time the mapping rule was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// Time the mapping rule was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// Time the mapping rule was deleted
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MappingRuleOrConfig) UnmarshalJSON(data []byte) error {
	type embed MappingRuleOrConfig
	var unmarshaler = struct {
		embed
		AcceptedAt *core.DateTime `json:"acceptedAt,omitempty"`
		CreatedAt  *core.DateTime `json:"createdAt,omitempty"`
		UpdatedAt  *core.DateTime `json:"updatedAt,omitempty"`
		DeletedAt  *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MappingRuleOrConfig(unmarshaler.embed)
	m.AcceptedAt = unmarshaler.AcceptedAt.TimePtr()
	m.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	m.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	m.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MappingRuleOrConfig) MarshalJSON() ([]byte, error) {
	type embed MappingRuleOrConfig
	var marshaler = struct {
		embed
		AcceptedAt *core.DateTime `json:"acceptedAt,omitempty"`
		CreatedAt  *core.DateTime `json:"createdAt,omitempty"`
		UpdatedAt  *core.DateTime `json:"updatedAt,omitempty"`
		DeletedAt  *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed:      embed(*m),
		AcceptedAt: core.NewOptionalDateTime(m.AcceptedAt),
		CreatedAt:  core.NewOptionalDateTime(m.CreatedAt),
		UpdatedAt:  core.NewOptionalDateTime(m.UpdatedAt),
		DeletedAt:  core.NewOptionalDateTime(m.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (m *MappingRuleOrConfig) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Program struct {
	// Mapping rules
	Rules []*MappingRuleOrConfig `json:"rules,omitempty" url:"rules,omitempty"`
	// If this program was saved, this is the ID of the program
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Namespace of the program
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Family ID of the program, if it belongs to a family
	FamilyId *FamilyId `json:"familyId,omitempty" url:"familyId,omitempty"`
	// If this program was saved, this is the time it was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// If this program was saved, this is the user ID of the creator
	CreatedBy *UserId `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Source keys
	SourceKeys []string `json:"sourceKeys,omitempty" url:"sourceKeys,omitempty"`
	// Destination keys
	DestinationKeys []string `json:"destinationKeys,omitempty" url:"destinationKeys,omitempty"`
	// Summary of the mapping rules
	Summary *ProgramSummary `json:"summary,omitempty" url:"summary,omitempty"`
	// If this program was saved, this token allows you to modify the program
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Program) UnmarshalJSON(data []byte) error {
	type embed Program
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Program(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Program) MarshalJSON() ([]byte, error) {
	type embed Program
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*p),
		CreatedAt: core.NewOptionalDateTime(p.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *Program) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProgramSummary struct {
	// Total number of mapping rules
	TotalRuleCount int `json:"totalRuleCount" url:"totalRuleCount"`
	// Number of mapping rules added
	AddedRuleCount int `json:"addedRuleCount" url:"addedRuleCount"`
	// Number of mapping rules deleted
	DeletedRuleCount int `json:"deletedRuleCount" url:"deletedRuleCount"`

	_rawJSON json.RawMessage
}

func (p *ProgramSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler ProgramSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProgramSummary(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProgramSummary) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ArrayableProperty struct {
	// Will allow multiple values and store as an array
	IsArray *bool `json:"isArray,omitempty" url:"isArray,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ArrayableProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ArrayableProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArrayableProperty(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArrayableProperty) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BaseProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string          `json:"description,omitempty" url:"description,omitempty"`
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BaseProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseProperty(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseProperty) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A `true` or `false` value type. Matching engines should attempt to resolve all common ways of representing this value and it should usually be displayed as a checkbox.
type BooleanProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string          `json:"description,omitempty" url:"description,omitempty"`
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string               `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string               `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *BooleanPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BooleanProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanProperty(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanProperty) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BooleanPropertyConfig struct {
	// Allow a neither true or false state to be stored as `null`
	AllowIndeterminate bool `json:"allowIndeterminate" url:"allowIndeterminate"`

	_rawJSON json.RawMessage
}

func (b *BooleanPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanPropertyConfig(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanPropertyConfig) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Constraint struct {
	Type     string
	Required interface{}
	Unique   *UniqueConstraint
	Computed interface{}
	External *ExternalConstraint
}

func NewConstraintFromRequired(value interface{}) *Constraint {
	return &Constraint{Type: "required", Required: value}
}

func NewConstraintFromUnique(value *UniqueConstraint) *Constraint {
	return &Constraint{Type: "unique", Unique: value}
}

func NewConstraintFromComputed(value interface{}) *Constraint {
	return &Constraint{Type: "computed", Computed: value}
}

func NewConstraintFromExternal(value *ExternalConstraint) *Constraint {
	return &Constraint{Type: "external", External: value}
}

func (c *Constraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "required":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Required = value
	case "unique":
		value := new(UniqueConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Unique = value
	case "computed":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Computed = value
	case "external":
		value := new(ExternalConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.External = value
	}
	return nil
}

func (c Constraint) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "required":
		var marshaler = struct {
			Type     string      `json:"type"`
			Required interface{} `json:"required,omitempty"`
		}{
			Type:     c.Type,
			Required: c.Required,
		}
		return json.Marshal(marshaler)
	case "unique":
		var marshaler = struct {
			Type string `json:"type"`
			*UniqueConstraint
		}{
			Type:             c.Type,
			UniqueConstraint: c.Unique,
		}
		return json.Marshal(marshaler)
	case "computed":
		var marshaler = struct {
			Type     string      `json:"type"`
			Computed interface{} `json:"computed,omitempty"`
		}{
			Type:     c.Type,
			Computed: c.Computed,
		}
		return json.Marshal(marshaler)
	case "external":
		var marshaler = struct {
			Type string `json:"type"`
			*ExternalConstraint
		}{
			Type:               c.Type,
			ExternalConstraint: c.External,
		}
		return json.Marshal(marshaler)
	}
}

type ConstraintVisitor interface {
	VisitRequired(interface{}) error
	VisitUnique(*UniqueConstraint) error
	VisitComputed(interface{}) error
	VisitExternal(*ExternalConstraint) error
}

func (c *Constraint) Accept(visitor ConstraintVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "required":
		return visitor.VisitRequired(c.Required)
	case "unique":
		return visitor.VisitUnique(c.Unique)
	case "computed":
		return visitor.VisitComputed(c.Computed)
	case "external":
		return visitor.VisitExternal(c.External)
	}
}

// Store a field as a GMT date. Data hooks must convert this value into a `YYYY-MM-DD` format in order for it to be considered a valid value. Datetime should be a separate and future supported value as it must consider timezone.
type DateProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string          `json:"description,omitempty" url:"description,omitempty"`
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DateProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler DateProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateProperty(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateProperty) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines an enumerated list of options for the user to select from. Matching tooling attempts to resolve incoming data assigment to a valid option. The maximum number of options for this list is `100`. For larger lists, users should use the reference or future `lookup` types.
type EnumProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string          `json:"description,omitempty" url:"description,omitempty"`
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool `json:"isArray,omitempty" url:"isArray,omitempty"`
	// Will allow multiple values and store / provide the values in an array if set. Not all field types support arrays.
	Multi  *bool               `json:"multi,omitempty" url:"multi,omitempty"`
	Config *EnumPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EnumProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumProperty(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumProperty) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertyConfig struct {
	// Permit the user to create new options for this specific field.
	AllowCustom *bool                 `json:"allowCustom,omitempty" url:"allowCustom,omitempty"`
	Options     []*EnumPropertyOption `json:"options,omitempty" url:"options,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EnumPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumPropertyConfig(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumPropertyConfig) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertyOption struct {
	// A visual label for this option, defaults to value if not provided
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// An optional color to assign this option
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// A reference pointer to a previously registered icon
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// An arbitrary JSON object to be associated with this option and made available to hooks
	Meta map[string]interface{} `json:"meta,omitempty" url:"meta,omitempty"`
	// The value or ID of this option. This value will be sent in egress. The type is a string | integer | boolean.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Alternative names to match this enum option to
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EnumPropertyOption) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumPropertyOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumPropertyOption(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumPropertyOption) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalConstraint struct {
	Validator string      `json:"validator" url:"validator"`
	Config    interface{} `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExternalConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalConstraint(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalConstraint) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Control the appearance of this field when it's displayed in a table or input
type FieldAppearance struct {
	Size *FieldSize `json:"size,omitempty" url:"size,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldAppearance) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldAppearance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldAppearance(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldAppearance) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The default visual sizing. This sizing may be overridden by a user
type FieldSize string

const (
	FieldSizeXs FieldSize = "xs"
	FieldSizeS  FieldSize = "s"
	FieldSizeM  FieldSize = "m"
	FieldSizeL  FieldSize = "l"
	FieldSizeXl FieldSize = "xl"
)

func NewFieldSizeFromString(s string) (FieldSize, error) {
	switch s {
	case "xs":
		return FieldSizeXs, nil
	case "s":
		return FieldSizeS, nil
	case "m":
		return FieldSizeM, nil
	case "l":
		return FieldSizeL, nil
	case "xl":
		return FieldSizeXl, nil
	}
	var t FieldSize
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldSize) Ptr() *FieldSize {
	return &f
}

type NumberConfig struct {
	// Number of decimal places to round data to
	DecimalPlaces *int `json:"decimalPlaces,omitempty" url:"decimalPlaces,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NumberConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberConfig(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberConfig) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Defines a property that should be stored and read as either an integer or floating point number. Database engines should look at the configuration to determine ideal storage format.
type NumberProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string          `json:"description,omitempty" url:"description,omitempty"`
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool         `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *NumberConfig `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NumberProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberProperty(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberProperty) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Defines a reference to another sheet. Links should be established automatically by the matching engine or similar upon an evaluation of unique or similar columns between datasets.
type ReferenceProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string          `json:"description,omitempty" url:"description,omitempty"`
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool                    `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *ReferencePropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (r *ReferenceProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceProperty(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceProperty) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencePropertyConfig struct {
	// Full path reference to a sheet configuration. Must be in the same workbook.
	Ref string `json:"ref" url:"ref"`
	// Key of the property to use as the reference key. Defaults to `id`
	Key string `json:"key" url:"key"`
	// The type of relationship this defines
	Relationship ReferencePropertyRelationship `json:"relationship,omitempty" url:"relationship,omitempty"`

	_rawJSON json.RawMessage
}

func (r *ReferencePropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencePropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencePropertyConfig(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferencePropertyConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencePropertyRelationship string

const (
	ReferencePropertyRelationshipHasOne  ReferencePropertyRelationship = "has-one"
	ReferencePropertyRelationshipHasMany ReferencePropertyRelationship = "has-many"
)

func NewReferencePropertyRelationshipFromString(s string) (ReferencePropertyRelationship, error) {
	switch s {
	case "has-one":
		return ReferencePropertyRelationshipHasOne, nil
	case "has-many":
		return ReferencePropertyRelationshipHasMany, nil
	}
	var t ReferencePropertyRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReferencePropertyRelationship) Ptr() *ReferencePropertyRelationship {
	return &r
}

type StringConfig struct {
	Size StringConfigOptions `json:"size,omitempty" url:"size,omitempty"`

	_rawJSON json.RawMessage
}

func (s *StringConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler StringConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringConfig(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// How much text should be storeable in this field
type StringConfigOptions string

const (
	// up to 255 characters
	StringConfigOptionsTiny StringConfigOptions = "tiny"
	// 64kb (default)
	StringConfigOptionsNormal StringConfigOptions = "normal"
	// 16mb
	StringConfigOptionsMedium StringConfigOptions = "medium"
	// 4gb
	StringConfigOptionsLong StringConfigOptions = "long"
)

func NewStringConfigOptionsFromString(s string) (StringConfigOptions, error) {
	switch s {
	case "tiny":
		return StringConfigOptionsTiny, nil
	case "normal":
		return StringConfigOptionsNormal, nil
	case "medium":
		return StringConfigOptionsMedium, nil
	case "long":
		return StringConfigOptionsLong, nil
	}
	var t StringConfigOptions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StringConfigOptions) Ptr() *StringConfigOptions {
	return &s
}

// Defines a property that should be stored and read as a basic string. Database engines should expect any length of text to be provided here unless explicitly defined in the config.
type StringProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string          `json:"description,omitempty" url:"description,omitempty"`
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string      `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string      `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *StringConfig `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (s *StringProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler StringProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringProperty(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringProperty) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UniqueConstraint struct {
	Config *UniqueConstraintConfig `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UniqueConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler UniqueConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UniqueConstraint(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UniqueConstraint) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UniqueConstraintConfig struct {
	// Ignore casing when determining uniqueness
	CaseSensitive *bool `json:"caseSensitive,omitempty" url:"caseSensitive,omitempty"`
	// Do not flag empty values as duplicate
	IgnoreEmpty *bool `json:"ignoreEmpty,omitempty" url:"ignoreEmpty,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UniqueConstraintConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler UniqueConstraintConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UniqueConstraintConfig(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UniqueConstraintConfig) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// CellConfig
type CellConfig struct {
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CellConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CellConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CellConfig(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CellValue struct {
	Valid     *bool                  `json:"valid,omitempty" url:"valid,omitempty"`
	Messages  []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value     *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer     *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CellValue) UnmarshalJSON(data []byte) error {
	type embed CellValue
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CellValue(unmarshaler.embed)
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellValue) MarshalJSON() ([]byte, error) {
	type embed CellValue
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CellValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CellValueWithLinks struct {
	Valid     *bool                  `json:"valid,omitempty" url:"valid,omitempty"`
	Messages  []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value     *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer     *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	Links     *Records               `json:"links,omitempty" url:"links,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CellValueWithLinks) UnmarshalJSON(data []byte) error {
	type embed CellValueWithLinks
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CellValueWithLinks(unmarshaler.embed)
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellValueWithLinks) MarshalJSON() ([]byte, error) {
	type embed CellValueWithLinks
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CellValueWithLinks) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DiffData = map[string]*DiffValue

type DiffRecord struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`
	Values   DiffData               `json:"values,omitempty" url:"values,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DiffRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler DiffRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiffRecord(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffRecord) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// List of DiffRecord objects
type DiffRecords = []*DiffRecord

type DiffRecordsResponse struct {
	Data DiffRecords `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DiffRecordsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DiffRecordsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiffRecordsResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffRecordsResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DiffValue struct {
	Valid         *bool                  `json:"valid,omitempty" url:"valid,omitempty"`
	Messages      []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata      map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value         *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer         *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt     *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	SnapshotValue *CellValueUnion        `json:"snapshotValue,omitempty" url:"snapshotValue,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DiffValue) UnmarshalJSON(data []byte) error {
	type embed DiffValue
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DiffValue(unmarshaler.embed)
	d.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffValue) MarshalJSON() ([]byte, error) {
	type embed DiffValue
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*d),
		UpdatedAt: core.NewOptionalDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DiffValue) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type FieldRecordCounts struct {
	Total int `json:"total" url:"total"`
	Valid int `json:"valid" url:"valid"`
	Error int `json:"error" url:"error"`
	Empty int `json:"empty" url:"empty"`

	_rawJSON json.RawMessage
}

func (f *FieldRecordCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldRecordCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldRecordCounts(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldRecordCounts) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A list of records with optional record counts
type GetRecordsResponseData struct {
	Success bool             `json:"success" url:"success"`
	Records RecordsWithLinks `json:"records,omitempty" url:"records,omitempty"`
	Counts  *RecordCounts    `json:"counts,omitempty" url:"counts,omitempty"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetRecordsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetRecordsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetRecordsResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetRecordsResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A single row of data in a Sheet
type Record struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`
	Values   RecordData             `json:"values,omitempty" url:"values,omitempty"`

	_rawJSON json.RawMessage
}

func (r *Record) UnmarshalJSON(data []byte) error {
	type unmarshaler Record
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Record(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Record) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordBase struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecordBase) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordBase(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordBase) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Configuration of a record or specific fields in the record
type RecordConfig struct {
	Readonly *bool                  `json:"readonly,omitempty" url:"readonly,omitempty"`
	Fields   map[string]*CellConfig `json:"fields,omitempty" url:"fields,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecordConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordConfig(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordCounts struct {
	Total         int            `json:"total" url:"total"`
	Valid         int            `json:"valid" url:"valid"`
	Error         int            `json:"error" url:"error"`
	ErrorsByField map[string]int `json:"errorsByField,omitempty" url:"errorsByField,omitempty"`
	// Counts for valid, error, and total records grouped by field key
	ByField map[string]*FieldRecordCounts `json:"byField,omitempty" url:"byField,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecordCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordCounts(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordCounts) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A single row of data in a Sheet
type RecordData = map[string]*CellValue

// A single row of data in a Sheet, including links to related rows
type RecordDataWithLinks = map[string]*CellValueWithLinks

// A single row of data in a Sheet, including links to related rows
type RecordWithLinks struct {
	Id       RecordId               `json:"id" url:"id"`
	Values   RecordDataWithLinks    `json:"values,omitempty" url:"values,omitempty"`
	Valid    *bool                  `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecordWithLinks) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordWithLinks
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordWithLinks(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordWithLinks) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// List of Record objects
type Records = []*Record

type RecordsResponse struct {
	Data *RecordsResponseData `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecordsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordsResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordsResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordsResponseData struct {
	Success bool              `json:"success" url:"success"`
	Records *RecordsWithLinks `json:"records,omitempty" url:"records,omitempty"`
	Counts  *RecordCounts     `json:"counts,omitempty" url:"counts,omitempty"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecordsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordsResponseData(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordsResponseData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// List of Record objects, including links to related rows
type RecordsWithLinks = []*RecordWithLinks

// Record data validation messages
type ValidationMessage struct {
	Type    *ValidationType   `json:"type,omitempty" url:"type,omitempty"`
	Source  *ValidationSource `json:"source,omitempty" url:"source,omitempty"`
	Message *string           `json:"message,omitempty" url:"message,omitempty"`

	_rawJSON json.RawMessage
}

func (v *ValidationMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationMessage(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationMessage) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationSource string

const (
	ValidationSourceRequiredConstraint ValidationSource = "required-constraint"
	ValidationSourceUniqueConstraint   ValidationSource = "unique-constraint"
	ValidationSourceCustomLogic        ValidationSource = "custom-logic"
	ValidationSourceUnlinked           ValidationSource = "unlinked"
	ValidationSourceInvalidOption      ValidationSource = "invalid-option"
	ValidationSourceIsArtifact         ValidationSource = "is-artifact"
)

func NewValidationSourceFromString(s string) (ValidationSource, error) {
	switch s {
	case "required-constraint":
		return ValidationSourceRequiredConstraint, nil
	case "unique-constraint":
		return ValidationSourceUniqueConstraint, nil
	case "custom-logic":
		return ValidationSourceCustomLogic, nil
	case "unlinked":
		return ValidationSourceUnlinked, nil
	case "invalid-option":
		return ValidationSourceInvalidOption, nil
	case "is-artifact":
		return ValidationSourceIsArtifact, nil
	}
	var t ValidationSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v ValidationSource) Ptr() *ValidationSource {
	return &v
}

type ValidationType string

const (
	ValidationTypeError ValidationType = "error"
	ValidationTypeWarn  ValidationType = "warn"
	ValidationTypeInfo  ValidationType = "info"
)

func NewValidationTypeFromString(s string) (ValidationType, error) {
	switch s {
	case "error":
		return ValidationTypeError, nil
	case "warn":
		return ValidationTypeWarn, nil
	case "info":
		return ValidationTypeInfo, nil
	}
	var t ValidationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v ValidationType) Ptr() *ValidationType {
	return &v
}

type ActorIdUnion struct {
	typeName string
	UserId   UserId
	AgentId  AgentId
	GuestId  GuestId
}

func NewActorIdUnionFromUserId(value UserId) *ActorIdUnion {
	return &ActorIdUnion{typeName: "userId", UserId: value}
}

func NewActorIdUnionFromAgentId(value AgentId) *ActorIdUnion {
	return &ActorIdUnion{typeName: "agentId", AgentId: value}
}

func NewActorIdUnionFromGuestId(value GuestId) *ActorIdUnion {
	return &ActorIdUnion{typeName: "guestId", GuestId: value}
}

func (a *ActorIdUnion) UnmarshalJSON(data []byte) error {
	var valueUserId UserId
	if err := json.Unmarshal(data, &valueUserId); err == nil {
		a.typeName = "userId"
		a.UserId = valueUserId
		return nil
	}
	var valueAgentId AgentId
	if err := json.Unmarshal(data, &valueAgentId); err == nil {
		a.typeName = "agentId"
		a.AgentId = valueAgentId
		return nil
	}
	var valueGuestId GuestId
	if err := json.Unmarshal(data, &valueGuestId); err == nil {
		a.typeName = "guestId"
		a.GuestId = valueGuestId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActorIdUnion) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "userId":
		return json.Marshal(a.UserId)
	case "agentId":
		return json.Marshal(a.AgentId)
	case "guestId":
		return json.Marshal(a.GuestId)
	}
}

type ActorIdUnionVisitor interface {
	VisitUserId(UserId) error
	VisitAgentId(AgentId) error
	VisitGuestId(GuestId) error
}

func (a *ActorIdUnion) Accept(visitor ActorIdUnionVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "userId":
		return visitor.VisitUserId(a.UserId)
	case "agentId":
		return visitor.VisitAgentId(a.AgentId)
	case "guestId":
		return visitor.VisitGuestId(a.GuestId)
	}
}

type ActorRoleResponse struct {
	Id         ActorRoleId      `json:"id" url:"id"`
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ActorId    *ActorIdUnion    `json:"actorId,omitempty" url:"actorId,omitempty"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`
	CreatedAt  time.Time        `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time        `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (a *ActorRoleResponse) UnmarshalJSON(data []byte) error {
	type embed ActorRoleResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ActorRoleResponse(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActorRoleResponse) MarshalJSON() ([]byte, error) {
	type embed ActorRoleResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ActorRoleResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignActorRoleRequest struct {
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AssignActorRoleRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AssignActorRoleRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssignActorRoleRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignActorRoleRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignRoleResponse struct {
	Data *AssignRoleResponseData `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AssignRoleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AssignRoleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssignRoleResponse(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignRoleResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignRoleResponseData struct {
	Id         ActorRoleId      `json:"id" url:"id"`
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ActorId    *ActorIdUnion    `json:"actorId,omitempty" url:"actorId,omitempty"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`
	CreatedAt  time.Time        `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time        `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (a *AssignRoleResponseData) UnmarshalJSON(data []byte) error {
	type embed AssignRoleResponseData
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssignRoleResponseData(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignRoleResponseData) MarshalJSON() ([]byte, error) {
	type embed AssignRoleResponseData
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *AssignRoleResponseData) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ListActorRolesResponse struct {
	Data []*ActorRoleResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListActorRolesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListActorRolesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListActorRolesResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListActorRolesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ResourceIdUnion struct {
	typeName      string
	AccountId     AccountId
	EnvironmentId EnvironmentId
	SpaceId       SpaceId
}

func NewResourceIdUnionFromAccountId(value AccountId) *ResourceIdUnion {
	return &ResourceIdUnion{typeName: "accountId", AccountId: value}
}

func NewResourceIdUnionFromEnvironmentId(value EnvironmentId) *ResourceIdUnion {
	return &ResourceIdUnion{typeName: "environmentId", EnvironmentId: value}
}

func NewResourceIdUnionFromSpaceId(value SpaceId) *ResourceIdUnion {
	return &ResourceIdUnion{typeName: "spaceId", SpaceId: value}
}

func (r *ResourceIdUnion) UnmarshalJSON(data []byte) error {
	var valueAccountId AccountId
	if err := json.Unmarshal(data, &valueAccountId); err == nil {
		r.typeName = "accountId"
		r.AccountId = valueAccountId
		return nil
	}
	var valueEnvironmentId EnvironmentId
	if err := json.Unmarshal(data, &valueEnvironmentId); err == nil {
		r.typeName = "environmentId"
		r.EnvironmentId = valueEnvironmentId
		return nil
	}
	var valueSpaceId SpaceId
	if err := json.Unmarshal(data, &valueSpaceId); err == nil {
		r.typeName = "spaceId"
		r.SpaceId = valueSpaceId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r ResourceIdUnion) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "accountId":
		return json.Marshal(r.AccountId)
	case "environmentId":
		return json.Marshal(r.EnvironmentId)
	case "spaceId":
		return json.Marshal(r.SpaceId)
	}
}

type ResourceIdUnionVisitor interface {
	VisitAccountId(AccountId) error
	VisitEnvironmentId(EnvironmentId) error
	VisitSpaceId(SpaceId) error
}

func (r *ResourceIdUnion) Accept(visitor ResourceIdUnionVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "accountId":
		return visitor.VisitAccountId(r.AccountId)
	case "environmentId":
		return visitor.VisitEnvironmentId(r.EnvironmentId)
	case "spaceId":
		return visitor.VisitSpaceId(r.SpaceId)
	}
}

type RoleResponse struct {
	Id        RoleId    `json:"id" url:"id"`
	Name      string    `json:"name" url:"name"`
	AccountId AccountId `json:"accountId" url:"accountId"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (r *RoleResponse) UnmarshalJSON(data []byte) error {
	type embed RoleResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RoleResponse(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleResponse) MarshalJSON() ([]byte, error) {
	type embed RoleResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (r *RoleResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The value of a secret
type Secret struct {
	// The reference name for a secret.
	Name SecretName `json:"name" url:"name"`
	// The secret value. This is hidden in the UI.
	Value SecretValue `json:"value" url:"value"`
	// The Environment of the secret.
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The Space of the secret.
	SpaceId *SpaceId `json:"spaceId,omitempty" url:"spaceId,omitempty"`
	// The ID of the secret.
	Id SecretId `json:"id" url:"id"`

	_rawJSON json.RawMessage
}

func (s *Secret) UnmarshalJSON(data []byte) error {
	type unmarshaler Secret
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Secret(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Secret) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The name of a secret. Minimum 1 character, maximum 1024
type SecretName = string

// The value of a secret. Minimum 1 character, maximum 1024
type SecretValue = string

type CellValueWithCounts struct {
	Valid     *bool                  `json:"valid,omitempty" url:"valid,omitempty"`
	Messages  []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value     *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer     *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	Counts    *RecordCounts          `json:"counts,omitempty" url:"counts,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CellValueWithCounts) UnmarshalJSON(data []byte) error {
	type embed CellValueWithCounts
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CellValueWithCounts(unmarshaler.embed)
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellValueWithCounts) MarshalJSON() ([]byte, error) {
	type embed CellValueWithCounts
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CellValueWithCounts) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Cell values grouped by field key
type CellsResponseData = map[string][]*CellValueWithCounts

type CompositeUniqueConstraint struct {
	// The name of the constraint
	Name string `json:"name" url:"name"`
	// The fields that must be unique together
	Fields   []string                          `json:"fields,omitempty" url:"fields,omitempty"`
	Strategy CompositeUniqueConstraintStrategy `json:"strategy,omitempty" url:"strategy,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CompositeUniqueConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler CompositeUniqueConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompositeUniqueConstraint(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompositeUniqueConstraint) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CompositeUniqueConstraintStrategy string

const (
	// A hash of the fields will be used to determine uniqueness
	CompositeUniqueConstraintStrategyHash CompositeUniqueConstraintStrategy = "hash"
	// The values of the fields will be concatenated to determine uniqueness
	CompositeUniqueConstraintStrategyConcat CompositeUniqueConstraintStrategy = "concat"
)

func NewCompositeUniqueConstraintStrategyFromString(s string) (CompositeUniqueConstraintStrategy, error) {
	switch s {
	case "hash":
		return CompositeUniqueConstraintStrategyHash, nil
	case "concat":
		return CompositeUniqueConstraintStrategyConcat, nil
	}
	var t CompositeUniqueConstraintStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CompositeUniqueConstraintStrategy) Ptr() *CompositeUniqueConstraintStrategy {
	return &c
}

type ExternalSheetConstraint struct {
	Validator string `json:"validator" url:"validator"`
	// The fields that must be unique together
	Fields []string    `json:"fields,omitempty" url:"fields,omitempty"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExternalSheetConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalSheetConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalSheetConstraint(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalSheetConstraint) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ListSheetsResponse struct {
	Data []*Sheet `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListSheetsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSheetsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSheetsResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSheetsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type RecordCountsResponseData struct {
	Counts  *RecordCounts `json:"counts,omitempty" url:"counts,omitempty"`
	Success bool          `json:"success" url:"success"`

	_rawJSON json.RawMessage
}

func (r *RecordCountsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordCountsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordCountsResponseData(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordCountsResponseData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A place to store tabular data
type Sheet struct {
	// The ID of the Sheet.
	Id SheetId `json:"id" url:"id"`
	// The ID of the Workbook.
	WorkbookId WorkbookId `json:"workbookId" url:"workbookId"`
	// The name of the Sheet.
	Name string `json:"name" url:"name"`
	// The slug of the Sheet.
	Slug string `json:"slug" url:"slug"`
	// Describes shape of data as well as behavior
	Config *SheetConfig `json:"config,omitempty" url:"config,omitempty"`
	// The scoped namespace of the Sheet.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// The actor who locked the Sheet.
	LockedBy *string `json:"lockedBy,omitempty" url:"lockedBy,omitempty"`
	// Date the sheet was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date the sheet was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The time the Sheet was locked.
	LockedAt *time.Time `json:"lockedAt,omitempty" url:"lockedAt,omitempty"`
	// The precomputed counts of records in the Sheet (may not exist).
	RecordCounts *RecordCounts `json:"recordCounts,omitempty" url:"recordCounts,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Sheet) UnmarshalJSON(data []byte) error {
	type embed Sheet
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		LockedAt  *core.DateTime `json:"lockedAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Sheet(unmarshaler.embed)
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.LockedAt = unmarshaler.LockedAt.TimePtr()
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Sheet) MarshalJSON() ([]byte, error) {
	type embed Sheet
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		LockedAt  *core.DateTime `json:"lockedAt,omitempty"`
	}{
		embed:     embed(*s),
		UpdatedAt: core.NewDateTime(s.UpdatedAt),
		CreatedAt: core.NewDateTime(s.CreatedAt),
		LockedAt:  core.NewOptionalDateTime(s.LockedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Sheet) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SheetAccess string

const (
	SheetAccessAll    SheetAccess = "*"
	SheetAccessAdd    SheetAccess = "add"
	SheetAccessEdit   SheetAccess = "edit"
	SheetAccessDelete SheetAccess = "delete"
	SheetAccessImport SheetAccess = "import"
)

func NewSheetAccessFromString(s string) (SheetAccess, error) {
	switch s {
	case "*":
		return SheetAccessAll, nil
	case "add":
		return SheetAccessAdd, nil
	case "edit":
		return SheetAccessEdit, nil
	case "delete":
		return SheetAccessDelete, nil
	case "import":
		return SheetAccessImport, nil
	}
	var t SheetAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SheetAccess) Ptr() *SheetAccess {
	return &s
}

// Describes shape of data as well as behavior
type SheetConfig struct {
	// The name of your Sheet as it will appear to your end users.
	Name string `json:"name" url:"name"`
	// A sentence or two describing the purpose of your Sheet.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A unique identifier for your Sheet.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// A boolean specifying whether or not this sheet is read only. Read only sheets are not editable by end users.
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`
	// Allow end users to add fields during mapping.
	AllowAdditionalFields *bool `json:"allowAdditionalFields,omitempty" url:"allowAdditionalFields,omitempty"`
	// The minimum confidence required to automatically map a field
	MappingConfidenceThreshold *float64 `json:"mappingConfidenceThreshold,omitempty" url:"mappingConfidenceThreshold,omitempty"`
	// Control Sheet-level access for all users.
	Access []SheetAccess `json:"access,omitempty" url:"access,omitempty"`
	// Where you define your Sheets data schema.
	Fields []*Property `json:"fields,omitempty" url:"fields,omitempty"`
	// An array of actions that end users can perform on this Sheet.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// An array of constraints that end users can perform on this Sheet.
	Constraints []*SheetConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SheetConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SheetConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SheetConfig(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SheetConfigOrUpdate struct {
	// The name of your Sheet as it will appear to your end users.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A sentence or two describing the purpose of your Sheet.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A unique identifier for your Sheet. **Required when updating a Workbook.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// A boolean specifying whether or not this sheet is read only. Read only sheets are not editable by end users.
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`
	// Allow end users to add fields during mapping.
	AllowAdditionalFields *bool `json:"allowAdditionalFields,omitempty" url:"allowAdditionalFields,omitempty"`
	// The minimum confidence required to automatically map a field
	MappingConfidenceThreshold *float64 `json:"mappingConfidenceThreshold,omitempty" url:"mappingConfidenceThreshold,omitempty"`
	// Control Sheet-level access for all users.
	Access []SheetAccess `json:"access,omitempty" url:"access,omitempty"`
	// Where you define your Sheets data schema.
	Fields []*Property `json:"fields,omitempty" url:"fields,omitempty"`
	// An array of actions that end users can perform on this Sheet.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// The ID of the Sheet.
	Id *SheetId `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the Workbook.
	WorkbookId *WorkbookId `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	// Describes shape of data as well as behavior.
	Config *SheetConfig `json:"config,omitempty" url:"config,omitempty"`
	// The scoped namespace of the Sheet.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Date the sheet was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// Date the sheet was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SheetConfigOrUpdate) UnmarshalJSON(data []byte) error {
	type embed SheetConfigOrUpdate
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SheetConfigOrUpdate(unmarshaler.embed)
	s.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetConfigOrUpdate) MarshalJSON() ([]byte, error) {
	type embed SheetConfigOrUpdate
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*s),
		UpdatedAt: core.NewOptionalDateTime(s.UpdatedAt),
		CreatedAt: core.NewOptionalDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *SheetConfigOrUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Changes to make to an existing sheet config
type SheetConfigUpdate struct {
	// The name of your Sheet as it will appear to your end users.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A sentence or two describing the purpose of your Sheet.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A unique identifier for your Sheet. **Required when updating a Workbook.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// A boolean specifying whether or not this sheet is read only. Read only sheets are not editable by end users.
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`
	// Allow end users to add fields during mapping.
	AllowAdditionalFields *bool `json:"allowAdditionalFields,omitempty" url:"allowAdditionalFields,omitempty"`
	// The minimum confidence required to automatically map a field
	MappingConfidenceThreshold *float64 `json:"mappingConfidenceThreshold,omitempty" url:"mappingConfidenceThreshold,omitempty"`
	// Control Sheet-level access for all users.
	Access []SheetAccess `json:"access,omitempty" url:"access,omitempty"`
	// Where you define your Sheets data schema.
	Fields []*Property `json:"fields,omitempty" url:"fields,omitempty"`
	// An array of actions that end users can perform on this Sheet.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SheetConfigUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler SheetConfigUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SheetConfigUpdate(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetConfigUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SheetConstraint struct {
	Type     string
	Unique   *CompositeUniqueConstraint
	External *ExternalSheetConstraint
}

func NewSheetConstraintFromUnique(value *CompositeUniqueConstraint) *SheetConstraint {
	return &SheetConstraint{Type: "unique", Unique: value}
}

func NewSheetConstraintFromExternal(value *ExternalSheetConstraint) *SheetConstraint {
	return &SheetConstraint{Type: "external", External: value}
}

func (s *SheetConstraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "unique":
		value := new(CompositeUniqueConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Unique = value
	case "external":
		value := new(ExternalSheetConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.External = value
	}
	return nil
}

func (s SheetConstraint) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "unique":
		var marshaler = struct {
			Type string `json:"type"`
			*CompositeUniqueConstraint
		}{
			Type:                      s.Type,
			CompositeUniqueConstraint: s.Unique,
		}
		return json.Marshal(marshaler)
	case "external":
		var marshaler = struct {
			Type string `json:"type"`
			*ExternalSheetConstraint
		}{
			Type:                    s.Type,
			ExternalSheetConstraint: s.External,
		}
		return json.Marshal(marshaler)
	}
}

type SheetConstraintVisitor interface {
	VisitUnique(*CompositeUniqueConstraint) error
	VisitExternal(*ExternalSheetConstraint) error
}

func (s *SheetConstraint) Accept(visitor SheetConstraintVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "unique":
		return visitor.VisitUnique(s.Unique)
	case "external":
		return visitor.VisitExternal(s.External)
	}
}

// Changes to make to an existing sheet
type SheetUpdate struct {
	// The ID of the Sheet.
	Id *SheetId `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the Workbook.
	WorkbookId *WorkbookId `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	// Describes shape of data as well as behavior.
	Config *SheetConfig `json:"config,omitempty" url:"config,omitempty"`
	// The scoped namespace of the Sheet.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Date the sheet was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// Date the sheet was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SheetUpdate) UnmarshalJSON(data []byte) error {
	type embed SheetUpdate
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SheetUpdate(unmarshaler.embed)
	s.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetUpdate) MarshalJSON() ([]byte, error) {
	type embed SheetUpdate
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*s),
		UpdatedAt: core.NewOptionalDateTime(s.UpdatedAt),
		CreatedAt: core.NewOptionalDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *SheetUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Snapshot struct {
	// The ID of the Snapshot.
	Id SnapshotId `json:"id" url:"id"`
	// The ID of the Sheet.
	SheetId SheetId `json:"sheetId" url:"sheetId"`
	// The title of the Snapshot.
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A summary of the Snapshot.
	Summary *SnapshotSummary `json:"summary,omitempty" url:"summary,omitempty"`
	// The time the Snapshot was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The actor who created the Snapshot.
	CreatedBy UserId `json:"createdBy" url:"createdBy"`

	_rawJSON json.RawMessage
}

func (s *Snapshot) UnmarshalJSON(data []byte) error {
	type embed Snapshot
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Snapshot(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Snapshot) MarshalJSON() ([]byte, error) {
	type embed Snapshot
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Snapshot) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SnapshotSummary struct {
	CreatedSince *SummarySection `json:"createdSince,omitempty" url:"createdSince,omitempty"`
	UpdatedSince *SummarySection `json:"updatedSince,omitempty" url:"updatedSince,omitempty"`
	DeletedSince *SummarySection `json:"deletedSince,omitempty" url:"deletedSince,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SnapshotSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler SnapshotSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SnapshotSummary(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SnapshotSummary) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SummarySection struct {
	Total   int            `json:"total" url:"total"`
	ByField map[string]int `json:"byField,omitempty" url:"byField,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SummarySection) UnmarshalJSON(data []byte) error {
	type unmarshaler SummarySection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummarySection(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummarySection) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Properties used to allow users to connect to the event bus
type EventToken struct {
	// The ID of the Account.
	AccountId *AccountId `json:"accountId,omitempty" url:"accountId,omitempty"`
	// The id of the event bus to subscribe to
	SubscribeKey *string `json:"subscribeKey,omitempty" url:"subscribeKey,omitempty"`
	// Time to live in minutes
	Ttl *int `json:"ttl,omitempty" url:"ttl,omitempty"`
	// This should be your API key.
	Token *string `json:"token,omitempty" url:"token,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EventToken) UnmarshalJSON(data []byte) error {
	type unmarshaler EventToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventToken(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventToken) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventTokenResponse struct {
	Data *EventToken `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EventTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTokenResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTokenResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type InternalSpaceConfigBase struct {
	SpaceConfigId     *SpaceConfigId `json:"spaceConfigId,omitempty" url:"spaceConfigId,omitempty"`
	EnvironmentId     *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	PrimaryWorkbookId *WorkbookId    `json:"primaryWorkbookId,omitempty" url:"primaryWorkbookId,omitempty"`
	// Metadata for the space
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The Space settings.
	Settings         *SpaceSettings `json:"settings,omitempty" url:"settings,omitempty"`
	Actions          []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Access           []SpaceAccess  `json:"access,omitempty" url:"access,omitempty"`
	AutoConfigure    *bool          `json:"autoConfigure,omitempty" url:"autoConfigure,omitempty"`
	Namespace        *string        `json:"namespace,omitempty" url:"namespace,omitempty"`
	Labels           []string       `json:"labels,omitempty" url:"labels,omitempty"`
	TranslationsPath *string        `json:"translationsPath,omitempty" url:"translationsPath,omitempty"`
	LanguageOverride *string        `json:"languageOverride,omitempty" url:"languageOverride,omitempty"`
	// Date when space was archived
	ArchivedAt *time.Time `json:"archivedAt,omitempty" url:"archivedAt,omitempty"`
	// The ID of the App that space is associated with
	AppId *AppId `json:"appId,omitempty" url:"appId,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InternalSpaceConfigBase) UnmarshalJSON(data []byte) error {
	type embed InternalSpaceConfigBase
	var unmarshaler = struct {
		embed
		ArchivedAt *core.DateTime `json:"archivedAt,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InternalSpaceConfigBase(unmarshaler.embed)
	i.ArchivedAt = unmarshaler.ArchivedAt.TimePtr()
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InternalSpaceConfigBase) MarshalJSON() ([]byte, error) {
	type embed InternalSpaceConfigBase
	var marshaler = struct {
		embed
		ArchivedAt *core.DateTime `json:"archivedAt,omitempty"`
	}{
		embed:      embed(*i),
		ArchivedAt: core.NewOptionalDateTime(i.ArchivedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InternalSpaceConfigBase) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A place to store your workbooks
type Space struct {
	SpaceConfigId     *SpaceConfigId `json:"spaceConfigId,omitempty" url:"spaceConfigId,omitempty"`
	EnvironmentId     *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	PrimaryWorkbookId *WorkbookId    `json:"primaryWorkbookId,omitempty" url:"primaryWorkbookId,omitempty"`
	// Metadata for the space
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The Space settings.
	Settings         *SpaceSettings `json:"settings,omitempty" url:"settings,omitempty"`
	Actions          []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Access           []SpaceAccess  `json:"access,omitempty" url:"access,omitempty"`
	AutoConfigure    *bool          `json:"autoConfigure,omitempty" url:"autoConfigure,omitempty"`
	Namespace        *string        `json:"namespace,omitempty" url:"namespace,omitempty"`
	Labels           []string       `json:"labels,omitempty" url:"labels,omitempty"`
	TranslationsPath *string        `json:"translationsPath,omitempty" url:"translationsPath,omitempty"`
	LanguageOverride *string        `json:"languageOverride,omitempty" url:"languageOverride,omitempty"`
	// Date when space was archived
	ArchivedAt *time.Time `json:"archivedAt,omitempty" url:"archivedAt,omitempty"`
	// The ID of the App that space is associated with
	AppId *AppId  `json:"appId,omitempty" url:"appId,omitempty"`
	Id    SpaceId `json:"id" url:"id"`
	// Amount of workbooks in the space
	WorkbooksCount *int `json:"workbooksCount,omitempty" url:"workbooksCount,omitempty"`
	// Amount of files in the space
	FilesCount      *int    `json:"filesCount,omitempty" url:"filesCount,omitempty"`
	CreatedByUserId *UserId `json:"createdByUserId,omitempty" url:"createdByUserId,omitempty"`
	// User name who created space
	CreatedByUserName *string `json:"createdByUserName,omitempty" url:"createdByUserName,omitempty"`
	// Date when space was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date when space was updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date when space was expired
	ExpiredAt *time.Time `json:"expiredAt,omitempty" url:"expiredAt,omitempty"`
	// This date marks the most recent activity within the space, tracking actions to the second. Activities include creating or updating records in a sheet, uploading files, or modifying a workbook's configuration.
	LastActivityAt *time.Time `json:"lastActivityAt,omitempty" url:"lastActivityAt,omitempty"`
	// Guest link to the space
	GuestLink *string `json:"guestLink,omitempty" url:"guestLink,omitempty"`
	// The name of the space
	Name string `json:"name" url:"name"`
	// The display order
	DisplayOrder *int `json:"displayOrder,omitempty" url:"displayOrder,omitempty"`
	// Access token for the space
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`
	// Flag for collaborative (project) spaces
	IsCollaborative *bool `json:"isCollaborative,omitempty" url:"isCollaborative,omitempty"`
	// Size information for the space
	Size *SpaceSize `json:"size,omitempty" url:"size,omitempty"`
	// Date when the space was upgraded
	UpgradedAt *time.Time `json:"upgradedAt,omitempty" url:"upgradedAt,omitempty"`
	// Type of guest authentication
	GuestAuthentication []GuestAuthenticationEnum `json:"guestAuthentication,omitempty" url:"guestAuthentication,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Space) UnmarshalJSON(data []byte) error {
	type embed Space
	var unmarshaler = struct {
		embed
		ArchivedAt     *core.DateTime `json:"archivedAt,omitempty"`
		CreatedAt      *core.DateTime `json:"createdAt"`
		UpdatedAt      *core.DateTime `json:"updatedAt"`
		ExpiredAt      *core.DateTime `json:"expiredAt,omitempty"`
		LastActivityAt *core.DateTime `json:"lastActivityAt,omitempty"`
		UpgradedAt     *core.DateTime `json:"upgradedAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Space(unmarshaler.embed)
	s.ArchivedAt = unmarshaler.ArchivedAt.TimePtr()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	s.ExpiredAt = unmarshaler.ExpiredAt.TimePtr()
	s.LastActivityAt = unmarshaler.LastActivityAt.TimePtr()
	s.UpgradedAt = unmarshaler.UpgradedAt.TimePtr()
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Space) MarshalJSON() ([]byte, error) {
	type embed Space
	var marshaler = struct {
		embed
		ArchivedAt     *core.DateTime `json:"archivedAt,omitempty"`
		CreatedAt      *core.DateTime `json:"createdAt"`
		UpdatedAt      *core.DateTime `json:"updatedAt"`
		ExpiredAt      *core.DateTime `json:"expiredAt,omitempty"`
		LastActivityAt *core.DateTime `json:"lastActivityAt,omitempty"`
		UpgradedAt     *core.DateTime `json:"upgradedAt,omitempty"`
	}{
		embed:          embed(*s),
		ArchivedAt:     core.NewOptionalDateTime(s.ArchivedAt),
		CreatedAt:      core.NewDateTime(s.CreatedAt),
		UpdatedAt:      core.NewDateTime(s.UpdatedAt),
		ExpiredAt:      core.NewOptionalDateTime(s.ExpiredAt),
		LastActivityAt: core.NewOptionalDateTime(s.LastActivityAt),
		UpgradedAt:     core.NewOptionalDateTime(s.UpgradedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Space) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpaceAccess string

const (
	SpaceAccessAll    SpaceAccess = "*"
	SpaceAccessUpload SpaceAccess = "upload"
)

func NewSpaceAccessFromString(s string) (SpaceAccess, error) {
	switch s {
	case "*":
		return SpaceAccessAll, nil
	case "upload":
		return SpaceAccessUpload, nil
	}
	var t SpaceAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SpaceAccess) Ptr() *SpaceAccess {
	return &s
}

// Settings for a space
type SpaceSettings struct {
	// The sidebar configuration for the space. (This will eventually replace metadata.sidebarconfig)
	SidebarConfig *SpaceSidebarConfig `json:"sidebarConfig,omitempty" url:"sidebarConfig,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SpaceSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSettings(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSettings) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpaceSidebarConfig struct {
	// Used to set the order of workbooks in the sidebar. This will not affect workbooks that are pinned and workbooks that are not specified here will be sorted alphabetically.
	WorkbookSidebarOrder []WorkbookId `json:"workbookSidebarOrder,omitempty" url:"workbookSidebarOrder,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SpaceSidebarConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSidebarConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSidebarConfig(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSidebarConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The size of a space
type SpaceSize struct {
	Name     string `json:"name" url:"name"`
	Id       string `json:"id" url:"id"`
	NumUsers int    `json:"numUsers" url:"numUsers"`
	Pdv      int    `json:"pdv" url:"pdv"`
	NumFiles int    `json:"numFiles" url:"numFiles"`

	_rawJSON json.RawMessage
}

func (s *SpaceSize) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSize
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSize(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSize) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configurations for the user
type User struct {
	Email      string                 `json:"email" url:"email"`
	Name       string                 `json:"name" url:"name"`
	AccountId  AccountId              `json:"accountId" url:"accountId"`
	Id         UserId                 `json:"id" url:"id"`
	Idp        string                 `json:"idp" url:"idp"`
	IdpRef     *string                `json:"idpRef,omitempty" url:"idpRef,omitempty"`
	Metadata   map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt  time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time              `json:"updatedAt" url:"updatedAt"`
	LastSeenAt *time.Time             `json:"lastSeenAt,omitempty" url:"lastSeenAt,omitempty"`
	Dashboard  *int                   `json:"dashboard,omitempty" url:"dashboard,omitempty"`

	_rawJSON json.RawMessage
}

func (u *User) UnmarshalJSON(data []byte) error {
	type embed User
	var unmarshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = User(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()
	u.LastSeenAt = unmarshaler.LastSeenAt.TimePtr()
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed:      embed(*u),
		CreatedAt:  core.NewDateTime(u.CreatedAt),
		UpdatedAt:  core.NewDateTime(u.UpdatedAt),
		LastSeenAt: core.NewOptionalDateTime(u.LastSeenAt),
	}
	return json.Marshal(marshaler)
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserResponse struct {
	Data *User `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserWithRoles struct {
	Email      string                 `json:"email" url:"email"`
	Name       string                 `json:"name" url:"name"`
	AccountId  AccountId              `json:"accountId" url:"accountId"`
	Id         UserId                 `json:"id" url:"id"`
	Idp        string                 `json:"idp" url:"idp"`
	IdpRef     *string                `json:"idpRef,omitempty" url:"idpRef,omitempty"`
	Metadata   map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt  time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time              `json:"updatedAt" url:"updatedAt"`
	LastSeenAt *time.Time             `json:"lastSeenAt,omitempty" url:"lastSeenAt,omitempty"`
	Dashboard  *int                   `json:"dashboard,omitempty" url:"dashboard,omitempty"`
	ActorRoles []*ActorRoleResponse   `json:"actorRoles,omitempty" url:"actorRoles,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserWithRoles) UnmarshalJSON(data []byte) error {
	type embed UserWithRoles
	var unmarshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserWithRoles(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()
	u.LastSeenAt = unmarshaler.LastSeenAt.TimePtr()
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserWithRoles) MarshalJSON() ([]byte, error) {
	type embed UserWithRoles
	var marshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed:      embed(*u),
		CreatedAt:  core.NewDateTime(u.CreatedAt),
		UpdatedAt:  core.NewDateTime(u.UpdatedAt),
		LastSeenAt: core.NewOptionalDateTime(u.LastSeenAt),
	}
	return json.Marshal(marshaler)
}

func (u *UserWithRoles) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type Version struct {
	VersionId VersionId `json:"versionId" url:"versionId"`

	_rawJSON json.RawMessage
}

func (v *Version) UnmarshalJSON(data []byte) error {
	type unmarshaler Version
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = Version(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *Version) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VersionResponse struct {
	Data *Version `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VersionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VersionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VersionResponse(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VersionResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// A collection of one or more sheets
type Workbook struct {
	// ID of the Workbook.
	Id WorkbookId `json:"id" url:"id"`
	// Name of the Workbook.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Associated Space ID of the Workbook.
	SpaceId SpaceId `json:"spaceId" url:"spaceId"`
	// Associated Environment ID of the Workbook.
	EnvironmentId EnvironmentId `json:"environmentId" url:"environmentId"`
	// A list of Sheets associated with the Workbook.
	Sheets []*Sheet `json:"sheets,omitempty" url:"sheets,omitempty"`
	// A list of labels for the Workbook.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// A list of Actions associated with the Workbook.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// The Workbook settings.
	Settings *WorkbookConfigSettings `json:"settings,omitempty" url:"settings,omitempty"`
	// Metadata for the workbook
	Metadata  interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Namespace *string     `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Date the workbook was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date the workbook was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the workbook was created
	ExpiredAt *time.Time `json:"expiredAt,omitempty" url:"expiredAt,omitempty"`

	_rawJSON json.RawMessage
}

func (w *Workbook) UnmarshalJSON(data []byte) error {
	type embed Workbook
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		ExpiredAt *core.DateTime `json:"expiredAt,omitempty"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = Workbook(unmarshaler.embed)
	w.UpdatedAt = unmarshaler.UpdatedAt.Time()
	w.CreatedAt = unmarshaler.CreatedAt.Time()
	w.ExpiredAt = unmarshaler.ExpiredAt.TimePtr()
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *Workbook) MarshalJSON() ([]byte, error) {
	type embed Workbook
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		ExpiredAt *core.DateTime `json:"expiredAt,omitempty"`
	}{
		embed:     embed(*w),
		UpdatedAt: core.NewDateTime(w.UpdatedAt),
		CreatedAt: core.NewDateTime(w.CreatedAt),
		ExpiredAt: core.NewOptionalDateTime(w.ExpiredAt),
	}
	return json.Marshal(marshaler)
}

func (w *Workbook) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Settings for a workbook
type WorkbookConfigSettings struct {
	// Whether to track changes for this workbook. Defaults to false. Tracking changes on a workbook allows for disabling workbook and sheet actions while data in the workbook is still being processed. You must run a recordHook listener if you enable this feature.
	TrackChanges *bool `json:"trackChanges,omitempty" url:"trackChanges,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WorkbookConfigSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkbookConfigSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkbookConfigSettings(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkbookConfigSettings) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
