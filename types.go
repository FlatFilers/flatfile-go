// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/FlatFilers/flatfile-go/core"
	time "time"
)

// An account
type Account struct {
	Id                      AccountId              `json:"id" url:"id"`
	Name                    string                 `json:"name" url:"name"`
	Subdomain               *string                `json:"subdomain,omitempty" url:"subdomain,omitempty"`
	VanityDomainDashboard   *string                `json:"vanityDomainDashboard,omitempty" url:"vanityDomainDashboard,omitempty"`
	VanityDomainSpaces      *string                `json:"vanityDomainSpaces,omitempty" url:"vanityDomainSpaces,omitempty"`
	EmbeddedDomainWhitelist []string               `json:"embeddedDomainWhitelist,omitempty" url:"embeddedDomainWhitelist,omitempty"`
	CustomFromEmail         *string                `json:"customFromEmail,omitempty" url:"customFromEmail,omitempty"`
	StripeCustomerId        *string                `json:"stripeCustomerId,omitempty" url:"stripeCustomerId,omitempty"`
	Metadata                map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt               time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt               time.Time              `json:"updatedAt" url:"updatedAt"`
	DefaultAppId            *AppId                 `json:"defaultAppId,omitempty" url:"defaultAppId,omitempty"`
	Dashboard               *int                   `json:"dashboard,omitempty" url:"dashboard,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type embed Account
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Account(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Account) MarshalJSON() ([]byte, error) {
	type embed Account
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Account) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Agent struct {
	// The topics the agent should listen for
	Topics []EventTopic `json:"topics,omitempty" url:"topics,omitempty"`
	// The compiler of the agent
	Compiler *Compiler `json:"compiler,omitempty" url:"compiler,omitempty"`
	// The source of the agent
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The source map of the agent
	SourceMap *string `json:"sourceMap,omitempty" url:"sourceMap,omitempty"`
	// The slug of the agent
	Slug          *string       `json:"slug,omitempty" url:"slug,omitempty"`
	Id            AgentId       `json:"id" url:"id"`
	CreatedAt     time.Time     `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time     `json:"updatedAt" url:"updatedAt"`
	AccountId     AccountId     `json:"accountId" url:"accountId"`
	EnvironmentId EnvironmentId `json:"environmentId" url:"environmentId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Agent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Agent) UnmarshalJSON(data []byte) error {
	type embed Agent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Agent(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Agent) MarshalJSON() ([]byte, error) {
	type embed Agent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Agent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Properties used to create a new agent
type AgentConfig struct {
	// The topics the agent should listen for
	Topics []EventTopic `json:"topics,omitempty" url:"topics,omitempty"`
	// The compiler of the agent
	Compiler *Compiler `json:"compiler,omitempty" url:"compiler,omitempty"`
	// The source of the agent
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The source map of the agent
	SourceMap *string `json:"sourceMap,omitempty" url:"sourceMap,omitempty"`
	// The slug of the agent
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AgentConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A log of an agent execution
type AgentLog struct {
	EventId EventId `json:"eventId" url:"eventId"`
	// Whether the agent execution was successful
	Success     bool   `json:"success" url:"success"`
	CreatedAt   string `json:"createdAt" url:"createdAt"`
	CompletedAt string `json:"completedAt" url:"completedAt"`
	// The log of the agent execution
	Log *string `json:"log,omitempty" url:"log,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AgentLog) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentLog) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentLog(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentLog) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AgentResponse struct {
	Data *Agent `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AgentResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AgentVersion struct {
	// The topics the agent should listen for
	Topics []EventTopic `json:"topics,omitempty" url:"topics,omitempty"`
	// The compiler of the agent
	Compiler *Compiler `json:"compiler,omitempty" url:"compiler,omitempty"`
	// The source of the agent
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The source map of the agent
	SourceMap *string `json:"sourceMap,omitempty" url:"sourceMap,omitempty"`
	// The slug of the agent
	Slug      *string        `json:"slug,omitempty" url:"slug,omitempty"`
	Id        AgentVersionId `json:"id" url:"id"`
	Version   int            `json:"version" url:"version"`
	Origin    int            `json:"origin" url:"origin"`
	CreatedAt time.Time      `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time      `json:"updatedAt" url:"updatedAt"`
	AgentId   AgentId        `json:"agent_id" url:"agent_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AgentVersion) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentVersion) UnmarshalJSON(data []byte) error {
	type embed AgentVersion
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AgentVersion(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentVersion) MarshalJSON() ([]byte, error) {
	type embed AgentVersion
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *AgentVersion) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The compiler of the agent
type Compiler string

const (
	CompilerJs Compiler = "js"
)

func NewCompilerFromString(s string) (Compiler, error) {
	switch s {
	case "js":
		return CompilerJs, nil
	}
	var t Compiler
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Compiler) Ptr() *Compiler {
	return &c
}

// A log of an agent execution
type DetailedAgentLog struct {
	EventId EventId `json:"eventId" url:"eventId"`
	// Whether the agent execution was successful
	Success     bool      `json:"success" url:"success"`
	CreatedAt   time.Time `json:"createdAt" url:"createdAt"`
	CompletedAt time.Time `json:"completedAt" url:"completedAt"`
	// The duration of the agent execution
	Duration int `json:"duration" url:"duration"`
	// The topics of the agent execution
	Topic string `json:"topic" url:"topic"`
	// The context of the agent execution
	Context map[string]interface{} `json:"context,omitempty" url:"context,omitempty"`
	// The log of the agent execution
	Log *string `json:"log,omitempty" url:"log,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DetailedAgentLog) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DetailedAgentLog) UnmarshalJSON(data []byte) error {
	type embed DetailedAgentLog
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DetailedAgentLog(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.CompletedAt = unmarshaler.CompletedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetailedAgentLog) MarshalJSON() ([]byte, error) {
	type embed DetailedAgentLog
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt"`
	}{
		embed:       embed(*d),
		CreatedAt:   core.NewDateTime(d.CreatedAt),
		CompletedAt: core.NewDateTime(d.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DetailedAgentLog) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// An execution of an agent
type Execution struct {
	EventId EventId `json:"eventId" url:"eventId"`
	// Whether the agent execution was successful
	Success     bool      `json:"success" url:"success"`
	CreatedAt   time.Time `json:"createdAt" url:"createdAt"`
	CompletedAt time.Time `json:"completedAt" url:"completedAt"`
	// The duration of the agent execution
	Duration int `json:"duration" url:"duration"`
	// The topics of the agent execution
	Topic string `json:"topic" url:"topic"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Execution) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Execution) UnmarshalJSON(data []byte) error {
	type embed Execution
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Execution(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.CompletedAt = unmarshaler.CompletedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Execution) MarshalJSON() ([]byte, error) {
	type embed Execution
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt"`
	}{
		embed:       embed(*e),
		CreatedAt:   core.NewDateTime(e.CreatedAt),
		CompletedAt: core.NewDateTime(e.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (e *Execution) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type GetAgentLogsResponse struct {
	Pagination *Pagination `json:"pagination,omitempty" url:"pagination,omitempty"`
	Data       []*AgentLog `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetAgentLogsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetAgentLogsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetAgentLogsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetAgentLogsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetAgentLogsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListAgentsResponse struct {
	Data []*Agent `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListAgentsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListAgentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListAgentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListAgentsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListAgentsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// An app
type App struct {
	Id                 AppId       `json:"id" url:"id"`
	Name               string      `json:"name" url:"name"`
	Namespace          string      `json:"namespace" url:"namespace"`
	Type               AppType     `json:"type" url:"type"`
	Entity             string      `json:"entity" url:"entity"`
	EntityPlural       string      `json:"entityPlural" url:"entityPlural"`
	Icon               *string     `json:"icon,omitempty" url:"icon,omitempty"`
	Metadata           interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	EnvironmentFilters interface{} `json:"environmentFilters,omitempty" url:"environmentFilters,omitempty"`
	Blueprint          interface{} `json:"blueprint,omitempty" url:"blueprint,omitempty"`
	CreatedAt          time.Time   `json:"createdAt" url:"createdAt"`
	UpdatedAt          time.Time   `json:"updatedAt" url:"updatedAt"`
	DeletedAt          *time.Time  `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`
	ActivatedAt        *time.Time  `json:"activatedAt,omitempty" url:"activatedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *App) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *App) UnmarshalJSON(data []byte) error {
	type embed App
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		UpdatedAt   *core.DateTime `json:"updatedAt"`
		DeletedAt   *core.DateTime `json:"deletedAt,omitempty"`
		ActivatedAt *core.DateTime `json:"activatedAt,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = App(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	a.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	a.ActivatedAt = unmarshaler.ActivatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *App) MarshalJSON() ([]byte, error) {
	type embed App
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		UpdatedAt   *core.DateTime `json:"updatedAt"`
		DeletedAt   *core.DateTime `json:"deletedAt,omitempty"`
		ActivatedAt *core.DateTime `json:"activatedAt,omitempty"`
	}{
		embed:       embed(*a),
		CreatedAt:   core.NewDateTime(a.CreatedAt),
		UpdatedAt:   core.NewDateTime(a.UpdatedAt),
		DeletedAt:   core.NewOptionalDateTime(a.DeletedAt),
		ActivatedAt: core.NewOptionalDateTime(a.ActivatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *App) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppType string

const (
	AppTypePortal    AppType = "PORTAL"
	AppTypeProjects  AppType = "PROJECTS"
	AppTypeMapping   AppType = "MAPPING"
	AppTypeWorkbooks AppType = "WORKBOOKS"
	AppTypeCustom    AppType = "CUSTOM"
)

func NewAppTypeFromString(s string) (AppType, error) {
	switch s {
	case "PORTAL":
		return AppTypePortal, nil
	case "PROJECTS":
		return AppTypeProjects, nil
	case "MAPPING":
		return AppTypeMapping, nil
	case "WORKBOOKS":
		return AppTypeWorkbooks, nil
	case "CUSTOM":
		return AppTypeCustom, nil
	}
	var t AppType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppType) Ptr() *AppType {
	return &a
}

type ConstraintResource struct {
	Id          ConstraintId `json:"id" url:"id"`
	AppId       AppId        `json:"appId" url:"appId"`
	Validator   string       `json:"validator" url:"validator"`
	Description *string      `json:"description,omitempty" url:"description,omitempty"`
	Function    *string      `json:"function,omitempty" url:"function,omitempty"`
	Options     interface{}  `json:"options,omitempty" url:"options,omitempty"`
	Label       *string      `json:"label,omitempty" url:"label,omitempty"`
	CreatedAt   time.Time    `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time    `json:"updatedAt" url:"updatedAt"`
	DeletedAt   *time.Time   `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConstraintResource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConstraintResource) UnmarshalJSON(data []byte) error {
	type embed ConstraintResource
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConstraintResource(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.DeletedAt = unmarshaler.DeletedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConstraintResource) MarshalJSON() ([]byte, error) {
	type embed ConstraintResource
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		DeletedAt: core.NewOptionalDateTime(c.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ConstraintResource) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConstraintVersionResource struct {
	Id          ConstraintId `json:"id" url:"id"`
	AppId       AppId        `json:"appId" url:"appId"`
	Validator   string       `json:"validator" url:"validator"`
	Description *string      `json:"description,omitempty" url:"description,omitempty"`
	Function    *string      `json:"function,omitempty" url:"function,omitempty"`
	Options     interface{}  `json:"options,omitempty" url:"options,omitempty"`
	Label       *string      `json:"label,omitempty" url:"label,omitempty"`
	CreatedAt   time.Time    `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time    `json:"updatedAt" url:"updatedAt"`
	DeletedAt   *time.Time   `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`
	Version     int          `json:"version" url:"version"`
	Prompt      *string      `json:"prompt,omitempty" url:"prompt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConstraintVersionResource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConstraintVersionResource) UnmarshalJSON(data []byte) error {
	type embed ConstraintVersionResource
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConstraintVersionResource(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.DeletedAt = unmarshaler.DeletedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConstraintVersionResource) MarshalJSON() ([]byte, error) {
	type embed ConstraintVersionResource
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		DeletedAt: core.NewOptionalDateTime(c.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ConstraintVersionResource) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Prompt struct {
	Id PromptId `json:"id" url:"id"`
	// ID of the user/guest who created the prompt
	CreatedById   string         `json:"createdById" url:"createdById"`
	AccountId     AccountId      `json:"accountId" url:"accountId"`
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	SpaceId       *SpaceId       `json:"spaceId,omitempty" url:"spaceId,omitempty"`
	// Type of prompt
	PromptType PromptTypeEnum `json:"promptType" url:"promptType"`
	// Text for prompts for AI Assist
	Prompt    string     `json:"prompt" url:"prompt"`
	CreatedAt time.Time  `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time  `json:"updatedAt" url:"updatedAt"`
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Prompt) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Prompt) UnmarshalJSON(data []byte) error {
	type embed Prompt
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Prompt(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	p.DeletedAt = unmarshaler.DeletedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Prompt) MarshalJSON() ([]byte, error) {
	type embed Prompt
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed:     embed(*p),
		CreatedAt: core.NewDateTime(p.CreatedAt),
		UpdatedAt: core.NewDateTime(p.UpdatedAt),
		DeletedAt: core.NewOptionalDateTime(p.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (p *Prompt) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PromptTypeEnum string

const (
	PromptTypeEnumAiAssist             PromptTypeEnum = "AI_ASSIST"
	PromptTypeEnumConstraintGeneration PromptTypeEnum = "CONSTRAINT_GENERATION"
)

func NewPromptTypeEnumFromString(s string) (PromptTypeEnum, error) {
	switch s {
	case "AI_ASSIST":
		return PromptTypeEnumAiAssist, nil
	case "CONSTRAINT_GENERATION":
		return PromptTypeEnumConstraintGeneration, nil
	}
	var t PromptTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PromptTypeEnum) Ptr() *PromptTypeEnum {
	return &p
}

// A commit version
type Commit struct {
	Id      CommitId `json:"id" url:"id"`
	SheetId SheetId  `json:"sheetId" url:"sheetId"`
	// The actor (user or system) who created the commit
	CreatedBy string `json:"createdBy" url:"createdBy"`
	// The actor (user or system) who completed the commit
	CompletedBy *string `json:"completedBy,omitempty" url:"completedBy,omitempty"`
	// The time the commit was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The time the commit was acknowledged
	CompletedAt *time.Time `json:"completedAt,omitempty" url:"completedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Commit) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Commit) UnmarshalJSON(data []byte) error {
	type embed Commit
	var unmarshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Commit(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.CompletedAt = unmarshaler.CompletedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Commit) MarshalJSON() ([]byte, error) {
	type embed Commit
	var marshaler = struct {
		embed
		CreatedAt   *core.DateTime `json:"createdAt"`
		CompletedAt *core.DateTime `json:"completedAt,omitempty"`
	}{
		embed:       embed(*c),
		CreatedAt:   core.NewDateTime(c.CreatedAt),
		CompletedAt: core.NewOptionalDateTime(c.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Commit) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ListCommitsResponse struct {
	Data []*Commit `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCommitsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCommitsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCommitsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCommitsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCommitsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ApiAction struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`
	// The text on the Button itself
	Label     string    `json:"label" url:"label"`
	Id        ActionId  `json:"id" url:"id"`
	TargetId  string    `json:"targetId" url:"targetId"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiAction) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiAction) UnmarshalJSON(data []byte) error {
	type embed ApiAction
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApiAction(unmarshaler.embed)
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	a.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiAction) MarshalJSON() ([]byte, error) {
	type embed ApiAction
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*a),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
		CreatedAt: core.NewDateTime(a.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ApiAction) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Account ID
type AccountId = string

type Action struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`
	// The text on the Button itself
	Label string `json:"label" url:"label"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Action) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Action) UnmarshalJSON(data []byte) error {
	type unmarshaler Action
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Action(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Action) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionConstraint struct {
	Type         string
	HasAllValid  *ActionConstraintHasAllValid
	HasSelection *ActionConstraintHasSelection
	HasData      *ActionConstraintHasData
}

func NewActionConstraintFromHasAllValid(value *ActionConstraintHasAllValid) *ActionConstraint {
	return &ActionConstraint{Type: "hasAllValid", HasAllValid: value}
}

func NewActionConstraintFromHasSelection(value *ActionConstraintHasSelection) *ActionConstraint {
	return &ActionConstraint{Type: "hasSelection", HasSelection: value}
}

func NewActionConstraintFromHasData(value *ActionConstraintHasData) *ActionConstraint {
	return &ActionConstraint{Type: "hasData", HasData: value}
}

func (a *ActionConstraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "hasAllValid":
		value := new(ActionConstraintHasAllValid)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasAllValid = value
	case "hasSelection":
		value := new(ActionConstraintHasSelection)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasSelection = value
	case "hasData":
		value := new(ActionConstraintHasData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.HasData = value
	}
	return nil
}

func (a ActionConstraint) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "hasAllValid":
		return core.MarshalJSONWithExtraProperty(a.HasAllValid, "type", "hasAllValid")
	case "hasSelection":
		return core.MarshalJSONWithExtraProperty(a.HasSelection, "type", "hasSelection")
	case "hasData":
		return core.MarshalJSONWithExtraProperty(a.HasData, "type", "hasData")
	}
}

type ActionConstraintVisitor interface {
	VisitHasAllValid(*ActionConstraintHasAllValid) error
	VisitHasSelection(*ActionConstraintHasSelection) error
	VisitHasData(*ActionConstraintHasData) error
}

func (a *ActionConstraint) Accept(visitor ActionConstraintVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "hasAllValid":
		return visitor.VisitHasAllValid(a.HasAllValid)
	case "hasSelection":
		return visitor.VisitHasSelection(a.HasSelection)
	case "hasData":
		return visitor.VisitHasData(a.HasData)
	}
}

// This constraint requires that all records are valid before the action can be performed.
type ActionConstraintHasAllValid struct {
	IgnoreSelection *bool `json:"ignoreSelection,omitempty" url:"ignoreSelection,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionConstraintHasAllValid) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasAllValid) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasAllValid
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasAllValid(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasAllValid) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This constraint requires that at least one record exists before the action can be performed.
type ActionConstraintHasData struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionConstraintHasData) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasData) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasData) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This constraint requires that at least one record is selected before the action can be performed.
type ActionConstraintHasSelection struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionConstraintHasSelection) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionConstraintHasSelection) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionConstraintHasSelection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionConstraintHasSelection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionConstraintHasSelection) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Action ID
type ActionId = string

type ActionMessage struct {
	Type    ActionMessageType `json:"type" url:"type"`
	Content string            `json:"content" url:"content"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMessage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMessage) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionMessageType string

const (
	ActionMessageTypeError ActionMessageType = "error"
	ActionMessageTypeInfo  ActionMessageType = "info"
)

func NewActionMessageTypeFromString(s string) (ActionMessageType, error) {
	switch s {
	case "error":
		return ActionMessageTypeError, nil
	case "info":
		return ActionMessageTypeInfo, nil
	}
	var t ActionMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionMessageType) Ptr() *ActionMessageType {
	return &a
}

// Foreground actions will prevent interacting with the resource until complete
type ActionMode string

const (
	ActionModeForeground      ActionMode = "foreground"
	ActionModeBackground      ActionMode = "background"
	ActionModeToolbarBlocking ActionMode = "toolbarBlocking"
)

func NewActionModeFromString(s string) (ActionMode, error) {
	switch s {
	case "foreground":
		return ActionModeForeground, nil
	case "background":
		return ActionModeBackground, nil
	case "toolbarBlocking":
		return ActionModeToolbarBlocking, nil
	}
	var t ActionMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionMode) Ptr() *ActionMode {
	return &a
}

type ActionMount struct {
	Type     string
	Sheet    *ActionMountSheet
	Workbook *ActionMountWorkbook
	Field    *ActionMountField
	Document *ActionMountDocument
	File     *ActionMountFile
}

func NewActionMountFromSheet(value *ActionMountSheet) *ActionMount {
	return &ActionMount{Type: "sheet", Sheet: value}
}

func NewActionMountFromWorkbook(value *ActionMountWorkbook) *ActionMount {
	return &ActionMount{Type: "workbook", Workbook: value}
}

func NewActionMountFromField(value *ActionMountField) *ActionMount {
	return &ActionMount{Type: "field", Field: value}
}

func NewActionMountFromDocument(value *ActionMountDocument) *ActionMount {
	return &ActionMount{Type: "document", Document: value}
}

func NewActionMountFromFile(value *ActionMountFile) *ActionMount {
	return &ActionMount{Type: "file", File: value}
}

func (a *ActionMount) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "sheet":
		value := new(ActionMountSheet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Sheet = value
	case "workbook":
		value := new(ActionMountWorkbook)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Workbook = value
	case "field":
		value := new(ActionMountField)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Field = value
	case "document":
		value := new(ActionMountDocument)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Document = value
	case "file":
		value := new(ActionMountFile)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.File = value
	}
	return nil
}

func (a ActionMount) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "sheet":
		return core.MarshalJSONWithExtraProperty(a.Sheet, "type", "sheet")
	case "workbook":
		return core.MarshalJSONWithExtraProperty(a.Workbook, "type", "workbook")
	case "field":
		return core.MarshalJSONWithExtraProperty(a.Field, "type", "field")
	case "document":
		return core.MarshalJSONWithExtraProperty(a.Document, "type", "document")
	case "file":
		return core.MarshalJSONWithExtraProperty(a.File, "type", "file")
	}
}

type ActionMountVisitor interface {
	VisitSheet(*ActionMountSheet) error
	VisitWorkbook(*ActionMountWorkbook) error
	VisitField(*ActionMountField) error
	VisitDocument(*ActionMountDocument) error
	VisitFile(*ActionMountFile) error
}

func (a *ActionMount) Accept(visitor ActionMountVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "sheet":
		return visitor.VisitSheet(a.Sheet)
	case "workbook":
		return visitor.VisitWorkbook(a.Workbook)
	case "field":
		return visitor.VisitField(a.Field)
	case "document":
		return visitor.VisitDocument(a.Document)
	case "file":
		return visitor.VisitFile(a.File)
	}
}

// Used to mount this action on documents.
type ActionMountDocument struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountDocument) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountDocument(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountDocument) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Sheet Columns.
type ActionMountField struct {
	Keys []string `json:"keys,omitempty" url:"keys,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountField) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountField) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountField) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on files.
type ActionMountFile struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountFile) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountFile) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountFile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountFile) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Sheets.
type ActionMountSheet struct {
	Slugs []string `json:"slugs,omitempty" url:"slugs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountSheet) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountSheet) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountSheet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountSheet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountSheet) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Used to mount this action on Workbooks.
type ActionMountWorkbook struct {
	Slugs []string `json:"slugs,omitempty" url:"slugs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionMountWorkbook) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionMountWorkbook) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionMountWorkbook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionMountWorkbook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionMountWorkbook) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionSchedule string

const (
	ActionScheduleWeekly ActionSchedule = "weekly"
	ActionScheduleDaily  ActionSchedule = "daily"
	ActionScheduleHourly ActionSchedule = "hourly"
)

func NewActionScheduleFromString(s string) (ActionSchedule, error) {
	switch s {
	case "weekly":
		return ActionScheduleWeekly, nil
	case "daily":
		return ActionScheduleDaily, nil
	case "hourly":
		return ActionScheduleHourly, nil
	}
	var t ActionSchedule
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionSchedule) Ptr() *ActionSchedule {
	return &a
}

type ActionUpdate struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`
	Label       *string             `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionUpdate) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionUpdate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionUpdate) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionWithoutLabel struct {
	// **This is deprecated. Use `operation` instead.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// This will become the job operation that is triggered
	Operation *string `json:"operation,omitempty" url:"operation,omitempty"`
	// Foreground and toolbarBlocking action mode will prevent interacting with the resource until complete
	Mode *ActionMode `json:"mode,omitempty" url:"mode,omitempty"`
	// A tooltip that appears when hovering the action button
	Tooltip  *string          `json:"tooltip,omitempty" url:"tooltip,omitempty"`
	Messages []*ActionMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// **This is deprecated.**
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The text that appears in the dialog after the action is clicked.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Determines if the action should happen on a regular cadence.
	Schedule *ActionSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// A primary action will be more visibly present, whether in Sheet or Workbook.
	Primary *bool `json:"primary,omitempty" url:"primary,omitempty"`
	// Whether to show a modal to confirm the action
	Confirm *bool `json:"confirm,omitempty" url:"confirm,omitempty"`
	// Icon will work on primary actions. It will only accept an already existing Flatfile design system icon.
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireAllValid *bool `json:"requireAllValid,omitempty" url:"requireAllValid,omitempty"`
	// **This is deprecated. Use `constraints` instead.**
	RequireSelection *bool `json:"requireSelection,omitempty" url:"requireSelection,omitempty"`
	// Adds an input form for this action after it is clicked.
	InputForm *InputForm `json:"inputForm,omitempty" url:"inputForm,omitempty"`
	// A limitation or restriction on the action.
	Constraints []*ActionConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	Mount       *ActionMount        `json:"mount,omitempty" url:"mount,omitempty"`
	Guide       *Guide              `json:"guide,omitempty" url:"guide,omitempty"`
	Guardrail   *Guardrail          `json:"guardrail,omitempty" url:"guardrail,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActionWithoutLabel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionWithoutLabel) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionWithoutLabel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionWithoutLabel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionWithoutLabel) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Actor Role ID
type ActorRoleId = string

// Agent ID
type AgentId = string

// Agent version ID
type AgentVersionId = string

// App ID
type AppId = string

// Commit ID
type CommitId = string

// Constraint ID
type ConstraintId = string

// Environment ID
type EnvironmentId = string

type Error struct {
	Key     *string `json:"key,omitempty" url:"key,omitempty"`
	Message string  `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Errors struct {
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Errors) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Errors) UnmarshalJSON(data []byte) error {
	type unmarshaler Errors
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Errors(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Errors) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Event ID
type EventId = string

// File ID
type FileId = string

// Options to filter records
type Filter string

const (
	FilterValid Filter = "valid"
	FilterError Filter = "error"
	FilterAll   Filter = "all"
	FilterNone  Filter = "none"
)

func NewFilterFromString(s string) (Filter, error) {
	switch s {
	case "valid":
		return FilterValid, nil
	case "error":
		return FilterError, nil
	case "all":
		return FilterAll, nil
	case "none":
		return FilterNone, nil
	}
	var t Filter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f Filter) Ptr() *Filter {
	return &f
}

// Use this to narrow the valid/error filter results to a specific field
type FilterField = string

type Guardrail struct {
	// Markdown guardrail for this action
	Content string `json:"content" url:"content"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Guardrail) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Guardrail) UnmarshalJSON(data []byte) error {
	type unmarshaler Guardrail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Guardrail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Guardrail) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Guide struct {
	// Markdown guidance for this action
	Content string `json:"content" url:"content"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Guide) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Guide) UnmarshalJSON(data []byte) error {
	type unmarshaler Guide
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Guide(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Guide) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type InputConfig struct {
	Options []*InputEnumPropertyOption `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputConfig) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler InputConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputConfig) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputConstraint struct {
	Type InputConstraintType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputConstraint) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler InputConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputConstraint) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputConstraintType string

const (
	InputConstraintTypeRequired InputConstraintType = "required"
)

func NewInputConstraintTypeFromString(s string) (InputConstraintType, error) {
	switch s {
	case "required":
		return InputConstraintTypeRequired, nil
	}
	var t InputConstraintType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InputConstraintType) Ptr() *InputConstraintType {
	return &i
}

type InputEnumPropertyOption struct {
	// A visual label for this option, defaults to value if not provided
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// An optional color to assign this option
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// A reference pointer to a previously registered icon
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// An arbitrary JSON object to be associated with this option and made available to hooks
	Meta map[string]interface{} `json:"meta,omitempty" url:"meta,omitempty"`
	// The value or ID of this option. This value will be sent in egress. The type is a string | integer | boolean.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputEnumPropertyOption) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputEnumPropertyOption) UnmarshalJSON(data []byte) error {
	type unmarshaler InputEnumPropertyOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputEnumPropertyOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputEnumPropertyOption) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputField struct {
	// Unique key for a Field.
	Key string `json:"key" url:"key"`
	// Visible name of a Field.
	Label string `json:"label" url:"label"`
	// Brief description below the name of the Field.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Field Types inform the user interface how to sort and display data.
	Type string `json:"type" url:"type"`
	// Default value for a Field.
	DefaultValue interface{} `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	// Additional configuration for enum Fields.
	Config *InputConfig `json:"config,omitempty" url:"config,omitempty"`
	// Indicate additional validations that will be applied to the Field.
	Constraints []*InputConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputField) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputField) UnmarshalJSON(data []byte) error {
	type unmarshaler InputField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputField) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputForm struct {
	Type   InputFormType `json:"type" url:"type"`
	Fields []*InputField `json:"fields,omitempty" url:"fields,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InputForm) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InputForm) UnmarshalJSON(data []byte) error {
	type unmarshaler InputForm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InputForm(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InputForm) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InputFormType string

const (
	InputFormTypeSimple InputFormType = "simple"
)

func NewInputFormTypeFromString(s string) (InputFormType, error) {
	switch s {
	case "simple":
		return InputFormTypeSimple, nil
	}
	var t InputFormType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InputFormType) Ptr() *InputFormType {
	return &i
}

// A JSONPath string - https://www.rfc-editor.org/rfc/rfc9535
type JsonPathString = string

// Based on pageSize, which page of records to return
type PageNumber = int

// Number of logs to return in a page (default 20)
type PageSize = int

// pagination info
type Pagination struct {
	// current page of results
	CurrentPage int `json:"currentPage" url:"currentPage"`
	// total number of pages of results
	PageCount int `json:"pageCount" url:"pageCount"`
	// total available results
	TotalCount int `json:"totalCount" url:"totalCount"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Pagination) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Pagination) UnmarshalJSON(data []byte) error {
	type unmarshaler Pagination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pagination(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Pagination) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Prompt ID
type PromptId = string

// Record ID
type RecordId = string

// Role ID
type RoleId = string

// Use this to narrow the searchValue results to a specific field
type SearchField = string

// Search for the given value, returning matching rows. For exact matches, wrap the value in double quotes ("Bob"). To search for null values, send empty double quotes ("")
type SearchValue = string

// Sheet ID
type SheetId = string

// Sort direction - asc (ascending) or desc (descending)
type SortDirection string

const (
	SortDirectionAsc  SortDirection = "asc"
	SortDirectionDesc SortDirection = "desc"
)

func NewSortDirectionFromString(s string) (SortDirection, error) {
	switch s {
	case "asc":
		return SortDirectionAsc, nil
	case "desc":
		return SortDirectionDesc, nil
	}
	var t SortDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortDirection) Ptr() *SortDirection {
	return &s
}

// Name of field by which to sort records
type SortField = string

// Space Config ID
type SpaceConfigId = string

// Space ID
type SpaceId = string

// Informs whether or not a request was successful
type Success struct {
	Data *SuccessData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Success) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Success) UnmarshalJSON(data []byte) error {
	type unmarshaler Success
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Success(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Success) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SuccessData struct {
	Success bool `json:"success" url:"success"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SuccessData) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessData) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessData) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Boolean
type SuccessQueryParameter = bool

// User ID
type UserId = string

// Version ID
type VersionId = string

// Workbook ID
type WorkbookId = string

// Conflict resolutions for a record
type Resolve struct {
	Field     *string      `json:"field,omitempty" url:"field,omitempty"`
	Type      *ResolveType `json:"type,omitempty" url:"type,omitempty"`
	ResolveTo *ResolveTo   `json:"resolveTo,omitempty" url:"resolveTo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Resolve) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Resolve) UnmarshalJSON(data []byte) error {
	type unmarshaler Resolve
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resolve(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Resolve) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResolveTo string

const (
	ResolveToClip     ResolveTo = "clip"
	ResolveToMain     ResolveTo = "main"
	ResolveToSnapshot ResolveTo = "snapshot"
)

func NewResolveToFromString(s string) (ResolveTo, error) {
	switch s {
	case "clip":
		return ResolveToClip, nil
	case "main":
		return ResolveToMain, nil
	case "snapshot":
		return ResolveToSnapshot, nil
	}
	var t ResolveTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResolveTo) Ptr() *ResolveTo {
	return &r
}

type ResolveType string

const (
	ResolveTypeConflict ResolveType = "conflict"
	ResolveTypeResolve  ResolveType = "resolve"
)

func NewResolveTypeFromString(s string) (ResolveType, error) {
	switch s {
	case "conflict":
		return ResolveTypeConflict, nil
	case "resolve":
		return ResolveTypeResolve, nil
	}
	var t ResolveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResolveType) Ptr() *ResolveType {
	return &r
}

// A data retention policy belonging to an environment
type DataRetentionPolicy struct {
	Type          DataRetentionPolicyEnum `json:"type" url:"type"`
	Period        int                     `json:"period" url:"period"`
	EnvironmentId EnvironmentId           `json:"environmentId" url:"environmentId"`
	Id            DataRetentionPolicyId   `json:"id" url:"id"`
	// Date the policy was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the policy was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DataRetentionPolicy) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DataRetentionPolicy) UnmarshalJSON(data []byte) error {
	type embed DataRetentionPolicy
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DataRetentionPolicy(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataRetentionPolicy) MarshalJSON() ([]byte, error) {
	type embed DataRetentionPolicy
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DataRetentionPolicy) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The type of data retention policy on an environment
type DataRetentionPolicyEnum string

const (
	DataRetentionPolicyEnumLastActivity DataRetentionPolicyEnum = "lastActivity"
	DataRetentionPolicyEnumSinceCreated DataRetentionPolicyEnum = "sinceCreated"
)

func NewDataRetentionPolicyEnumFromString(s string) (DataRetentionPolicyEnum, error) {
	switch s {
	case "lastActivity":
		return DataRetentionPolicyEnumLastActivity, nil
	case "sinceCreated":
		return DataRetentionPolicyEnumSinceCreated, nil
	}
	var t DataRetentionPolicyEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DataRetentionPolicyEnum) Ptr() *DataRetentionPolicyEnum {
	return &d
}

// A document (markdown components) belong to a space
type Document struct {
	Title string `json:"title" url:"title"`
	Body  string `json:"body" url:"body"`
	// Certain treatments will cause your Document to look or behave differently.
	Treatments    []string       `json:"treatments,omitempty" url:"treatments,omitempty"`
	Actions       []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Id            DocumentId     `json:"id" url:"id"`
	SpaceId       *SpaceId       `json:"spaceId,omitempty" url:"spaceId,omitempty"`
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// Date the document was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the document was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Document) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Document) UnmarshalJSON(data []byte) error {
	type embed Document
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Document(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Document) MarshalJSON() ([]byte, error) {
	type embed Document
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *Document) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// An entitlement belonging to a resource
type Entitlement struct {
	// Short name for the entitlement
	Key string `json:"key" url:"key"`
	// Contains conditions or limits for an entitlement
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Entitlement) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Entitlement) UnmarshalJSON(data []byte) error {
	type unmarshaler Entitlement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Entitlement(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Entitlement) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The type of authentication to use for guests
type GuestAuthenticationEnum string

const (
	GuestAuthenticationEnumSharedLink GuestAuthenticationEnum = "shared_link"
	GuestAuthenticationEnumMagicLink  GuestAuthenticationEnum = "magic_link"
)

func NewGuestAuthenticationEnumFromString(s string) (GuestAuthenticationEnum, error) {
	switch s {
	case "shared_link":
		return GuestAuthenticationEnumSharedLink, nil
	case "magic_link":
		return GuestAuthenticationEnumMagicLink, nil
	}
	var t GuestAuthenticationEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GuestAuthenticationEnum) Ptr() *GuestAuthenticationEnum {
	return &g
}

// Name of an action
type ActionName = string

type BaseEvent struct {
	// The domain of the event
	Domain Domain `json:"domain" url:"domain"`
	// The context of the event
	Context *Context `json:"context,omitempty" url:"context,omitempty"`
	// The attributes of the event
	Attributes *EventAttributes `json:"attributes,omitempty" url:"attributes,omitempty"`
	// The callback url to acknowledge the event
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// The url to retrieve the data associated with the event
	DataUrl    *string  `json:"dataUrl,omitempty" url:"dataUrl,omitempty"`
	Target     *string  `json:"target,omitempty" url:"target,omitempty"`
	Origin     *Origin  `json:"origin,omitempty" url:"origin,omitempty"`
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BaseEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseEvent) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The context of the event
type Context struct {
	// The namespaces of the event
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`
	// The slugs of related resources
	Slugs         *EventContextSlugs `json:"slugs,omitempty" url:"slugs,omitempty"`
	ActionName    *ActionName        `json:"actionName,omitempty" url:"actionName,omitempty"`
	AccountId     AccountId          `json:"accountId" url:"accountId"`
	EnvironmentId EnvironmentId      `json:"environmentId" url:"environmentId"`
	SpaceId       *SpaceId           `json:"spaceId,omitempty" url:"spaceId,omitempty"`
	WorkbookId    *WorkbookId        `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	SheetId       *SheetId           `json:"sheetId,omitempty" url:"sheetId,omitempty"`
	SheetSlug     *SheetSlug         `json:"sheetSlug,omitempty" url:"sheetSlug,omitempty"`
	SnapshotId    *SnapshotId        `json:"snapshotId,omitempty" url:"snapshotId,omitempty"`
	// Deprecated, use `commitId` instead.
	VersionId        *VersionId  `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId         *CommitId   `json:"commitId,omitempty" url:"commitId,omitempty"`
	JobId            *JobId      `json:"jobId,omitempty" url:"jobId,omitempty"`
	ProgramId        *ProgramId  `json:"programId,omitempty" url:"programId,omitempty"`
	FileId           *FileId     `json:"fileId,omitempty" url:"fileId,omitempty"`
	DocumentId       *DocumentId `json:"documentId,omitempty" url:"documentId,omitempty"`
	PrecedingEventId *EventId    `json:"precedingEventId,omitempty" url:"precedingEventId,omitempty"`
	// Can be a UserId, GuestId, or AgentId
	ActorId    *string     `json:"actorId,omitempty" url:"actorId,omitempty"`
	AppId      *AppId      `json:"appId,omitempty" url:"appId,omitempty"`
	ActionId   *ActionId   `json:"actionId,omitempty" url:"actionId,omitempty"`
	DataClipId *DataClipId `json:"dataClipId,omitempty" url:"dataClipId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Context) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Context) UnmarshalJSON(data []byte) error {
	type unmarshaler Context
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Context(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Context) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The domain of the event
type Domain string

const (
	DomainFile        Domain = "file"
	DomainSpace       Domain = "space"
	DomainWorkbook    Domain = "workbook"
	DomainJob         Domain = "job"
	DomainDocument    Domain = "document"
	DomainSheet       Domain = "sheet"
	DomainProgram     Domain = "program"
	DomainSecret      Domain = "secret"
	DomainCron        Domain = "cron"
	DomainEnvironment Domain = "environment"
	DomainDataClip    Domain = "data-clip"
)

func NewDomainFromString(s string) (Domain, error) {
	switch s {
	case "file":
		return DomainFile, nil
	case "space":
		return DomainSpace, nil
	case "workbook":
		return DomainWorkbook, nil
	case "job":
		return DomainJob, nil
	case "document":
		return DomainDocument, nil
	case "sheet":
		return DomainSheet, nil
	case "program":
		return DomainProgram, nil
	case "secret":
		return DomainSecret, nil
	case "cron":
		return DomainCron, nil
	case "environment":
		return DomainEnvironment, nil
	case "data-clip":
		return DomainDataClip, nil
	}
	var t Domain
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d Domain) Ptr() *Domain {
	return &d
}

// An event that tracks an activity within an environment
type Event struct {
	Topic                  string
	AgentCreated           *GenericEvent
	AgentUpdated           *GenericEvent
	AgentDeleted           *GenericEvent
	SpaceCreated           *GenericEvent
	SpaceUpdated           *GenericEvent
	SpaceDeleted           *GenericEvent
	SpaceArchived          *GenericEvent
	SpaceExpired           *GenericEvent
	SpaceGuestAdded        *GenericEvent
	SpaceGuestRemoved      *GenericEvent
	DocumentCreated        *GenericEvent
	DocumentUpdated        *GenericEvent
	DocumentDeleted        *GenericEvent
	WorkbookCreated        *GenericEvent
	WorkbookUpdated        *GenericEvent
	WorkbookDeleted        *GenericEvent
	WorkbookExpired        *GenericEvent
	SheetCreated           *GenericEvent
	SheetUpdated           *GenericEvent
	SheetDeleted           *GenericEvent
	SheetCountsUpdated     *GenericEvent
	SnapshotCreated        *GenericEvent
	RecordsCreated         *GenericEvent
	RecordsUpdated         *GenericEvent
	RecordsDeleted         *GenericEvent
	FileCreated            *GenericEvent
	FileUpdated            *GenericEvent
	FileDeleted            *GenericEvent
	FileExpired            *GenericEvent
	JobCreated             *GenericEvent
	JobUpdated             *GenericEvent
	JobDeleted             *GenericEvent
	JobFailed              *GenericEvent
	JobCompleted           *GenericEvent
	JobReady               *GenericEvent
	JobScheduled           *GenericEvent
	JobOutcomeAcknowledged *GenericEvent
	JobPartsCompleted      *GenericEvent
	ProgramCreated         *GenericEvent
	ProgramUpdated         *GenericEvent
	CommitCreated          *GenericEvent
	CommitUpdated          *GenericEvent
	CommitCompleted        *GenericEvent
	SecretCreated          *GenericEvent
	SecretUpdated          *GenericEvent
	SecretDeleted          *GenericEvent
	LayerCreated           *GenericEvent
	EnvironmentCreated     *GenericEvent
	EnvironmentUpdated     *GenericEvent
	EnvironmentDeleted     *GenericEvent
	ActionCreated          *GenericEvent
	ActionUpdated          *GenericEvent
	ActionDeleted          *GenericEvent
	DataClipCreated        *GenericEvent
	DataClipUpdated        *GenericEvent
	DataClipDeleted        *GenericEvent
}

func NewEventFromAgentCreated(value *GenericEvent) *Event {
	return &Event{Topic: "agent:created", AgentCreated: value}
}

func NewEventFromAgentUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "agent:updated", AgentUpdated: value}
}

func NewEventFromAgentDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "agent:deleted", AgentDeleted: value}
}

func NewEventFromSpaceCreated(value *GenericEvent) *Event {
	return &Event{Topic: "space:created", SpaceCreated: value}
}

func NewEventFromSpaceUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "space:updated", SpaceUpdated: value}
}

func NewEventFromSpaceDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "space:deleted", SpaceDeleted: value}
}

func NewEventFromSpaceArchived(value *GenericEvent) *Event {
	return &Event{Topic: "space:archived", SpaceArchived: value}
}

func NewEventFromSpaceExpired(value *GenericEvent) *Event {
	return &Event{Topic: "space:expired", SpaceExpired: value}
}

func NewEventFromSpaceGuestAdded(value *GenericEvent) *Event {
	return &Event{Topic: "space:guestAdded", SpaceGuestAdded: value}
}

func NewEventFromSpaceGuestRemoved(value *GenericEvent) *Event {
	return &Event{Topic: "space:guestRemoved", SpaceGuestRemoved: value}
}

func NewEventFromDocumentCreated(value *GenericEvent) *Event {
	return &Event{Topic: "document:created", DocumentCreated: value}
}

func NewEventFromDocumentUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "document:updated", DocumentUpdated: value}
}

func NewEventFromDocumentDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "document:deleted", DocumentDeleted: value}
}

func NewEventFromWorkbookCreated(value *GenericEvent) *Event {
	return &Event{Topic: "workbook:created", WorkbookCreated: value}
}

func NewEventFromWorkbookUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "workbook:updated", WorkbookUpdated: value}
}

func NewEventFromWorkbookDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "workbook:deleted", WorkbookDeleted: value}
}

func NewEventFromWorkbookExpired(value *GenericEvent) *Event {
	return &Event{Topic: "workbook:expired", WorkbookExpired: value}
}

func NewEventFromSheetCreated(value *GenericEvent) *Event {
	return &Event{Topic: "sheet:created", SheetCreated: value}
}

func NewEventFromSheetUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "sheet:updated", SheetUpdated: value}
}

func NewEventFromSheetDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "sheet:deleted", SheetDeleted: value}
}

func NewEventFromSheetCountsUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "sheet:counts-updated", SheetCountsUpdated: value}
}

func NewEventFromSnapshotCreated(value *GenericEvent) *Event {
	return &Event{Topic: "snapshot:created", SnapshotCreated: value}
}

func NewEventFromRecordsCreated(value *GenericEvent) *Event {
	return &Event{Topic: "records:created", RecordsCreated: value}
}

func NewEventFromRecordsUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "records:updated", RecordsUpdated: value}
}

func NewEventFromRecordsDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "records:deleted", RecordsDeleted: value}
}

func NewEventFromFileCreated(value *GenericEvent) *Event {
	return &Event{Topic: "file:created", FileCreated: value}
}

func NewEventFromFileUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "file:updated", FileUpdated: value}
}

func NewEventFromFileDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "file:deleted", FileDeleted: value}
}

func NewEventFromFileExpired(value *GenericEvent) *Event {
	return &Event{Topic: "file:expired", FileExpired: value}
}

func NewEventFromJobCreated(value *GenericEvent) *Event {
	return &Event{Topic: "job:created", JobCreated: value}
}

func NewEventFromJobUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "job:updated", JobUpdated: value}
}

func NewEventFromJobDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "job:deleted", JobDeleted: value}
}

func NewEventFromJobFailed(value *GenericEvent) *Event {
	return &Event{Topic: "job:failed", JobFailed: value}
}

func NewEventFromJobCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "job:completed", JobCompleted: value}
}

func NewEventFromJobReady(value *GenericEvent) *Event {
	return &Event{Topic: "job:ready", JobReady: value}
}

func NewEventFromJobScheduled(value *GenericEvent) *Event {
	return &Event{Topic: "job:scheduled", JobScheduled: value}
}

func NewEventFromJobOutcomeAcknowledged(value *GenericEvent) *Event {
	return &Event{Topic: "job:outcome-acknowledged", JobOutcomeAcknowledged: value}
}

func NewEventFromJobPartsCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "job:parts-completed", JobPartsCompleted: value}
}

func NewEventFromProgramCreated(value *GenericEvent) *Event {
	return &Event{Topic: "program:created", ProgramCreated: value}
}

func NewEventFromProgramUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "program:updated", ProgramUpdated: value}
}

func NewEventFromCommitCreated(value *GenericEvent) *Event {
	return &Event{Topic: "commit:created", CommitCreated: value}
}

func NewEventFromCommitUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "commit:updated", CommitUpdated: value}
}

func NewEventFromCommitCompleted(value *GenericEvent) *Event {
	return &Event{Topic: "commit:completed", CommitCompleted: value}
}

func NewEventFromSecretCreated(value *GenericEvent) *Event {
	return &Event{Topic: "secret:created", SecretCreated: value}
}

func NewEventFromSecretUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "secret:updated", SecretUpdated: value}
}

func NewEventFromSecretDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "secret:deleted", SecretDeleted: value}
}

func NewEventFromLayerCreated(value *GenericEvent) *Event {
	return &Event{Topic: "layer:created", LayerCreated: value}
}

func NewEventFromEnvironmentCreated(value *GenericEvent) *Event {
	return &Event{Topic: "environment:created", EnvironmentCreated: value}
}

func NewEventFromEnvironmentUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "environment:updated", EnvironmentUpdated: value}
}

func NewEventFromEnvironmentDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "environment:deleted", EnvironmentDeleted: value}
}

func NewEventFromActionCreated(value *GenericEvent) *Event {
	return &Event{Topic: "action:created", ActionCreated: value}
}

func NewEventFromActionUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "action:updated", ActionUpdated: value}
}

func NewEventFromActionDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "action:deleted", ActionDeleted: value}
}

func NewEventFromDataClipCreated(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:created", DataClipCreated: value}
}

func NewEventFromDataClipUpdated(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:updated", DataClipUpdated: value}
}

func NewEventFromDataClipDeleted(value *GenericEvent) *Event {
	return &Event{Topic: "data-clip:deleted", DataClipDeleted: value}
}

func (e *Event) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Topic string `json:"topic"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Topic = unmarshaler.Topic
	if unmarshaler.Topic == "" {
		return fmt.Errorf("%T did not include discriminant topic", e)
	}
	switch unmarshaler.Topic {
	case "agent:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentCreated = value
	case "agent:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentUpdated = value
	case "agent:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AgentDeleted = value
	case "space:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceCreated = value
	case "space:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceUpdated = value
	case "space:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceDeleted = value
	case "space:archived":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceArchived = value
	case "space:expired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceExpired = value
	case "space:guestAdded":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceGuestAdded = value
	case "space:guestRemoved":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SpaceGuestRemoved = value
	case "document:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentCreated = value
	case "document:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentUpdated = value
	case "document:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DocumentDeleted = value
	case "workbook:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookCreated = value
	case "workbook:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookUpdated = value
	case "workbook:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookDeleted = value
	case "workbook:expired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WorkbookExpired = value
	case "sheet:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetCreated = value
	case "sheet:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetUpdated = value
	case "sheet:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetDeleted = value
	case "sheet:counts-updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SheetCountsUpdated = value
	case "snapshot:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SnapshotCreated = value
	case "records:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsCreated = value
	case "records:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsUpdated = value
	case "records:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.RecordsDeleted = value
	case "file:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileCreated = value
	case "file:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileUpdated = value
	case "file:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileDeleted = value
	case "file:expired":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileExpired = value
	case "job:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobCreated = value
	case "job:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobUpdated = value
	case "job:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobDeleted = value
	case "job:failed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobFailed = value
	case "job:completed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobCompleted = value
	case "job:ready":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobReady = value
	case "job:scheduled":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobScheduled = value
	case "job:outcome-acknowledged":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobOutcomeAcknowledged = value
	case "job:parts-completed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.JobPartsCompleted = value
	case "program:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ProgramCreated = value
	case "program:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ProgramUpdated = value
	case "commit:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitCreated = value
	case "commit:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitUpdated = value
	case "commit:completed":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.CommitCompleted = value
	case "secret:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretCreated = value
	case "secret:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretUpdated = value
	case "secret:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecretDeleted = value
	case "layer:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.LayerCreated = value
	case "environment:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EnvironmentCreated = value
	case "environment:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EnvironmentUpdated = value
	case "environment:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EnvironmentDeleted = value
	case "action:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ActionCreated = value
	case "action:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ActionUpdated = value
	case "action:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ActionDeleted = value
	case "data-clip:created":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipCreated = value
	case "data-clip:updated":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipUpdated = value
	case "data-clip:deleted":
		value := new(GenericEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DataClipDeleted = value
	}
	return nil
}

func (e Event) MarshalJSON() ([]byte, error) {
	switch e.Topic {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Topic, e)
	case "agent:created":
		return core.MarshalJSONWithExtraProperty(e.AgentCreated, "topic", "agent:created")
	case "agent:updated":
		return core.MarshalJSONWithExtraProperty(e.AgentUpdated, "topic", "agent:updated")
	case "agent:deleted":
		return core.MarshalJSONWithExtraProperty(e.AgentDeleted, "topic", "agent:deleted")
	case "space:created":
		return core.MarshalJSONWithExtraProperty(e.SpaceCreated, "topic", "space:created")
	case "space:updated":
		return core.MarshalJSONWithExtraProperty(e.SpaceUpdated, "topic", "space:updated")
	case "space:deleted":
		return core.MarshalJSONWithExtraProperty(e.SpaceDeleted, "topic", "space:deleted")
	case "space:archived":
		return core.MarshalJSONWithExtraProperty(e.SpaceArchived, "topic", "space:archived")
	case "space:expired":
		return core.MarshalJSONWithExtraProperty(e.SpaceExpired, "topic", "space:expired")
	case "space:guestAdded":
		return core.MarshalJSONWithExtraProperty(e.SpaceGuestAdded, "topic", "space:guestAdded")
	case "space:guestRemoved":
		return core.MarshalJSONWithExtraProperty(e.SpaceGuestRemoved, "topic", "space:guestRemoved")
	case "document:created":
		return core.MarshalJSONWithExtraProperty(e.DocumentCreated, "topic", "document:created")
	case "document:updated":
		return core.MarshalJSONWithExtraProperty(e.DocumentUpdated, "topic", "document:updated")
	case "document:deleted":
		return core.MarshalJSONWithExtraProperty(e.DocumentDeleted, "topic", "document:deleted")
	case "workbook:created":
		return core.MarshalJSONWithExtraProperty(e.WorkbookCreated, "topic", "workbook:created")
	case "workbook:updated":
		return core.MarshalJSONWithExtraProperty(e.WorkbookUpdated, "topic", "workbook:updated")
	case "workbook:deleted":
		return core.MarshalJSONWithExtraProperty(e.WorkbookDeleted, "topic", "workbook:deleted")
	case "workbook:expired":
		return core.MarshalJSONWithExtraProperty(e.WorkbookExpired, "topic", "workbook:expired")
	case "sheet:created":
		return core.MarshalJSONWithExtraProperty(e.SheetCreated, "topic", "sheet:created")
	case "sheet:updated":
		return core.MarshalJSONWithExtraProperty(e.SheetUpdated, "topic", "sheet:updated")
	case "sheet:deleted":
		return core.MarshalJSONWithExtraProperty(e.SheetDeleted, "topic", "sheet:deleted")
	case "sheet:counts-updated":
		return core.MarshalJSONWithExtraProperty(e.SheetCountsUpdated, "topic", "sheet:counts-updated")
	case "snapshot:created":
		return core.MarshalJSONWithExtraProperty(e.SnapshotCreated, "topic", "snapshot:created")
	case "records:created":
		return core.MarshalJSONWithExtraProperty(e.RecordsCreated, "topic", "records:created")
	case "records:updated":
		return core.MarshalJSONWithExtraProperty(e.RecordsUpdated, "topic", "records:updated")
	case "records:deleted":
		return core.MarshalJSONWithExtraProperty(e.RecordsDeleted, "topic", "records:deleted")
	case "file:created":
		return core.MarshalJSONWithExtraProperty(e.FileCreated, "topic", "file:created")
	case "file:updated":
		return core.MarshalJSONWithExtraProperty(e.FileUpdated, "topic", "file:updated")
	case "file:deleted":
		return core.MarshalJSONWithExtraProperty(e.FileDeleted, "topic", "file:deleted")
	case "file:expired":
		return core.MarshalJSONWithExtraProperty(e.FileExpired, "topic", "file:expired")
	case "job:created":
		return core.MarshalJSONWithExtraProperty(e.JobCreated, "topic", "job:created")
	case "job:updated":
		return core.MarshalJSONWithExtraProperty(e.JobUpdated, "topic", "job:updated")
	case "job:deleted":
		return core.MarshalJSONWithExtraProperty(e.JobDeleted, "topic", "job:deleted")
	case "job:failed":
		return core.MarshalJSONWithExtraProperty(e.JobFailed, "topic", "job:failed")
	case "job:completed":
		return core.MarshalJSONWithExtraProperty(e.JobCompleted, "topic", "job:completed")
	case "job:ready":
		return core.MarshalJSONWithExtraProperty(e.JobReady, "topic", "job:ready")
	case "job:scheduled":
		return core.MarshalJSONWithExtraProperty(e.JobScheduled, "topic", "job:scheduled")
	case "job:outcome-acknowledged":
		return core.MarshalJSONWithExtraProperty(e.JobOutcomeAcknowledged, "topic", "job:outcome-acknowledged")
	case "job:parts-completed":
		return core.MarshalJSONWithExtraProperty(e.JobPartsCompleted, "topic", "job:parts-completed")
	case "program:created":
		return core.MarshalJSONWithExtraProperty(e.ProgramCreated, "topic", "program:created")
	case "program:updated":
		return core.MarshalJSONWithExtraProperty(e.ProgramUpdated, "topic", "program:updated")
	case "commit:created":
		return core.MarshalJSONWithExtraProperty(e.CommitCreated, "topic", "commit:created")
	case "commit:updated":
		return core.MarshalJSONWithExtraProperty(e.CommitUpdated, "topic", "commit:updated")
	case "commit:completed":
		return core.MarshalJSONWithExtraProperty(e.CommitCompleted, "topic", "commit:completed")
	case "secret:created":
		return core.MarshalJSONWithExtraProperty(e.SecretCreated, "topic", "secret:created")
	case "secret:updated":
		return core.MarshalJSONWithExtraProperty(e.SecretUpdated, "topic", "secret:updated")
	case "secret:deleted":
		return core.MarshalJSONWithExtraProperty(e.SecretDeleted, "topic", "secret:deleted")
	case "layer:created":
		return core.MarshalJSONWithExtraProperty(e.LayerCreated, "topic", "layer:created")
	case "environment:created":
		return core.MarshalJSONWithExtraProperty(e.EnvironmentCreated, "topic", "environment:created")
	case "environment:updated":
		return core.MarshalJSONWithExtraProperty(e.EnvironmentUpdated, "topic", "environment:updated")
	case "environment:deleted":
		return core.MarshalJSONWithExtraProperty(e.EnvironmentDeleted, "topic", "environment:deleted")
	case "action:created":
		return core.MarshalJSONWithExtraProperty(e.ActionCreated, "topic", "action:created")
	case "action:updated":
		return core.MarshalJSONWithExtraProperty(e.ActionUpdated, "topic", "action:updated")
	case "action:deleted":
		return core.MarshalJSONWithExtraProperty(e.ActionDeleted, "topic", "action:deleted")
	case "data-clip:created":
		return core.MarshalJSONWithExtraProperty(e.DataClipCreated, "topic", "data-clip:created")
	case "data-clip:updated":
		return core.MarshalJSONWithExtraProperty(e.DataClipUpdated, "topic", "data-clip:updated")
	case "data-clip:deleted":
		return core.MarshalJSONWithExtraProperty(e.DataClipDeleted, "topic", "data-clip:deleted")
	}
}

type EventVisitor interface {
	VisitAgentCreated(*GenericEvent) error
	VisitAgentUpdated(*GenericEvent) error
	VisitAgentDeleted(*GenericEvent) error
	VisitSpaceCreated(*GenericEvent) error
	VisitSpaceUpdated(*GenericEvent) error
	VisitSpaceDeleted(*GenericEvent) error
	VisitSpaceArchived(*GenericEvent) error
	VisitSpaceExpired(*GenericEvent) error
	VisitSpaceGuestAdded(*GenericEvent) error
	VisitSpaceGuestRemoved(*GenericEvent) error
	VisitDocumentCreated(*GenericEvent) error
	VisitDocumentUpdated(*GenericEvent) error
	VisitDocumentDeleted(*GenericEvent) error
	VisitWorkbookCreated(*GenericEvent) error
	VisitWorkbookUpdated(*GenericEvent) error
	VisitWorkbookDeleted(*GenericEvent) error
	VisitWorkbookExpired(*GenericEvent) error
	VisitSheetCreated(*GenericEvent) error
	VisitSheetUpdated(*GenericEvent) error
	VisitSheetDeleted(*GenericEvent) error
	VisitSheetCountsUpdated(*GenericEvent) error
	VisitSnapshotCreated(*GenericEvent) error
	VisitRecordsCreated(*GenericEvent) error
	VisitRecordsUpdated(*GenericEvent) error
	VisitRecordsDeleted(*GenericEvent) error
	VisitFileCreated(*GenericEvent) error
	VisitFileUpdated(*GenericEvent) error
	VisitFileDeleted(*GenericEvent) error
	VisitFileExpired(*GenericEvent) error
	VisitJobCreated(*GenericEvent) error
	VisitJobUpdated(*GenericEvent) error
	VisitJobDeleted(*GenericEvent) error
	VisitJobFailed(*GenericEvent) error
	VisitJobCompleted(*GenericEvent) error
	VisitJobReady(*GenericEvent) error
	VisitJobScheduled(*GenericEvent) error
	VisitJobOutcomeAcknowledged(*GenericEvent) error
	VisitJobPartsCompleted(*GenericEvent) error
	VisitProgramCreated(*GenericEvent) error
	VisitProgramUpdated(*GenericEvent) error
	VisitCommitCreated(*GenericEvent) error
	VisitCommitUpdated(*GenericEvent) error
	VisitCommitCompleted(*GenericEvent) error
	VisitSecretCreated(*GenericEvent) error
	VisitSecretUpdated(*GenericEvent) error
	VisitSecretDeleted(*GenericEvent) error
	VisitLayerCreated(*GenericEvent) error
	VisitEnvironmentCreated(*GenericEvent) error
	VisitEnvironmentUpdated(*GenericEvent) error
	VisitEnvironmentDeleted(*GenericEvent) error
	VisitActionCreated(*GenericEvent) error
	VisitActionUpdated(*GenericEvent) error
	VisitActionDeleted(*GenericEvent) error
	VisitDataClipCreated(*GenericEvent) error
	VisitDataClipUpdated(*GenericEvent) error
	VisitDataClipDeleted(*GenericEvent) error
}

func (e *Event) Accept(visitor EventVisitor) error {
	switch e.Topic {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Topic, e)
	case "agent:created":
		return visitor.VisitAgentCreated(e.AgentCreated)
	case "agent:updated":
		return visitor.VisitAgentUpdated(e.AgentUpdated)
	case "agent:deleted":
		return visitor.VisitAgentDeleted(e.AgentDeleted)
	case "space:created":
		return visitor.VisitSpaceCreated(e.SpaceCreated)
	case "space:updated":
		return visitor.VisitSpaceUpdated(e.SpaceUpdated)
	case "space:deleted":
		return visitor.VisitSpaceDeleted(e.SpaceDeleted)
	case "space:archived":
		return visitor.VisitSpaceArchived(e.SpaceArchived)
	case "space:expired":
		return visitor.VisitSpaceExpired(e.SpaceExpired)
	case "space:guestAdded":
		return visitor.VisitSpaceGuestAdded(e.SpaceGuestAdded)
	case "space:guestRemoved":
		return visitor.VisitSpaceGuestRemoved(e.SpaceGuestRemoved)
	case "document:created":
		return visitor.VisitDocumentCreated(e.DocumentCreated)
	case "document:updated":
		return visitor.VisitDocumentUpdated(e.DocumentUpdated)
	case "document:deleted":
		return visitor.VisitDocumentDeleted(e.DocumentDeleted)
	case "workbook:created":
		return visitor.VisitWorkbookCreated(e.WorkbookCreated)
	case "workbook:updated":
		return visitor.VisitWorkbookUpdated(e.WorkbookUpdated)
	case "workbook:deleted":
		return visitor.VisitWorkbookDeleted(e.WorkbookDeleted)
	case "workbook:expired":
		return visitor.VisitWorkbookExpired(e.WorkbookExpired)
	case "sheet:created":
		return visitor.VisitSheetCreated(e.SheetCreated)
	case "sheet:updated":
		return visitor.VisitSheetUpdated(e.SheetUpdated)
	case "sheet:deleted":
		return visitor.VisitSheetDeleted(e.SheetDeleted)
	case "sheet:counts-updated":
		return visitor.VisitSheetCountsUpdated(e.SheetCountsUpdated)
	case "snapshot:created":
		return visitor.VisitSnapshotCreated(e.SnapshotCreated)
	case "records:created":
		return visitor.VisitRecordsCreated(e.RecordsCreated)
	case "records:updated":
		return visitor.VisitRecordsUpdated(e.RecordsUpdated)
	case "records:deleted":
		return visitor.VisitRecordsDeleted(e.RecordsDeleted)
	case "file:created":
		return visitor.VisitFileCreated(e.FileCreated)
	case "file:updated":
		return visitor.VisitFileUpdated(e.FileUpdated)
	case "file:deleted":
		return visitor.VisitFileDeleted(e.FileDeleted)
	case "file:expired":
		return visitor.VisitFileExpired(e.FileExpired)
	case "job:created":
		return visitor.VisitJobCreated(e.JobCreated)
	case "job:updated":
		return visitor.VisitJobUpdated(e.JobUpdated)
	case "job:deleted":
		return visitor.VisitJobDeleted(e.JobDeleted)
	case "job:failed":
		return visitor.VisitJobFailed(e.JobFailed)
	case "job:completed":
		return visitor.VisitJobCompleted(e.JobCompleted)
	case "job:ready":
		return visitor.VisitJobReady(e.JobReady)
	case "job:scheduled":
		return visitor.VisitJobScheduled(e.JobScheduled)
	case "job:outcome-acknowledged":
		return visitor.VisitJobOutcomeAcknowledged(e.JobOutcomeAcknowledged)
	case "job:parts-completed":
		return visitor.VisitJobPartsCompleted(e.JobPartsCompleted)
	case "program:created":
		return visitor.VisitProgramCreated(e.ProgramCreated)
	case "program:updated":
		return visitor.VisitProgramUpdated(e.ProgramUpdated)
	case "commit:created":
		return visitor.VisitCommitCreated(e.CommitCreated)
	case "commit:updated":
		return visitor.VisitCommitUpdated(e.CommitUpdated)
	case "commit:completed":
		return visitor.VisitCommitCompleted(e.CommitCompleted)
	case "secret:created":
		return visitor.VisitSecretCreated(e.SecretCreated)
	case "secret:updated":
		return visitor.VisitSecretUpdated(e.SecretUpdated)
	case "secret:deleted":
		return visitor.VisitSecretDeleted(e.SecretDeleted)
	case "layer:created":
		return visitor.VisitLayerCreated(e.LayerCreated)
	case "environment:created":
		return visitor.VisitEnvironmentCreated(e.EnvironmentCreated)
	case "environment:updated":
		return visitor.VisitEnvironmentUpdated(e.EnvironmentUpdated)
	case "environment:deleted":
		return visitor.VisitEnvironmentDeleted(e.EnvironmentDeleted)
	case "action:created":
		return visitor.VisitActionCreated(e.ActionCreated)
	case "action:updated":
		return visitor.VisitActionUpdated(e.ActionUpdated)
	case "action:deleted":
		return visitor.VisitActionDeleted(e.ActionDeleted)
	case "data-clip:created":
		return visitor.VisitDataClipCreated(e.DataClipCreated)
	case "data-clip:updated":
		return visitor.VisitDataClipUpdated(e.DataClipUpdated)
	case "data-clip:deleted":
		return visitor.VisitDataClipDeleted(e.DataClipDeleted)
	}
}

// The attributes of the event
type EventAttributes struct {
	// Date the related entity was last updated
	TargetUpdatedAt *time.Time `json:"targetUpdatedAt,omitempty" url:"targetUpdatedAt,omitempty"`
	// The progress of the event within a collection of iterable events
	Progress *Progress `json:"progress,omitempty" url:"progress,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventAttributes) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventAttributes) UnmarshalJSON(data []byte) error {
	type embed EventAttributes
	var unmarshaler = struct {
		embed
		TargetUpdatedAt *core.DateTime `json:"targetUpdatedAt,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventAttributes(unmarshaler.embed)
	e.TargetUpdatedAt = unmarshaler.TargetUpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventAttributes) MarshalJSON() ([]byte, error) {
	type embed EventAttributes
	var marshaler = struct {
		embed
		TargetUpdatedAt *core.DateTime `json:"targetUpdatedAt,omitempty"`
	}{
		embed:           embed(*e),
		TargetUpdatedAt: core.NewOptionalDateTime(e.TargetUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EventAttributes) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventContextSlugs struct {
	// The slug of the space
	Space *string `json:"space,omitempty" url:"space,omitempty"`
	// The slug of the workbook
	Workbook *string `json:"workbook,omitempty" url:"workbook,omitempty"`
	// The slug of the sheet
	Sheet *string `json:"sheet,omitempty" url:"sheet,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventContextSlugs) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventContextSlugs) UnmarshalJSON(data []byte) error {
	type unmarshaler EventContextSlugs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventContextSlugs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventContextSlugs) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventResponse struct {
	Data *Event `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type GenericEvent struct {
	// The domain of the event
	Domain Domain `json:"domain" url:"domain"`
	// The context of the event
	Context *Context `json:"context,omitempty" url:"context,omitempty"`
	// The attributes of the event
	Attributes *EventAttributes `json:"attributes,omitempty" url:"attributes,omitempty"`
	// The callback url to acknowledge the event
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// The url to retrieve the data associated with the event
	DataUrl    *string  `json:"dataUrl,omitempty" url:"dataUrl,omitempty"`
	Target     *string  `json:"target,omitempty" url:"target,omitempty"`
	Origin     *Origin  `json:"origin,omitempty" url:"origin,omitempty"`
	Namespaces []string `json:"namespaces,omitempty" url:"namespaces,omitempty"`
	Id         EventId  `json:"id" url:"id"`
	// Date the event was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the event was deleted
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`
	// Date the event was acknowledged
	AcknowledgedAt *time.Time `json:"acknowledgedAt,omitempty" url:"acknowledgedAt,omitempty"`
	// The actor (user or system) who acknowledged the event
	AcknowledgedBy *string                `json:"acknowledgedBy,omitempty" url:"acknowledgedBy,omitempty"`
	Payload        map[string]interface{} `json:"payload,omitempty" url:"payload,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GenericEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenericEvent) UnmarshalJSON(data []byte) error {
	type embed GenericEvent
	var unmarshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"createdAt"`
		DeletedAt      *core.DateTime `json:"deletedAt,omitempty"`
		AcknowledgedAt *core.DateTime `json:"acknowledgedAt,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GenericEvent(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	g.AcknowledgedAt = unmarshaler.AcknowledgedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenericEvent) MarshalJSON() ([]byte, error) {
	type embed GenericEvent
	var marshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"createdAt"`
		DeletedAt      *core.DateTime `json:"deletedAt,omitempty"`
		AcknowledgedAt *core.DateTime `json:"acknowledgedAt,omitempty"`
	}{
		embed:          embed(*g),
		CreatedAt:      core.NewDateTime(g.CreatedAt),
		DeletedAt:      core.NewOptionalDateTime(g.DeletedAt),
		AcknowledgedAt: core.NewOptionalDateTime(g.AcknowledgedAt),
	}
	return json.Marshal(marshaler)
}

func (g *GenericEvent) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListAllEventsResponse struct {
	Data []*Event `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListAllEventsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListAllEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListAllEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListAllEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListAllEventsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The origin resource of the event
type Origin struct {
	Id   *string `json:"id,omitempty" url:"id,omitempty"`
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Origin) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Origin) UnmarshalJSON(data []byte) error {
	type unmarshaler Origin
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Origin(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Origin) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The progress of the event within a collection of iterable events
type Progress struct {
	// The current progress of the event
	Current *int `json:"current,omitempty" url:"current,omitempty"`
	// The total number of events in this group
	Total *int `json:"total,omitempty" url:"total,omitempty"`
	// The percent complete of the event group
	Percent *int `json:"percent,omitempty" url:"percent,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Progress) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Progress) UnmarshalJSON(data []byte) error {
	type unmarshaler Progress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Progress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Progress) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Sheet Slug
type SheetSlug = string

// Any uploaded file of any type
type File struct {
	Id FileId `json:"id" url:"id"`
	// Original filename
	Name string `json:"name" url:"name"`
	// Extension of the file
	Ext string `json:"ext" url:"ext"`
	// MIME Type of the file
	Mimetype string `json:"mimetype" url:"mimetype"`
	// Text encoding of the file
	Encoding string `json:"encoding" url:"encoding"`
	// Status of the file
	Status ModelFileStatusEnum `json:"status" url:"status"`
	// The storage mode of file
	Mode *Mode `json:"mode,omitempty" url:"mode,omitempty"`
	// Size of file in bytes
	Size int `json:"size" url:"size"`
	// Number of bytes that have been uploaded so far (useful for progress tracking)
	BytesReceived int `json:"bytesReceived" url:"bytesReceived"`
	// Date the file was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the file was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date the file was expired
	ExpiredAt  *time.Time  `json:"expiredAt,omitempty" url:"expiredAt,omitempty"`
	SpaceId    SpaceId     `json:"spaceId" url:"spaceId"`
	WorkbookId *WorkbookId `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	SheetId    *SheetId    `json:"sheetId,omitempty" url:"sheetId,omitempty"`
	Actions    []*Action   `json:"actions,omitempty" url:"actions,omitempty"`
	Origin     *FileOrigin `json:"origin,omitempty" url:"origin,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		ExpiredAt *core.DateTime `json:"expiredAt,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.Time()
	f.UpdatedAt = unmarshaler.UpdatedAt.Time()
	f.ExpiredAt = unmarshaler.ExpiredAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
		ExpiredAt *core.DateTime `json:"expiredAt,omitempty"`
	}{
		embed:     embed(*f),
		CreatedAt: core.NewDateTime(f.CreatedAt),
		UpdatedAt: core.NewDateTime(f.UpdatedAt),
		ExpiredAt: core.NewOptionalDateTime(f.ExpiredAt),
	}
	return json.Marshal(marshaler)
}

func (f *File) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Guest struct {
	EnvironmentId EnvironmentId `json:"environmentId" url:"environmentId"`
	Email         string        `json:"email" url:"email"`
	Name          string        `json:"name" url:"name"`
	Spaces        []*GuestSpace `json:"spaces,omitempty" url:"spaces,omitempty"`
	Id            GuestId       `json:"id" url:"id"`
	// Date the guest object was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the guest object was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Guest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Guest) UnmarshalJSON(data []byte) error {
	type embed Guest
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = Guest(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Guest) MarshalJSON() ([]byte, error) {
	type embed Guest
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*g),
		CreatedAt: core.NewDateTime(g.CreatedAt),
		UpdatedAt: core.NewDateTime(g.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (g *Guest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuestSpace struct {
	Id           SpaceId          `json:"id" url:"id"`
	Workbooks    []*GuestWorkbook `json:"workbooks,omitempty" url:"workbooks,omitempty"`
	LastAccessed *time.Time       `json:"lastAccessed,omitempty" url:"lastAccessed,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GuestSpace) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuestSpace) UnmarshalJSON(data []byte) error {
	type embed GuestSpace
	var unmarshaler = struct {
		embed
		LastAccessed *core.DateTime `json:"lastAccessed,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GuestSpace(unmarshaler.embed)
	g.LastAccessed = unmarshaler.LastAccessed.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuestSpace) MarshalJSON() ([]byte, error) {
	type embed GuestSpace
	var marshaler = struct {
		embed
		LastAccessed *core.DateTime `json:"lastAccessed,omitempty"`
	}{
		embed:        embed(*g),
		LastAccessed: core.NewOptionalDateTime(g.LastAccessed),
	}
	return json.Marshal(marshaler)
}

func (g *GuestSpace) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuestToken struct {
	// The token used to authenticate the guest
	Token string `json:"token" url:"token"`
	Valid bool   `json:"valid" url:"valid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GuestToken) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuestToken) UnmarshalJSON(data []byte) error {
	type unmarshaler GuestToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuestToken(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuestToken) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuestWorkbook struct {
	Id WorkbookId `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GuestWorkbook) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuestWorkbook) UnmarshalJSON(data []byte) error {
	type unmarshaler GuestWorkbook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuestWorkbook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuestWorkbook) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type AiGenerateBlueprintConstraintsJobConfig struct {
	SpaceId    SpaceId    `json:"spaceId" url:"spaceId"`
	WorkbookId WorkbookId `json:"workbookId" url:"workbookId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AiGenerateBlueprintConstraintsJobConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AiGenerateBlueprintConstraintsJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AiGenerateBlueprintConstraintsJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AiGenerateBlueprintConstraintsJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AiGenerateBlueprintConstraintsJobConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AiGenerateBlueprintJobConfig struct {
	SpaceId SpaceId `json:"spaceId" url:"spaceId"`
	AppId   AppId   `json:"appId" url:"appId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AiGenerateBlueprintJobConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AiGenerateBlueprintJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AiGenerateBlueprintJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AiGenerateBlueprintJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AiGenerateBlueprintJobConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AiGenerateConstraintJobConfig struct {
	SpaceId     SpaceId             `json:"spaceId" url:"spaceId"`
	Constraints []*StoredConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`
	// A description of what the constraint to be generated should do
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AiGenerateConstraintJobConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AiGenerateConstraintJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AiGenerateConstraintJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AiGenerateConstraintJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AiGenerateConstraintJobConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AiGenerateSampleDataJobConfig struct {
	SpaceId SpaceId `json:"spaceId" url:"spaceId"`
	AppId   AppId   `json:"appId" url:"appId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AiGenerateSampleDataJobConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AiGenerateSampleDataJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AiGenerateSampleDataJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AiGenerateSampleDataJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AiGenerateSampleDataJobConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for AI-powered rule creation jobs that generate or replace field constraints
type AiRuleCreationJobConfig struct {
	// The natural language description of the rule to be created
	Prompt string `json:"prompt" url:"prompt"`
	// The ID of the sheet containing the field to create/update the rule for
	SheetId SheetId `json:"sheetId" url:"sheetId"`
	// The key of the field to create/update the rule for
	FieldKey string `json:"fieldKey" url:"fieldKey"`
	// To edit an existing rule, provide the validator of the constraint on the field and that constraint will be replaced.
	Validator *string `json:"validator,omitempty" url:"validator,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AiRuleCreationJobConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AiRuleCreationJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AiRuleCreationJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AiRuleCreationJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AiRuleCreationJobConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppAutobuildDeployJobConfig struct {
	SpaceId SpaceId `json:"spaceId" url:"spaceId"`
	AppId   AppId   `json:"appId" url:"appId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppAutobuildDeployJobConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppAutobuildDeployJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AppAutobuildDeployJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppAutobuildDeployJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppAutobuildDeployJobConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type CategoryMapping struct {
	// The source value to map from
	SourceValue *EnumValue `json:"sourceValue,omitempty" url:"sourceValue,omitempty"`
	// The destination value to map to
	DestinationValue *EnumValue `json:"destinationValue,omitempty" url:"destinationValue,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CategoryMapping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CategoryMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CategoryMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CategoryMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CategoryMapping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Certainty string

const (
	CertaintyAbsolute Certainty = "absolute"
	CertaintyStrong   Certainty = "strong"
	CertaintyModerate Certainty = "moderate"
	CertaintyWeak     Certainty = "weak"
)

func NewCertaintyFromString(s string) (Certainty, error) {
	switch s {
	case "absolute":
		return CertaintyAbsolute, nil
	case "strong":
		return CertaintyStrong, nil
	case "moderate":
		return CertaintyModerate, nil
	case "weak":
		return CertaintyWeak, nil
	}
	var t Certainty
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Certainty) Ptr() *Certainty {
	return &c
}

type CollectionJobSubject struct {
	Resource string                 `json:"resource" url:"resource"`
	Params   map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`
	Query    map[string]interface{} `json:"query,omitempty" url:"query,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CollectionJobSubject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CollectionJobSubject) UnmarshalJSON(data []byte) error {
	type unmarshaler CollectionJobSubject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CollectionJobSubject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CollectionJobSubject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The configuration for a delete job
type DeleteRecordsJobConfig struct {
	// Options to filter records (default=none)
	Filter *Filter `json:"filter,omitempty" url:"filter,omitempty"`
	// Use this to narrow the valid/error filter results to a specific field (Requires filter to be set)
	FilterField *FilterField `json:"filterField,omitempty" url:"filterField,omitempty"`
	SearchValue *SearchValue `json:"searchValue,omitempty" url:"searchValue,omitempty"`
	SearchField *SearchField `json:"searchField,omitempty" url:"searchField,omitempty"`
	// FFQL query to filter records
	Q     *string `json:"q,omitempty" url:"q,omitempty"`
	Sheet SheetId `json:"sheet" url:"sheet"`
	// List of record ids to exclude from deletion
	Exceptions []RecordId `json:"exceptions,omitempty" url:"exceptions,omitempty"`
	// If specified, a snapshot will be generated with this label
	SnapshotLabel *string `json:"snapshotLabel,omitempty" url:"snapshotLabel,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteRecordsJobConfig) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteRecordsJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteRecordsJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteRecordsJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteRecordsJobConfig) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DestinationField struct {
	// The description of the destination field
	DestinationField *Property `json:"destinationField,omitempty" url:"destinationField,omitempty"`
	// A list of preview values of the data in the destination field
	Preview []string `json:"preview,omitempty" url:"preview,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DestinationField) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DestinationField) UnmarshalJSON(data []byte) error {
	type unmarshaler DestinationField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DestinationField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DestinationField) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The driver to use for extracting data from the file
type Driver string

const (
	DriverCsv Driver = "csv"
)

func NewDriverFromString(s string) (Driver, error) {
	switch s {
	case "csv":
		return DriverCsv, nil
	}
	var t Driver
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d Driver) Ptr() *Driver {
	return &d
}

type Edge struct {
	// The description of the source field
	SourceField *Property `json:"sourceField,omitempty" url:"sourceField,omitempty"`
	// The description of the destination field
	DestinationField *Property `json:"destinationField,omitempty" url:"destinationField,omitempty"`
	// A list of preview values of the data in the destination field
	Preview []string `json:"preview,omitempty" url:"preview,omitempty"`
	// Only available if one or more of the destination fields is of type enum. Provides category mapping.
	EnumDetails *EnumDetails `json:"enumDetails,omitempty" url:"enumDetails,omitempty"`
	// Metadata about the edge
	Metadata *Metadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Edge) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Edge) UnmarshalJSON(data []byte) error {
	type unmarshaler Edge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Edge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Edge) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmptyObject struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmptyObject) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmptyObject) UnmarshalJSON(data []byte) error {
	type unmarshaler EmptyObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmptyObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmptyObject) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Only available if one or more of the destination fields is of type enum. Provides category mapping.
type EnumDetails struct {
	// The mapping of source values to destination values
	Mapping []*CategoryMapping `json:"mapping,omitempty" url:"mapping,omitempty"`
	// A list of source values that are not mapped from
	UnusedSourceValues []*EnumValue `json:"unusedSourceValues,omitempty" url:"unusedSourceValues,omitempty"`
	// A list of destination values that are not mapped to
	UnusedDestinationValues []*EnumValue `json:"unusedDestinationValues,omitempty" url:"unusedDestinationValues,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumDetails) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumDetails) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumValue struct {
	String  string
	Integer int
	Boolean bool

	typ string
}

func NewEnumValueFromString(value string) *EnumValue {
	return &EnumValue{typ: "String", String: value}
}

func NewEnumValueFromInteger(value int) *EnumValue {
	return &EnumValue{typ: "Integer", Integer: value}
}

func NewEnumValueFromBoolean(value bool) *EnumValue {
	return &EnumValue{typ: "Boolean", Boolean: value}
}

func (e *EnumValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typ = "Integer"
		e.Integer = valueInteger
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		e.typ = "Boolean"
		e.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EnumValue) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Integer" || e.Integer != 0 {
		return json.Marshal(e.Integer)
	}
	if e.typ == "Boolean" || e.Boolean != false {
		return json.Marshal(e.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EnumValueVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
	VisitBoolean(bool) error
}

func (e *EnumValue) Accept(visitor EnumValueVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Integer" || e.Integer != 0 {
		return visitor.VisitInteger(e.Integer)
	}
	if e.typ == "Boolean" || e.Boolean != false {
		return visitor.VisitBoolean(e.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ExportJobConfig struct {
	Options *ExportOptions `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExportJobConfig) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExportJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ExportJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExportJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExportJobConfig) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExportOptions struct {
	// Deprecated, use `commitId` instead
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	// If provided, the snapshot version of the workbook will be used for the export
	CommitId *CommitId `json:"commitId,omitempty" url:"commitId,omitempty"`
	// The field to sort the records on
	SortField *SortField `json:"sortField,omitempty" url:"sortField,omitempty"`
	// The direction to sort the records
	SortDirection *SortDirection `json:"sortDirection,omitempty" url:"sortDirection,omitempty"`
	// The filter to apply to the records
	Filter *Filter `json:"filter,omitempty" url:"filter,omitempty"`
	// The field to filter on
	FilterField *FilterField `json:"filterField,omitempty" url:"filterField,omitempty"`
	// The value to search for
	SearchValue *SearchValue `json:"searchValue,omitempty" url:"searchValue,omitempty"`
	// The field to search for the search value in
	SearchField *SearchField `json:"searchField,omitempty" url:"searchField,omitempty"`
	// The FFQL query to filter records
	Q *string `json:"q,omitempty" url:"q,omitempty"`
	// The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records
	Ids []RecordId `json:"ids,omitempty" url:"ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExportOptions) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExportOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ExportOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExportOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExportOptions) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FileJobConfig struct {
	// The driver to use for extracting data from the file
	Driver Driver `json:"driver" url:"driver"`
	// The options to use for extracting data from the file
	Options map[string]interface{} `json:"options,omitempty" url:"options,omitempty"`
	// The row number of the header row detected at extraction time
	DetectedHeaderRow *int `json:"detectedHeaderRow,omitempty" url:"detectedHeaderRow,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FileJobConfig) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler FileJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileJobConfig) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindAndReplaceJobConfig struct {
	// The filter to apply to the records
	Filter *Filter `json:"filter,omitempty" url:"filter,omitempty"`
	// The field to filter on
	FilterField *FilterField `json:"filterField,omitempty" url:"filterField,omitempty"`
	// The value to search for
	SearchValue *SearchValue `json:"searchValue,omitempty" url:"searchValue,omitempty"`
	// The field to search for the search value in
	SearchField *SearchField `json:"searchField,omitempty" url:"searchField,omitempty"`
	// The FFQL query to filter records
	Q *string `json:"q,omitempty" url:"q,omitempty"`
	// The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records
	Ids []RecordId `json:"ids,omitempty" url:"ids,omitempty"`
	// A value to find for a given field in a sheet. Wrap the value in "" for exact match
	Find *CellValueUnion `json:"find,omitempty" url:"find,omitempty"`
	// The value to replace found values with
	Replace *CellValueUnion `json:"replace,omitempty" url:"replace,omitempty"`
	// A unique key used to identify a field in a sheet
	FieldKey string `json:"fieldKey" url:"fieldKey"`
	// If specified, a snapshot will be generated with this label
	SnapshotLabel *string `json:"snapshotLabel,omitempty" url:"snapshotLabel,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindAndReplaceJobConfig) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindAndReplaceJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler FindAndReplaceJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindAndReplaceJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindAndReplaceJobConfig) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A single unit of work that will execute asynchronously
type Job struct {
	// The type of job
	Type JobType `json:"type" url:"type"`
	// the type of operation to perform on the data. For example, "export".
	Operation   string           `json:"operation" url:"operation"`
	Source      JobSource        `json:"source" url:"source"`
	Destination *JobDestination  `json:"destination,omitempty" url:"destination,omitempty"`
	Config      *JobUpdateConfig `json:"config,omitempty" url:"config,omitempty"`
	// the type of trigger to use for this job
	Trigger *Trigger `json:"trigger,omitempty" url:"trigger,omitempty"`
	// the status of the job
	Status *JobStatus `json:"status,omitempty" url:"status,omitempty"`
	// the progress of the job. Whole number between 0 and 100
	Progress *int    `json:"progress,omitempty" url:"progress,omitempty"`
	FileId   *FileId `json:"fileId,omitempty" url:"fileId,omitempty"`
	// the mode of the job
	Mode *JobMode `json:"mode,omitempty" url:"mode,omitempty"`
	// Input parameters for this job type.
	Input map[string]interface{} `json:"input,omitempty" url:"input,omitempty"`
	// Subject parameters for this job type.
	Subject *JobSubject `json:"subject,omitempty" url:"subject,omitempty"`
	// Outcome summary of job.
	Outcome map[string]interface{} `json:"outcome,omitempty" url:"outcome,omitempty"`
	// Current status of job in text
	Info *string `json:"info,omitempty" url:"info,omitempty"`
	// Indicates if Flatfile is managing the control flow of this job or if it is being manually tracked.
	Managed *bool `json:"managed,omitempty" url:"managed,omitempty"`
	// The id of the environment this job belongs to
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The part number of this job
	Part *int `json:"part,omitempty" url:"part,omitempty"`
	// The data for this part of the job
	PartData map[string]interface{} `json:"partData,omitempty" url:"partData,omitempty"`
	// The execution mode for this part of the job
	PartExecution *JobPartExecution `json:"partExecution,omitempty" url:"partExecution,omitempty"`
	// The id of the parent job
	ParentId *JobId `json:"parentId,omitempty" url:"parentId,omitempty"`
	// The ids of the jobs that must complete before this job can start
	PredecessorIds []JobId `json:"predecessorIds,omitempty" url:"predecessorIds,omitempty"`
	// Additional metadata for the job
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Id       JobId                  `json:"id" url:"id"`
	// Date the item was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the item was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// the time that the job started at
	StartedAt *time.Time `json:"startedAt,omitempty" url:"startedAt,omitempty"`
	// the time that the job finished at
	FinishedAt *time.Time `json:"finishedAt,omitempty" url:"finishedAt,omitempty"`
	// the time that the job's outcome has been acknowledged by a user
	OutcomeAcknowledgedAt *time.Time `json:"outcomeAcknowledgedAt,omitempty" url:"outcomeAcknowledgedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *Job) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *Job) UnmarshalJSON(data []byte) error {
	type embed Job
	var unmarshaler = struct {
		embed
		CreatedAt             *core.DateTime `json:"createdAt"`
		UpdatedAt             *core.DateTime `json:"updatedAt"`
		StartedAt             *core.DateTime `json:"startedAt,omitempty"`
		FinishedAt            *core.DateTime `json:"finishedAt,omitempty"`
		OutcomeAcknowledgedAt *core.DateTime `json:"outcomeAcknowledgedAt,omitempty"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = Job(unmarshaler.embed)
	j.CreatedAt = unmarshaler.CreatedAt.Time()
	j.UpdatedAt = unmarshaler.UpdatedAt.Time()
	j.StartedAt = unmarshaler.StartedAt.TimePtr()
	j.FinishedAt = unmarshaler.FinishedAt.TimePtr()
	j.OutcomeAcknowledgedAt = unmarshaler.OutcomeAcknowledgedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *Job) MarshalJSON() ([]byte, error) {
	type embed Job
	var marshaler = struct {
		embed
		CreatedAt             *core.DateTime `json:"createdAt"`
		UpdatedAt             *core.DateTime `json:"updatedAt"`
		StartedAt             *core.DateTime `json:"startedAt,omitempty"`
		FinishedAt            *core.DateTime `json:"finishedAt,omitempty"`
		OutcomeAcknowledgedAt *core.DateTime `json:"outcomeAcknowledgedAt,omitempty"`
	}{
		embed:                 embed(*j),
		CreatedAt:             core.NewDateTime(j.CreatedAt),
		UpdatedAt:             core.NewDateTime(j.UpdatedAt),
		StartedAt:             core.NewOptionalDateTime(j.StartedAt),
		FinishedAt:            core.NewOptionalDateTime(j.FinishedAt),
		OutcomeAcknowledgedAt: core.NewOptionalDateTime(j.OutcomeAcknowledgedAt),
	}
	return json.Marshal(marshaler)
}

func (j *Job) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The id of the workbook where extracted file data will be sent
type JobDestination = WorkbookId

// The execution plan for a job, for example, for a map job, the execution plan is the mapping of the source sheet to the destination sheet.
type JobExecutionPlan struct {
	FieldMapping              []*Edge             `json:"fieldMapping,omitempty" url:"fieldMapping,omitempty"`
	UnmappedSourceFields      []*SourceField      `json:"unmappedSourceFields,omitempty" url:"unmappedSourceFields,omitempty"`
	UnmappedDestinationFields []*DestinationField `json:"unmappedDestinationFields,omitempty" url:"unmappedDestinationFields,omitempty"`
	ProgramId                 *string             `json:"programId,omitempty" url:"programId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobExecutionPlan) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobExecutionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler JobExecutionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobExecutionPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobExecutionPlan) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The execution plan for a job, for example, for a map job, the execution plan is the mapping of the source sheet to the destination sheet.
type JobExecutionPlanConfig struct {
	FieldMapping              []*Edge             `json:"fieldMapping,omitempty" url:"fieldMapping,omitempty"`
	UnmappedSourceFields      []*SourceField      `json:"unmappedSourceFields,omitempty" url:"unmappedSourceFields,omitempty"`
	UnmappedDestinationFields []*DestinationField `json:"unmappedDestinationFields,omitempty" url:"unmappedDestinationFields,omitempty"`
	ProgramId                 *string             `json:"programId,omitempty" url:"programId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobExecutionPlanConfig) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobExecutionPlanConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler JobExecutionPlanConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobExecutionPlanConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobExecutionPlanConfig) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// the mode of the job
type JobMode string

const (
	JobModeForeground      JobMode = "foreground"
	JobModeBackground      JobMode = "background"
	JobModeToolbarBlocking JobMode = "toolbarBlocking"
)

func NewJobModeFromString(s string) (JobMode, error) {
	switch s {
	case "foreground":
		return JobModeForeground, nil
	case "background":
		return JobModeBackground, nil
	case "toolbarBlocking":
		return JobModeToolbarBlocking, nil
	}
	var t JobMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobMode) Ptr() *JobMode {
	return &j
}

// Outcome summary of a job
type JobOutcome struct {
	Acknowledge       *bool              `json:"acknowledge,omitempty" url:"acknowledge,omitempty"`
	Trigger           *JobOutcomeTrigger `json:"trigger,omitempty" url:"trigger,omitempty"`
	ButtonText        *string            `json:"buttonText,omitempty" url:"buttonText,omitempty"`
	Next              *JobOutcomeNext    `json:"next,omitempty" url:"next,omitempty"`
	Heading           *string            `json:"heading,omitempty" url:"heading,omitempty"`
	Message           *string            `json:"message,omitempty" url:"message,omitempty"`
	HideDefaultButton *bool              `json:"hideDefaultButton,omitempty" url:"hideDefaultButton,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcome) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcome) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcome
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcome(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcome) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNext struct {
	Type     string
	Id       *JobOutcomeNextId
	Url      *JobOutcomeNextUrl
	Download *JobOutcomeNextDownload
	Files    *JobOutcomeNextFiles
	Wait     *JobOutcomeNextWait
	Snapshot *JobOutcomeNextSnapshot
	Retry    *JobOutcomeNextRetry
	View     *JobOutcomeNextView
}

func NewJobOutcomeNextFromId(value *JobOutcomeNextId) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "id", Id: value}
}

func NewJobOutcomeNextFromUrl(value *JobOutcomeNextUrl) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "url", Url: value}
}

func NewJobOutcomeNextFromDownload(value *JobOutcomeNextDownload) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "download", Download: value}
}

func NewJobOutcomeNextFromFiles(value *JobOutcomeNextFiles) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "files", Files: value}
}

func NewJobOutcomeNextFromWait(value *JobOutcomeNextWait) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "wait", Wait: value}
}

func NewJobOutcomeNextFromSnapshot(value *JobOutcomeNextSnapshot) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "snapshot", Snapshot: value}
}

func NewJobOutcomeNextFromRetry(value *JobOutcomeNextRetry) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "retry", Retry: value}
}

func NewJobOutcomeNextFromView(value *JobOutcomeNextView) *JobOutcomeNext {
	return &JobOutcomeNext{Type: "view", View: value}
}

func (j *JobOutcomeNext) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", j)
	}
	switch unmarshaler.Type {
	case "id":
		value := new(JobOutcomeNextId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Id = value
	case "url":
		value := new(JobOutcomeNextUrl)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Url = value
	case "download":
		value := new(JobOutcomeNextDownload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Download = value
	case "files":
		value := new(JobOutcomeNextFiles)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Files = value
	case "wait":
		value := new(JobOutcomeNextWait)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Wait = value
	case "snapshot":
		value := new(JobOutcomeNextSnapshot)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Snapshot = value
	case "retry":
		value := new(JobOutcomeNextRetry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Retry = value
	case "view":
		value := new(JobOutcomeNextView)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.View = value
	}
	return nil
}

func (j JobOutcomeNext) MarshalJSON() ([]byte, error) {
	switch j.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "id":
		return core.MarshalJSONWithExtraProperty(j.Id, "type", "id")
	case "url":
		return core.MarshalJSONWithExtraProperty(j.Url, "type", "url")
	case "download":
		return core.MarshalJSONWithExtraProperty(j.Download, "type", "download")
	case "files":
		return core.MarshalJSONWithExtraProperty(j.Files, "type", "files")
	case "wait":
		return core.MarshalJSONWithExtraProperty(j.Wait, "type", "wait")
	case "snapshot":
		return core.MarshalJSONWithExtraProperty(j.Snapshot, "type", "snapshot")
	case "retry":
		return core.MarshalJSONWithExtraProperty(j.Retry, "type", "retry")
	case "view":
		return core.MarshalJSONWithExtraProperty(j.View, "type", "view")
	}
}

type JobOutcomeNextVisitor interface {
	VisitId(*JobOutcomeNextId) error
	VisitUrl(*JobOutcomeNextUrl) error
	VisitDownload(*JobOutcomeNextDownload) error
	VisitFiles(*JobOutcomeNextFiles) error
	VisitWait(*JobOutcomeNextWait) error
	VisitSnapshot(*JobOutcomeNextSnapshot) error
	VisitRetry(*JobOutcomeNextRetry) error
	VisitView(*JobOutcomeNextView) error
}

func (j *JobOutcomeNext) Accept(visitor JobOutcomeNextVisitor) error {
	switch j.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "id":
		return visitor.VisitId(j.Id)
	case "url":
		return visitor.VisitUrl(j.Url)
	case "download":
		return visitor.VisitDownload(j.Download)
	case "files":
		return visitor.VisitFiles(j.Files)
	case "wait":
		return visitor.VisitWait(j.Wait)
	case "snapshot":
		return visitor.VisitSnapshot(j.Snapshot)
	case "retry":
		return visitor.VisitRetry(j.Retry)
	case "view":
		return visitor.VisitView(j.View)
	}
}

type JobOutcomeNextDownload struct {
	Url      string  `json:"url" url:"url"`
	Label    *string `json:"label,omitempty" url:"label,omitempty"`
	FileName *string `json:"fileName,omitempty" url:"fileName,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextDownload) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextDownload) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextDownload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextDownload(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextDownload) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextFileObject struct {
	FileId string  `json:"fileId" url:"fileId"`
	Label  *string `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextFileObject) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextFileObject) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextFileObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextFileObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextFileObject) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextFiles struct {
	Files []*JobOutcomeNextFileObject `json:"files,omitempty" url:"files,omitempty"`
	Label *string                     `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextFiles) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextFiles) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextFiles
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextFiles(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextFiles) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextId struct {
	Id    string  `json:"id" url:"id"`
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	Path  *string `json:"path,omitempty" url:"path,omitempty"`
	Query *string `json:"query,omitempty" url:"query,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextId) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextId) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextId(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextId) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextRetry struct {
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextRetry) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextRetry) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextRetry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextRetry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextRetry) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextSnapshot struct {
	SnapshotId string `json:"snapshotId" url:"snapshotId"`
	SheetId    string `json:"sheetId" url:"sheetId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextSnapshot) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextSnapshot) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextSnapshot
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextSnapshot(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextSnapshot) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextUrl struct {
	Url   string  `json:"url" url:"url"`
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextUrl) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextUrl) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextUrl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextUrl(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextUrl) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextView struct {
	SheetId string `json:"sheetId" url:"sheetId"`
	// An array of field keys from the sheet
	HiddenColumns []string `json:"hiddenColumns,omitempty" url:"hiddenColumns,omitempty"`
	Label         *string  `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextView) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextView) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextView
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextView(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextView) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeNextWait struct {
	Fade     *bool `json:"fade,omitempty" url:"fade,omitempty"`
	Confetti *bool `json:"confetti,omitempty" url:"confetti,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeNextWait) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeNextWait) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeNextWait
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeNextWait(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeNextWait) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobOutcomeTrigger struct {
	JobOutcomeTriggerType    JobOutcomeTriggerType
	JobOutcomeTriggerDetails *JobOutcomeTriggerDetails

	typ string
}

func NewJobOutcomeTriggerFromJobOutcomeTriggerType(value JobOutcomeTriggerType) *JobOutcomeTrigger {
	return &JobOutcomeTrigger{typ: "JobOutcomeTriggerType", JobOutcomeTriggerType: value}
}

func NewJobOutcomeTriggerFromJobOutcomeTriggerDetails(value *JobOutcomeTriggerDetails) *JobOutcomeTrigger {
	return &JobOutcomeTrigger{typ: "JobOutcomeTriggerDetails", JobOutcomeTriggerDetails: value}
}

func (j *JobOutcomeTrigger) UnmarshalJSON(data []byte) error {
	var valueJobOutcomeTriggerType JobOutcomeTriggerType
	if err := json.Unmarshal(data, &valueJobOutcomeTriggerType); err == nil {
		j.typ = "JobOutcomeTriggerType"
		j.JobOutcomeTriggerType = valueJobOutcomeTriggerType
		return nil
	}
	valueJobOutcomeTriggerDetails := new(JobOutcomeTriggerDetails)
	if err := json.Unmarshal(data, &valueJobOutcomeTriggerDetails); err == nil {
		j.typ = "JobOutcomeTriggerDetails"
		j.JobOutcomeTriggerDetails = valueJobOutcomeTriggerDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobOutcomeTrigger) MarshalJSON() ([]byte, error) {
	if j.typ == "JobOutcomeTriggerType" || j.JobOutcomeTriggerType != "" {
		return json.Marshal(j.JobOutcomeTriggerType)
	}
	if j.typ == "JobOutcomeTriggerDetails" || j.JobOutcomeTriggerDetails != nil {
		return json.Marshal(j.JobOutcomeTriggerDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobOutcomeTriggerVisitor interface {
	VisitJobOutcomeTriggerType(JobOutcomeTriggerType) error
	VisitJobOutcomeTriggerDetails(*JobOutcomeTriggerDetails) error
}

func (j *JobOutcomeTrigger) Accept(visitor JobOutcomeTriggerVisitor) error {
	if j.typ == "JobOutcomeTriggerType" || j.JobOutcomeTriggerType != "" {
		return visitor.VisitJobOutcomeTriggerType(j.JobOutcomeTriggerType)
	}
	if j.typ == "JobOutcomeTriggerDetails" || j.JobOutcomeTriggerDetails != nil {
		return visitor.VisitJobOutcomeTriggerDetails(j.JobOutcomeTriggerDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// For whom the job outcome's next effect should be triggered automatically
type JobOutcomeTriggerAudience string

const (
	JobOutcomeTriggerAudienceOriginator JobOutcomeTriggerAudience = "originator"
	JobOutcomeTriggerAudienceAll        JobOutcomeTriggerAudience = "all"
)

func NewJobOutcomeTriggerAudienceFromString(s string) (JobOutcomeTriggerAudience, error) {
	switch s {
	case "originator":
		return JobOutcomeTriggerAudienceOriginator, nil
	case "all":
		return JobOutcomeTriggerAudienceAll, nil
	}
	var t JobOutcomeTriggerAudience
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobOutcomeTriggerAudience) Ptr() *JobOutcomeTriggerAudience {
	return &j
}

// Details about the trigger for the job outcome
type JobOutcomeTriggerDetails struct {
	Type     JobOutcomeTriggerType      `json:"type" url:"type"`
	Audience *JobOutcomeTriggerAudience `json:"audience,omitempty" url:"audience,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobOutcomeTriggerDetails) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobOutcomeTriggerDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler JobOutcomeTriggerDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobOutcomeTriggerDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobOutcomeTriggerDetails) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// Whether a job outcome's effect should be triggered automatically
type JobOutcomeTriggerType string

const (
	JobOutcomeTriggerTypeManual          JobOutcomeTriggerType = "manual"
	JobOutcomeTriggerTypeAutomatic       JobOutcomeTriggerType = "automatic"
	JobOutcomeTriggerTypeAutomaticSilent JobOutcomeTriggerType = "automatic_silent"
)

func NewJobOutcomeTriggerTypeFromString(s string) (JobOutcomeTriggerType, error) {
	switch s {
	case "manual":
		return JobOutcomeTriggerTypeManual, nil
	case "automatic":
		return JobOutcomeTriggerTypeAutomatic, nil
	case "automatic_silent":
		return JobOutcomeTriggerTypeAutomaticSilent, nil
	}
	var t JobOutcomeTriggerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobOutcomeTriggerType) Ptr() *JobOutcomeTriggerType {
	return &j
}

type JobPartExecution string

const (
	JobPartExecutionSequential JobPartExecution = "sequential"
	JobPartExecutionParallel   JobPartExecution = "parallel"
)

func NewJobPartExecutionFromString(s string) (JobPartExecution, error) {
	switch s {
	case "sequential":
		return JobPartExecutionSequential, nil
	case "parallel":
		return JobPartExecutionParallel, nil
	}
	var t JobPartExecution
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobPartExecution) Ptr() *JobPartExecution {
	return &j
}

// Info about the number of parts to create
type JobParts struct {
	Integer       int
	JobPartsArray JobPartsArray

	typ string
}

func NewJobPartsFromInteger(value int) *JobParts {
	return &JobParts{typ: "Integer", Integer: value}
}

func NewJobPartsFromJobPartsArray(value JobPartsArray) *JobParts {
	return &JobParts{typ: "JobPartsArray", JobPartsArray: value}
}

func (j *JobParts) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		j.typ = "Integer"
		j.Integer = valueInteger
		return nil
	}
	var valueJobPartsArray JobPartsArray
	if err := json.Unmarshal(data, &valueJobPartsArray); err == nil {
		j.typ = "JobPartsArray"
		j.JobPartsArray = valueJobPartsArray
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobParts) MarshalJSON() ([]byte, error) {
	if j.typ == "Integer" || j.Integer != 0 {
		return json.Marshal(j.Integer)
	}
	if j.typ == "JobPartsArray" || j.JobPartsArray != nil {
		return json.Marshal(j.JobPartsArray)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobPartsVisitor interface {
	VisitInteger(int) error
	VisitJobPartsArray(JobPartsArray) error
}

func (j *JobParts) Accept(visitor JobPartsVisitor) error {
	if j.typ == "Integer" || j.Integer != 0 {
		return visitor.VisitInteger(j.Integer)
	}
	if j.typ == "JobPartsArray" || j.JobPartsArray != nil {
		return visitor.VisitJobPartsArray(j.JobPartsArray)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// Data for each of the job parts
type JobPartsArray = []map[string]interface{}

// The job/plan tuple that contains the full plan and the jobs status
type JobPlan struct {
	Job  *Job              `json:"job,omitempty" url:"job,omitempty"`
	Plan *JobExecutionPlan `json:"plan,omitempty" url:"plan,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobPlan) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler JobPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobPlan) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The id of a file, workbook, sheet, or app
type JobSource = string

// the status of the job
type JobStatus string

const (
	JobStatusCreated   JobStatus = "created"
	JobStatusPlanning  JobStatus = "planning"
	JobStatusScheduled JobStatus = "scheduled"
	JobStatusReady     JobStatus = "ready"
	JobStatusExecuting JobStatus = "executing"
	JobStatusComplete  JobStatus = "complete"
	JobStatusFailed    JobStatus = "failed"
	JobStatusCanceled  JobStatus = "canceled"
	JobStatusWaiting   JobStatus = "waiting"
)

func NewJobStatusFromString(s string) (JobStatus, error) {
	switch s {
	case "created":
		return JobStatusCreated, nil
	case "planning":
		return JobStatusPlanning, nil
	case "scheduled":
		return JobStatusScheduled, nil
	case "ready":
		return JobStatusReady, nil
	case "executing":
		return JobStatusExecuting, nil
	case "complete":
		return JobStatusComplete, nil
	case "failed":
		return JobStatusFailed, nil
	case "canceled":
		return JobStatusCanceled, nil
	case "waiting":
		return JobStatusWaiting, nil
	}
	var t JobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobStatus) Ptr() *JobStatus {
	return &j
}

// Subject parameters for this job type
type JobSubject struct {
	Type       string
	Resource   *ResourceJobSubject
	Collection *CollectionJobSubject
}

func NewJobSubjectFromResource(value *ResourceJobSubject) *JobSubject {
	return &JobSubject{Type: "resource", Resource: value}
}

func NewJobSubjectFromCollection(value *CollectionJobSubject) *JobSubject {
	return &JobSubject{Type: "collection", Collection: value}
}

func (j *JobSubject) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", j)
	}
	switch unmarshaler.Type {
	case "resource":
		value := new(ResourceJobSubject)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Resource = value
	case "collection":
		value := new(CollectionJobSubject)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Collection = value
	}
	return nil
}

func (j JobSubject) MarshalJSON() ([]byte, error) {
	switch j.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "resource":
		return core.MarshalJSONWithExtraProperty(j.Resource, "type", "resource")
	case "collection":
		return core.MarshalJSONWithExtraProperty(j.Collection, "type", "collection")
	}
}

type JobSubjectVisitor interface {
	VisitResource(*ResourceJobSubject) error
	VisitCollection(*CollectionJobSubject) error
}

func (j *JobSubject) Accept(visitor JobSubjectVisitor) error {
	switch j.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", j.Type, j)
	case "resource":
		return visitor.VisitResource(j.Resource)
	case "collection":
		return visitor.VisitCollection(j.Collection)
	}
}

// The type of job
type JobType string

const (
	JobTypeFile     JobType = "file"
	JobTypeWorkbook JobType = "workbook"
	JobTypeSheet    JobType = "sheet"
	JobTypeSpace    JobType = "space"
	JobTypeDocument JobType = "document"
	JobTypeApp      JobType = "app"
)

func NewJobTypeFromString(s string) (JobType, error) {
	switch s {
	case "file":
		return JobTypeFile, nil
	case "workbook":
		return JobTypeWorkbook, nil
	case "sheet":
		return JobTypeSheet, nil
	case "space":
		return JobTypeSpace, nil
	case "document":
		return JobTypeDocument, nil
	case "app":
		return JobTypeApp, nil
	}
	var t JobType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobType) Ptr() *JobType {
	return &j
}

type JobUpdateConfig struct {
	DeleteRecordsJobConfig                  *DeleteRecordsJobConfig
	FileJobConfig                           *FileJobConfig
	PipelineJobConfig                       *PipelineJobConfig
	ExportJobConfig                         *ExportJobConfig
	MutateJobConfig                         *MutateJobConfig
	FindAndReplaceJobConfig                 *FindAndReplaceJobConfig
	MappingProgramJobConfig                 *MappingProgramJobConfig
	AiGenerateBlueprintJobConfig            *AiGenerateBlueprintJobConfig
	AppAutobuildDeployJobConfig             *AppAutobuildDeployJobConfig
	AiGenerateSampleDataJobConfig           *AiGenerateSampleDataJobConfig
	AiGenerateBlueprintConstraintsJobConfig *AiGenerateBlueprintConstraintsJobConfig
	AiGenerateConstraintJobConfig           *AiGenerateConstraintJobConfig
	AiRuleCreationJobConfig                 *AiRuleCreationJobConfig
	EmptyObject                             *EmptyObject

	typ string
}

func NewJobUpdateConfigFromDeleteRecordsJobConfig(value *DeleteRecordsJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "DeleteRecordsJobConfig", DeleteRecordsJobConfig: value}
}

func NewJobUpdateConfigFromFileJobConfig(value *FileJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "FileJobConfig", FileJobConfig: value}
}

func NewJobUpdateConfigFromPipelineJobConfig(value *PipelineJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "PipelineJobConfig", PipelineJobConfig: value}
}

func NewJobUpdateConfigFromExportJobConfig(value *ExportJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "ExportJobConfig", ExportJobConfig: value}
}

func NewJobUpdateConfigFromMutateJobConfig(value *MutateJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "MutateJobConfig", MutateJobConfig: value}
}

func NewJobUpdateConfigFromFindAndReplaceJobConfig(value *FindAndReplaceJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "FindAndReplaceJobConfig", FindAndReplaceJobConfig: value}
}

func NewJobUpdateConfigFromMappingProgramJobConfig(value *MappingProgramJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "MappingProgramJobConfig", MappingProgramJobConfig: value}
}

func NewJobUpdateConfigFromAiGenerateBlueprintJobConfig(value *AiGenerateBlueprintJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "AiGenerateBlueprintJobConfig", AiGenerateBlueprintJobConfig: value}
}

func NewJobUpdateConfigFromAppAutobuildDeployJobConfig(value *AppAutobuildDeployJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "AppAutobuildDeployJobConfig", AppAutobuildDeployJobConfig: value}
}

func NewJobUpdateConfigFromAiGenerateSampleDataJobConfig(value *AiGenerateSampleDataJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "AiGenerateSampleDataJobConfig", AiGenerateSampleDataJobConfig: value}
}

func NewJobUpdateConfigFromAiGenerateBlueprintConstraintsJobConfig(value *AiGenerateBlueprintConstraintsJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "AiGenerateBlueprintConstraintsJobConfig", AiGenerateBlueprintConstraintsJobConfig: value}
}

func NewJobUpdateConfigFromAiGenerateConstraintJobConfig(value *AiGenerateConstraintJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "AiGenerateConstraintJobConfig", AiGenerateConstraintJobConfig: value}
}

func NewJobUpdateConfigFromAiRuleCreationJobConfig(value *AiRuleCreationJobConfig) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "AiRuleCreationJobConfig", AiRuleCreationJobConfig: value}
}

func NewJobUpdateConfigFromEmptyObject(value *EmptyObject) *JobUpdateConfig {
	return &JobUpdateConfig{typ: "EmptyObject", EmptyObject: value}
}

func (j *JobUpdateConfig) UnmarshalJSON(data []byte) error {
	valueDeleteRecordsJobConfig := new(DeleteRecordsJobConfig)
	if err := json.Unmarshal(data, &valueDeleteRecordsJobConfig); err == nil {
		j.typ = "DeleteRecordsJobConfig"
		j.DeleteRecordsJobConfig = valueDeleteRecordsJobConfig
		return nil
	}
	valueFileJobConfig := new(FileJobConfig)
	if err := json.Unmarshal(data, &valueFileJobConfig); err == nil {
		j.typ = "FileJobConfig"
		j.FileJobConfig = valueFileJobConfig
		return nil
	}
	valuePipelineJobConfig := new(PipelineJobConfig)
	if err := json.Unmarshal(data, &valuePipelineJobConfig); err == nil {
		j.typ = "PipelineJobConfig"
		j.PipelineJobConfig = valuePipelineJobConfig
		return nil
	}
	valueExportJobConfig := new(ExportJobConfig)
	if err := json.Unmarshal(data, &valueExportJobConfig); err == nil {
		j.typ = "ExportJobConfig"
		j.ExportJobConfig = valueExportJobConfig
		return nil
	}
	valueMutateJobConfig := new(MutateJobConfig)
	if err := json.Unmarshal(data, &valueMutateJobConfig); err == nil {
		j.typ = "MutateJobConfig"
		j.MutateJobConfig = valueMutateJobConfig
		return nil
	}
	valueFindAndReplaceJobConfig := new(FindAndReplaceJobConfig)
	if err := json.Unmarshal(data, &valueFindAndReplaceJobConfig); err == nil {
		j.typ = "FindAndReplaceJobConfig"
		j.FindAndReplaceJobConfig = valueFindAndReplaceJobConfig
		return nil
	}
	valueMappingProgramJobConfig := new(MappingProgramJobConfig)
	if err := json.Unmarshal(data, &valueMappingProgramJobConfig); err == nil {
		j.typ = "MappingProgramJobConfig"
		j.MappingProgramJobConfig = valueMappingProgramJobConfig
		return nil
	}
	valueAiGenerateBlueprintJobConfig := new(AiGenerateBlueprintJobConfig)
	if err := json.Unmarshal(data, &valueAiGenerateBlueprintJobConfig); err == nil {
		j.typ = "AiGenerateBlueprintJobConfig"
		j.AiGenerateBlueprintJobConfig = valueAiGenerateBlueprintJobConfig
		return nil
	}
	valueAppAutobuildDeployJobConfig := new(AppAutobuildDeployJobConfig)
	if err := json.Unmarshal(data, &valueAppAutobuildDeployJobConfig); err == nil {
		j.typ = "AppAutobuildDeployJobConfig"
		j.AppAutobuildDeployJobConfig = valueAppAutobuildDeployJobConfig
		return nil
	}
	valueAiGenerateSampleDataJobConfig := new(AiGenerateSampleDataJobConfig)
	if err := json.Unmarshal(data, &valueAiGenerateSampleDataJobConfig); err == nil {
		j.typ = "AiGenerateSampleDataJobConfig"
		j.AiGenerateSampleDataJobConfig = valueAiGenerateSampleDataJobConfig
		return nil
	}
	valueAiGenerateBlueprintConstraintsJobConfig := new(AiGenerateBlueprintConstraintsJobConfig)
	if err := json.Unmarshal(data, &valueAiGenerateBlueprintConstraintsJobConfig); err == nil {
		j.typ = "AiGenerateBlueprintConstraintsJobConfig"
		j.AiGenerateBlueprintConstraintsJobConfig = valueAiGenerateBlueprintConstraintsJobConfig
		return nil
	}
	valueAiGenerateConstraintJobConfig := new(AiGenerateConstraintJobConfig)
	if err := json.Unmarshal(data, &valueAiGenerateConstraintJobConfig); err == nil {
		j.typ = "AiGenerateConstraintJobConfig"
		j.AiGenerateConstraintJobConfig = valueAiGenerateConstraintJobConfig
		return nil
	}
	valueAiRuleCreationJobConfig := new(AiRuleCreationJobConfig)
	if err := json.Unmarshal(data, &valueAiRuleCreationJobConfig); err == nil {
		j.typ = "AiRuleCreationJobConfig"
		j.AiRuleCreationJobConfig = valueAiRuleCreationJobConfig
		return nil
	}
	valueEmptyObject := new(EmptyObject)
	if err := json.Unmarshal(data, &valueEmptyObject); err == nil {
		j.typ = "EmptyObject"
		j.EmptyObject = valueEmptyObject
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobUpdateConfig) MarshalJSON() ([]byte, error) {
	if j.typ == "DeleteRecordsJobConfig" || j.DeleteRecordsJobConfig != nil {
		return json.Marshal(j.DeleteRecordsJobConfig)
	}
	if j.typ == "FileJobConfig" || j.FileJobConfig != nil {
		return json.Marshal(j.FileJobConfig)
	}
	if j.typ == "PipelineJobConfig" || j.PipelineJobConfig != nil {
		return json.Marshal(j.PipelineJobConfig)
	}
	if j.typ == "ExportJobConfig" || j.ExportJobConfig != nil {
		return json.Marshal(j.ExportJobConfig)
	}
	if j.typ == "MutateJobConfig" || j.MutateJobConfig != nil {
		return json.Marshal(j.MutateJobConfig)
	}
	if j.typ == "FindAndReplaceJobConfig" || j.FindAndReplaceJobConfig != nil {
		return json.Marshal(j.FindAndReplaceJobConfig)
	}
	if j.typ == "MappingProgramJobConfig" || j.MappingProgramJobConfig != nil {
		return json.Marshal(j.MappingProgramJobConfig)
	}
	if j.typ == "AiGenerateBlueprintJobConfig" || j.AiGenerateBlueprintJobConfig != nil {
		return json.Marshal(j.AiGenerateBlueprintJobConfig)
	}
	if j.typ == "AppAutobuildDeployJobConfig" || j.AppAutobuildDeployJobConfig != nil {
		return json.Marshal(j.AppAutobuildDeployJobConfig)
	}
	if j.typ == "AiGenerateSampleDataJobConfig" || j.AiGenerateSampleDataJobConfig != nil {
		return json.Marshal(j.AiGenerateSampleDataJobConfig)
	}
	if j.typ == "AiGenerateBlueprintConstraintsJobConfig" || j.AiGenerateBlueprintConstraintsJobConfig != nil {
		return json.Marshal(j.AiGenerateBlueprintConstraintsJobConfig)
	}
	if j.typ == "AiGenerateConstraintJobConfig" || j.AiGenerateConstraintJobConfig != nil {
		return json.Marshal(j.AiGenerateConstraintJobConfig)
	}
	if j.typ == "AiRuleCreationJobConfig" || j.AiRuleCreationJobConfig != nil {
		return json.Marshal(j.AiRuleCreationJobConfig)
	}
	if j.typ == "EmptyObject" || j.EmptyObject != nil {
		return json.Marshal(j.EmptyObject)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobUpdateConfigVisitor interface {
	VisitDeleteRecordsJobConfig(*DeleteRecordsJobConfig) error
	VisitFileJobConfig(*FileJobConfig) error
	VisitPipelineJobConfig(*PipelineJobConfig) error
	VisitExportJobConfig(*ExportJobConfig) error
	VisitMutateJobConfig(*MutateJobConfig) error
	VisitFindAndReplaceJobConfig(*FindAndReplaceJobConfig) error
	VisitMappingProgramJobConfig(*MappingProgramJobConfig) error
	VisitAiGenerateBlueprintJobConfig(*AiGenerateBlueprintJobConfig) error
	VisitAppAutobuildDeployJobConfig(*AppAutobuildDeployJobConfig) error
	VisitAiGenerateSampleDataJobConfig(*AiGenerateSampleDataJobConfig) error
	VisitAiGenerateBlueprintConstraintsJobConfig(*AiGenerateBlueprintConstraintsJobConfig) error
	VisitAiGenerateConstraintJobConfig(*AiGenerateConstraintJobConfig) error
	VisitAiRuleCreationJobConfig(*AiRuleCreationJobConfig) error
	VisitEmptyObject(*EmptyObject) error
}

func (j *JobUpdateConfig) Accept(visitor JobUpdateConfigVisitor) error {
	if j.typ == "DeleteRecordsJobConfig" || j.DeleteRecordsJobConfig != nil {
		return visitor.VisitDeleteRecordsJobConfig(j.DeleteRecordsJobConfig)
	}
	if j.typ == "FileJobConfig" || j.FileJobConfig != nil {
		return visitor.VisitFileJobConfig(j.FileJobConfig)
	}
	if j.typ == "PipelineJobConfig" || j.PipelineJobConfig != nil {
		return visitor.VisitPipelineJobConfig(j.PipelineJobConfig)
	}
	if j.typ == "ExportJobConfig" || j.ExportJobConfig != nil {
		return visitor.VisitExportJobConfig(j.ExportJobConfig)
	}
	if j.typ == "MutateJobConfig" || j.MutateJobConfig != nil {
		return visitor.VisitMutateJobConfig(j.MutateJobConfig)
	}
	if j.typ == "FindAndReplaceJobConfig" || j.FindAndReplaceJobConfig != nil {
		return visitor.VisitFindAndReplaceJobConfig(j.FindAndReplaceJobConfig)
	}
	if j.typ == "MappingProgramJobConfig" || j.MappingProgramJobConfig != nil {
		return visitor.VisitMappingProgramJobConfig(j.MappingProgramJobConfig)
	}
	if j.typ == "AiGenerateBlueprintJobConfig" || j.AiGenerateBlueprintJobConfig != nil {
		return visitor.VisitAiGenerateBlueprintJobConfig(j.AiGenerateBlueprintJobConfig)
	}
	if j.typ == "AppAutobuildDeployJobConfig" || j.AppAutobuildDeployJobConfig != nil {
		return visitor.VisitAppAutobuildDeployJobConfig(j.AppAutobuildDeployJobConfig)
	}
	if j.typ == "AiGenerateSampleDataJobConfig" || j.AiGenerateSampleDataJobConfig != nil {
		return visitor.VisitAiGenerateSampleDataJobConfig(j.AiGenerateSampleDataJobConfig)
	}
	if j.typ == "AiGenerateBlueprintConstraintsJobConfig" || j.AiGenerateBlueprintConstraintsJobConfig != nil {
		return visitor.VisitAiGenerateBlueprintConstraintsJobConfig(j.AiGenerateBlueprintConstraintsJobConfig)
	}
	if j.typ == "AiGenerateConstraintJobConfig" || j.AiGenerateConstraintJobConfig != nil {
		return visitor.VisitAiGenerateConstraintJobConfig(j.AiGenerateConstraintJobConfig)
	}
	if j.typ == "AiRuleCreationJobConfig" || j.AiRuleCreationJobConfig != nil {
		return visitor.VisitAiRuleCreationJobConfig(j.AiRuleCreationJobConfig)
	}
	if j.typ == "EmptyObject" || j.EmptyObject != nil {
		return visitor.VisitEmptyObject(j.EmptyObject)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type MappingProgramJobConfig struct {
	SourceSheetId      SheetId                  `json:"sourceSheetId" url:"sourceSheetId"`
	DestinationSheetId SheetId                  `json:"destinationSheetId" url:"destinationSheetId"`
	MappingRules       []map[string]interface{} `json:"mappingRules,omitempty" url:"mappingRules,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MappingProgramJobConfig) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MappingProgramJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler MappingProgramJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MappingProgramJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MappingProgramJobConfig) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Metadata struct {
	Certainty  *Certainty `json:"certainty,omitempty" url:"certainty,omitempty"`
	Confidence *float64   `json:"confidence,omitempty" url:"confidence,omitempty"`
	Source     *string    `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Metadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type unmarshaler Metadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PipelineJobConfig struct {
	SourceSheetId      SheetId `json:"sourceSheetId" url:"sourceSheetId"`
	DestinationSheetId SheetId `json:"destinationSheetId" url:"destinationSheetId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PipelineJobConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PipelineJobConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PipelineJobConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PipelineJobConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PipelineJobConfig) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResourceJobSubject struct {
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResourceJobSubject) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResourceJobSubject) UnmarshalJSON(data []byte) error {
	type unmarshaler ResourceJobSubject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResourceJobSubject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResourceJobSubject) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SourceField struct {
	// The description of the source field
	SourceField *Property `json:"sourceField,omitempty" url:"sourceField,omitempty"`
	// A list of preview values of the data in the source field
	Preview []string `json:"preview,omitempty" url:"preview,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SourceField) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceField) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceField) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The type of trigger to use for this job
type Trigger string

const (
	TriggerManual    Trigger = "manual"
	TriggerImmediate Trigger = "immediate"
)

func NewTriggerFromString(s string) (Trigger, error) {
	switch s {
	case "manual":
		return TriggerManual, nil
	case "immediate":
		return TriggerImmediate, nil
	}
	var t Trigger
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t Trigger) Ptr() *Trigger {
	return &t
}

type MappingRule struct {
	// Name of the mapping rule
	Name   string      `json:"name" url:"name"`
	Type   string      `json:"type" url:"type"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`
	// Time the mapping rule was last updated
	AcceptedAt *time.Time `json:"acceptedAt,omitempty" url:"acceptedAt,omitempty"`
	// User ID of the contributor of the mapping rule
	AcceptedBy *UserId `json:"acceptedBy,omitempty" url:"acceptedBy,omitempty"`
	// Metadata of the mapping rule
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of the mapping rule
	Id MappingId `json:"id" url:"id"`
	// Confidence of the mapping rule
	Confidence *int `json:"confidence,omitempty" url:"confidence,omitempty"`
	// User ID of the user who suggested the mapping rule
	CreatedBy *UserId `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Time the mapping rule was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Time the mapping rule was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Time the mapping rule was deleted
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MappingRule) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MappingRule) UnmarshalJSON(data []byte) error {
	type embed MappingRule
	var unmarshaler = struct {
		embed
		AcceptedAt *core.DateTime `json:"acceptedAt,omitempty"`
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		DeletedAt  *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MappingRule(unmarshaler.embed)
	m.AcceptedAt = unmarshaler.AcceptedAt.TimePtr()
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	m.DeletedAt = unmarshaler.DeletedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MappingRule) MarshalJSON() ([]byte, error) {
	type embed MappingRule
	var marshaler = struct {
		embed
		AcceptedAt *core.DateTime `json:"acceptedAt,omitempty"`
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		DeletedAt  *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed:      embed(*m),
		AcceptedAt: core.NewOptionalDateTime(m.AcceptedAt),
		CreatedAt:  core.NewDateTime(m.CreatedAt),
		UpdatedAt:  core.NewDateTime(m.UpdatedAt),
		DeletedAt:  core.NewOptionalDateTime(m.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (m *MappingRule) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MappingRuleOrConfig struct {
	// Name of the mapping rule
	Name   string      `json:"name" url:"name"`
	Type   string      `json:"type" url:"type"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`
	// Time the mapping rule was last updated
	AcceptedAt *time.Time `json:"acceptedAt,omitempty" url:"acceptedAt,omitempty"`
	// User ID of the contributor of the mapping rule
	AcceptedBy *UserId `json:"acceptedBy,omitempty" url:"acceptedBy,omitempty"`
	// Metadata of the mapping rule
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of the mapping rule
	Id *MappingId `json:"id,omitempty" url:"id,omitempty"`
	// Confidence of the mapping rule
	Confidence *int `json:"confidence,omitempty" url:"confidence,omitempty"`
	// User ID of the creator of the mapping rule
	CreatedBy *UserId `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Time the mapping rule was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// Time the mapping rule was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// Time the mapping rule was deleted
	DeletedAt *time.Time `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MappingRuleOrConfig) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MappingRuleOrConfig) UnmarshalJSON(data []byte) error {
	type embed MappingRuleOrConfig
	var unmarshaler = struct {
		embed
		AcceptedAt *core.DateTime `json:"acceptedAt,omitempty"`
		CreatedAt  *core.DateTime `json:"createdAt,omitempty"`
		UpdatedAt  *core.DateTime `json:"updatedAt,omitempty"`
		DeletedAt  *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MappingRuleOrConfig(unmarshaler.embed)
	m.AcceptedAt = unmarshaler.AcceptedAt.TimePtr()
	m.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	m.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	m.DeletedAt = unmarshaler.DeletedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MappingRuleOrConfig) MarshalJSON() ([]byte, error) {
	type embed MappingRuleOrConfig
	var marshaler = struct {
		embed
		AcceptedAt *core.DateTime `json:"acceptedAt,omitempty"`
		CreatedAt  *core.DateTime `json:"createdAt,omitempty"`
		UpdatedAt  *core.DateTime `json:"updatedAt,omitempty"`
		DeletedAt  *core.DateTime `json:"deletedAt,omitempty"`
	}{
		embed:      embed(*m),
		AcceptedAt: core.NewOptionalDateTime(m.AcceptedAt),
		CreatedAt:  core.NewOptionalDateTime(m.CreatedAt),
		UpdatedAt:  core.NewOptionalDateTime(m.UpdatedAt),
		DeletedAt:  core.NewOptionalDateTime(m.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (m *MappingRuleOrConfig) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Program struct {
	// Mapping rules
	Rules []*MappingRuleOrConfig `json:"rules,omitempty" url:"rules,omitempty"`
	// If this program was saved, this is the ID of the program
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Namespace of the program
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Family ID of the program, if it belongs to a family
	FamilyId *FamilyId `json:"familyId,omitempty" url:"familyId,omitempty"`
	// If this program was saved, this is the time it was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// If this program was saved, this is the user ID of the creator
	CreatedBy *UserId `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Source keys
	SourceKeys []string `json:"sourceKeys,omitempty" url:"sourceKeys,omitempty"`
	// Destination keys
	DestinationKeys []string `json:"destinationKeys,omitempty" url:"destinationKeys,omitempty"`
	// Summary of the mapping rules
	Summary *ProgramSummary `json:"summary,omitempty" url:"summary,omitempty"`
	// If this program was saved, this token allows you to modify the program
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Program) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Program) UnmarshalJSON(data []byte) error {
	type embed Program
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Program(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Program) MarshalJSON() ([]byte, error) {
	type embed Program
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*p),
		CreatedAt: core.NewOptionalDateTime(p.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *Program) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProgramSummary struct {
	// Total number of mapping rules
	TotalRuleCount int `json:"totalRuleCount" url:"totalRuleCount"`
	// Number of mapping rules added
	AddedRuleCount int `json:"addedRuleCount" url:"addedRuleCount"`
	// Number of mapping rules deleted
	DeletedRuleCount int `json:"deletedRuleCount" url:"deletedRuleCount"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProgramSummary) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProgramSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler ProgramSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProgramSummary(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProgramSummary) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ArrayableProperty struct {
	// Will allow multiple values and store as an array
	IsArray *bool `json:"isArray,omitempty" url:"isArray,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ArrayableProperty) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ArrayableProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ArrayableProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArrayableProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArrayableProperty) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BaseProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BaseProperty) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseProperty) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A `true` or `false` value type. Matching engines should attempt to resolve all common ways of representing this value and it should usually be displayed as a checkbox.
type BooleanProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string               `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string               `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *BooleanPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BooleanProperty) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanProperty) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BooleanPropertyConfig struct {
	// Allow a neither true or false state to be stored as `null`
	AllowIndeterminate bool `json:"allowIndeterminate" url:"allowIndeterminate"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BooleanPropertyConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanPropertyConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanPropertyConfig) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Constraint struct {
	Type     string
	Required interface{}
	Unique   *UniqueConstraint
	Computed interface{}
	External *ExternalConstraint
	Stored   *StoredConstraint
}

func NewConstraintFromRequired(value interface{}) *Constraint {
	return &Constraint{Type: "required", Required: value}
}

func NewConstraintFromUnique(value *UniqueConstraint) *Constraint {
	return &Constraint{Type: "unique", Unique: value}
}

func NewConstraintFromComputed(value interface{}) *Constraint {
	return &Constraint{Type: "computed", Computed: value}
}

func NewConstraintFromExternal(value *ExternalConstraint) *Constraint {
	return &Constraint{Type: "external", External: value}
}

func NewConstraintFromStored(value *StoredConstraint) *Constraint {
	return &Constraint{Type: "stored", Stored: value}
}

func (c *Constraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "required":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Required = value
	case "unique":
		value := new(UniqueConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Unique = value
	case "computed":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Computed = value
	case "external":
		value := new(ExternalConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.External = value
	case "stored":
		value := new(StoredConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Stored = value
	}
	return nil
}

func (c Constraint) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "required":
		var marshaler = struct {
			Type     string      `json:"type"`
			Required interface{} `json:"required,omitempty"`
		}{
			Type:     "required",
			Required: c.Required,
		}
		return json.Marshal(marshaler)
	case "unique":
		return core.MarshalJSONWithExtraProperty(c.Unique, "type", "unique")
	case "computed":
		var marshaler = struct {
			Type     string      `json:"type"`
			Computed interface{} `json:"computed,omitempty"`
		}{
			Type:     "computed",
			Computed: c.Computed,
		}
		return json.Marshal(marshaler)
	case "external":
		return core.MarshalJSONWithExtraProperty(c.External, "type", "external")
	case "stored":
		return core.MarshalJSONWithExtraProperty(c.Stored, "type", "stored")
	}
}

type ConstraintVisitor interface {
	VisitRequired(interface{}) error
	VisitUnique(*UniqueConstraint) error
	VisitComputed(interface{}) error
	VisitExternal(*ExternalConstraint) error
	VisitStored(*StoredConstraint) error
}

func (c *Constraint) Accept(visitor ConstraintVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "required":
		return visitor.VisitRequired(c.Required)
	case "unique":
		return visitor.VisitUnique(c.Unique)
	case "computed":
		return visitor.VisitComputed(c.Computed)
	case "external":
		return visitor.VisitExternal(c.External)
	case "stored":
		return visitor.VisitStored(c.Stored)
	}
}

// Store a field as a GMT date. Data hooks must convert this value into a `YYYY-MM-DD` format in order for it to be considered a valid value. Datetime should be a separate and future supported value as it must consider timezone.
type DateProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DateProperty) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler DateProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateProperty) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines an array of values selected from an enumerated list of options. Matching tooling attempts to resolve incoming data assigment to a valid option. The maximum number of items that can be in this list is `100`.
type EnumListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string            `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string            `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *EnumPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumListProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumListProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumListProperty) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Defines an enumerated list of options for the user to select from. Matching tooling attempts to resolve incoming data assigment to a valid option. The maximum number of options for this list is `100`. For larger lists, users should use the reference or future `lookup` types.
type EnumProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool `json:"isArray,omitempty" url:"isArray,omitempty"`
	// Will allow multiple values and store / provide the values in an array if set. Not all field types support arrays.
	Multi  *bool               `json:"multi,omitempty" url:"multi,omitempty"`
	Config *EnumPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumProperty) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertyConfig struct {
	// Permit the user to create new options for this specific field.
	AllowCustom *bool                 `json:"allowCustom,omitempty" url:"allowCustom,omitempty"`
	Options     []*EnumPropertyOption `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumPropertyConfig) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumPropertyConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumPropertyConfig) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertyOption struct {
	// A visual label for this option, defaults to value if not provided
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// An optional color to assign this option
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// A reference pointer to a previously registered icon
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// An arbitrary JSON object to be associated with this option and made available to hooks
	Meta map[string]interface{} `json:"meta,omitempty" url:"meta,omitempty"`
	// The value or ID of this option. This value will be sent in egress. The type is a string | integer | boolean.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Alternative names to match this enum option to
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnumPropertyOption) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumPropertyOption) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumPropertyOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumPropertyOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumPropertyOption) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalConstraint struct {
	Validator string      `json:"validator" url:"validator"`
	Config    interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExternalConstraint) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalConstraint) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Control the appearance of this field when it's displayed in a table or input
type FieldAppearance struct {
	Size *FieldSize `json:"size,omitempty" url:"size,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FieldAppearance) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldAppearance) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldAppearance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldAppearance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldAppearance) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The default visual sizing. This sizing may be overridden by a user
type FieldSize string

const (
	FieldSizeXs FieldSize = "xs"
	FieldSizeS  FieldSize = "s"
	FieldSizeM  FieldSize = "m"
	FieldSizeL  FieldSize = "l"
	FieldSizeXl FieldSize = "xl"
)

func NewFieldSizeFromString(s string) (FieldSize, error) {
	switch s {
	case "xs":
		return FieldSizeXs, nil
	case "s":
		return FieldSizeS, nil
	case "m":
		return FieldSizeM, nil
	case "l":
		return FieldSizeL, nil
	case "xl":
		return FieldSizeXl, nil
	}
	var t FieldSize
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldSize) Ptr() *FieldSize {
	return &f
}

type NumberConfig struct {
	// Number of decimal places to round data to
	DecimalPlaces *int `json:"decimalPlaces,omitempty" url:"decimalPlaces,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NumberConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberConfig) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Defines a property that should be stored and read as either an integer or floating point number. Database engines should look at the configuration to determine ideal storage format.
type NumberProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool         `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *NumberConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NumberProperty) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberProperty) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Defines an array of values referenced from another sheet. Links should be established automatically by the matching engine or similar upon an evaluation of unique or similar columns between datasets.
type ReferenceListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool                        `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *ReferenceListPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferenceListProperty) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceListProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceListProperty) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferenceListPropertyConfig struct {
	// Full path reference to a sheet configuration. Must be in the same workbook.
	Ref string `json:"ref" url:"ref"`
	// Key of the property to use as the reference key. Defaults to `id`
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferenceListPropertyConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceListPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceListPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceListPropertyConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceListPropertyConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines a reference to another sheet. Links should be established automatically by the matching engine or similar upon an evaluation of unique or similar columns between datasets.
type ReferenceProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool                    `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *ReferencePropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferenceProperty) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceProperty) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencePropertyConfig struct {
	// Full path reference to a sheet configuration. Must be in the same workbook.
	Ref string `json:"ref" url:"ref"`
	// Key of the property to use as the reference key. Defaults to `id`
	Key string `json:"key" url:"key"`
	// The type of relationship this defines
	Relationship *ReferencePropertyRelationship `json:"relationship,omitempty" url:"relationship,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReferencePropertyConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferencePropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencePropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencePropertyConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferencePropertyConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencePropertyRelationship string

const (
	ReferencePropertyRelationshipHasOne  ReferencePropertyRelationship = "has-one"
	ReferencePropertyRelationshipHasMany ReferencePropertyRelationship = "has-many"
)

func NewReferencePropertyRelationshipFromString(s string) (ReferencePropertyRelationship, error) {
	switch s {
	case "has-one":
		return ReferencePropertyRelationshipHasOne, nil
	case "has-many":
		return ReferencePropertyRelationshipHasMany, nil
	}
	var t ReferencePropertyRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReferencePropertyRelationship) Ptr() *ReferencePropertyRelationship {
	return &r
}

type StoredConstraint struct {
	// Must match the constraint validator name.
	Validator string `json:"validator" url:"validator"`
	// The version of the stored constraint to use. (Defaults to version 1.)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A short description of what this constraint configuration does, example - values between 1 and 100
	Description *string     `json:"description,omitempty" url:"description,omitempty"`
	Config      interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StoredConstraint) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StoredConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler StoredConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StoredConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StoredConstraint) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StringConfig struct {
	Size StringConfigOptions `json:"size" url:"size"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StringConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler StringConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// How much text should be storeable in this field
type StringConfigOptions string

const (
	// up to 255 characters
	StringConfigOptionsTiny StringConfigOptions = "tiny"
	// 64kb (default)
	StringConfigOptionsNormal StringConfigOptions = "normal"
	// 16mb
	StringConfigOptionsMedium StringConfigOptions = "medium"
	// 4gb
	StringConfigOptionsLong StringConfigOptions = "long"
)

func NewStringConfigOptionsFromString(s string) (StringConfigOptions, error) {
	switch s {
	case "tiny":
		return StringConfigOptionsTiny, nil
	case "normal":
		return StringConfigOptionsNormal, nil
	case "medium":
		return StringConfigOptionsMedium, nil
	case "long":
		return StringConfigOptionsLong, nil
	}
	var t StringConfigOptions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StringConfigOptions) Ptr() *StringConfigOptions {
	return &s
}

// Defines a property that should be stored and read as an array of strings. Database engines should expect any number of items to be provided here. The maximum number of items that can be in this list is `100`.
type StringListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StringListProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler StringListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringListProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringListProperty) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines a property that should be stored and read as a basic string. Database engines should expect any length of text to be provided here unless explicitly defined in the config.
type StringProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string      `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string      `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *StringConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StringProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler StringProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringProperty) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UniqueConstraint struct {
	Config *UniqueConstraintConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UniqueConstraint) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UniqueConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler UniqueConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UniqueConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UniqueConstraint) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UniqueConstraintConfig struct {
	// Ignore casing when determining uniqueness
	CaseSensitive *bool `json:"caseSensitive,omitempty" url:"caseSensitive,omitempty"`
	// Do not flag empty values as duplicate
	IgnoreEmpty *bool `json:"ignoreEmpty,omitempty" url:"ignoreEmpty,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UniqueConstraintConfig) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UniqueConstraintConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler UniqueConstraintConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UniqueConstraintConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UniqueConstraintConfig) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// CellConfig
type CellConfig struct {
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CellConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CellConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CellConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CellConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CellValue struct {
	Valid    *bool                `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// Deprecated, use record level metadata instead.
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value     *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer     *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CellValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CellValue) UnmarshalJSON(data []byte) error {
	type embed CellValue
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CellValue(unmarshaler.embed)
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellValue) MarshalJSON() ([]byte, error) {
	type embed CellValue
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CellValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CellValueWithLinks struct {
	Valid    *bool                `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// Deprecated, use record level metadata instead.
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value     *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer     *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	Links     *Records               `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CellValueWithLinks) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CellValueWithLinks) UnmarshalJSON(data []byte) error {
	type embed CellValueWithLinks
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CellValueWithLinks(unmarshaler.embed)
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellValueWithLinks) MarshalJSON() ([]byte, error) {
	type embed CellValueWithLinks
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CellValueWithLinks) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DiffData = map[string]*DiffValue

type DiffRecord struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`
	Values   DiffData               `json:"values,omitempty" url:"values,omitempty"`
	Resolves []*Resolve             `json:"resolves,omitempty" url:"resolves,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DiffRecord) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiffRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler DiffRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiffRecord(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffRecord) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// List of DiffRecord objects
type DiffRecords = []*DiffRecord

type DiffRecordsResponse struct {
	Data DiffRecords `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DiffRecordsResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiffRecordsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DiffRecordsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiffRecordsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffRecordsResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DiffValue struct {
	Valid    *bool                `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// Deprecated, use record level metadata instead.
	Metadata      map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value         *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer         *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt     *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	SnapshotValue *CellValueUnion        `json:"snapshotValue,omitempty" url:"snapshotValue,omitempty"`
	ClipValue     *CellValueUnion        `json:"clipValue,omitempty" url:"clipValue,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DiffValue) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiffValue) UnmarshalJSON(data []byte) error {
	type embed DiffValue
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DiffValue(unmarshaler.embed)
	d.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiffValue) MarshalJSON() ([]byte, error) {
	type embed DiffValue
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*d),
		UpdatedAt: core.NewOptionalDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DiffValue) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type FieldRecordCounts struct {
	Total int `json:"total" url:"total"`
	Valid int `json:"valid" url:"valid"`
	Error int `json:"error" url:"error"`
	Empty int `json:"empty" url:"empty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FieldRecordCounts) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldRecordCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldRecordCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldRecordCounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldRecordCounts) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A list of records with optional record counts
type GetRecordsResponseData struct {
	Success bool             `json:"success" url:"success"`
	Records RecordsWithLinks `json:"records,omitempty" url:"records,omitempty"`
	Counts  *RecordCounts    `json:"counts,omitempty" url:"counts,omitempty"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetRecordsResponseData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetRecordsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetRecordsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetRecordsResponseData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetRecordsResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A single row of data in a Sheet
type Record struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`
	Values   RecordData             `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Record) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Record) UnmarshalJSON(data []byte) error {
	type unmarshaler Record
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Record(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Record) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordBase struct {
	Id RecordId `json:"id" url:"id"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Auto-generated value based on whether the record contains a field with an error message. Cannot be set via the API.
	Valid *bool `json:"valid,omitempty" url:"valid,omitempty"`
	// This record level `messages` property is deprecated and no longer stored or used. Use the `messages` property on the individual cell values instead. This property will be removed in a future release.
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordBase) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordBase) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordBase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordBase) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Configuration of a record or specific fields in the record
type RecordConfig struct {
	Readonly          *bool                  `json:"readonly,omitempty" url:"readonly,omitempty"`
	Fields            map[string]*CellConfig `json:"fields,omitempty" url:"fields,omitempty"`
	MarkedForDeletion *bool                  `json:"markedForDeletion,omitempty" url:"markedForDeletion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordConfig) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordCounts struct {
	Total         int            `json:"total" url:"total"`
	Valid         int            `json:"valid" url:"valid"`
	Error         int            `json:"error" url:"error"`
	ErrorsByField map[string]int `json:"errorsByField,omitempty" url:"errorsByField,omitempty"`
	// Counts for valid, error, and total records grouped by field key
	ByField map[string]*FieldRecordCounts `json:"byField,omitempty" url:"byField,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordCounts) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordCounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordCounts) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A single row of data in a Sheet
type RecordData = map[string]*CellValue

// A single row of data in a Sheet, including links to related rows
type RecordDataWithLinks = map[string]*CellValueWithLinks

// A single row of data in a Sheet, including links to related rows
type RecordWithLinks struct {
	Id       RecordId               `json:"id" url:"id"`
	Values   RecordDataWithLinks    `json:"values,omitempty" url:"values,omitempty"`
	Valid    *bool                  `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage   `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Config   *RecordConfig          `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordWithLinks) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordWithLinks) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordWithLinks
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordWithLinks(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordWithLinks) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// List of Record objects
type Records = []*Record

type RecordsResponse struct {
	Data *RecordsResponseData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordsResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordsResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecordsResponseData struct {
	Success bool              `json:"success" url:"success"`
	Records *RecordsWithLinks `json:"records,omitempty" url:"records,omitempty"`
	Counts  *RecordCounts     `json:"counts,omitempty" url:"counts,omitempty"`
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordsResponseData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordsResponseData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordsResponseData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// List of Record objects, including links to related rows
type RecordsWithLinks = []*RecordWithLinks

// Record data validation messages
type ValidationMessage struct {
	Field   *string           `json:"field,omitempty" url:"field,omitempty"`
	Type    *ValidationType   `json:"type,omitempty" url:"type,omitempty"`
	Source  *ValidationSource `json:"source,omitempty" url:"source,omitempty"`
	Message *string           `json:"message,omitempty" url:"message,omitempty"`
	// This JSONPath is based on the root of mapped cell object.
	Path *JsonPathString `json:"path,omitempty" url:"path,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *ValidationMessage) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationMessage) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationSource string

const (
	ValidationSourceRequiredConstraint ValidationSource = "required-constraint"
	ValidationSourceUniqueConstraint   ValidationSource = "unique-constraint"
	ValidationSourceCustomLogic        ValidationSource = "custom-logic"
	ValidationSourceUnlinked           ValidationSource = "unlinked"
	ValidationSourceInvalidOption      ValidationSource = "invalid-option"
	ValidationSourceIsArtifact         ValidationSource = "is-artifact"
)

func NewValidationSourceFromString(s string) (ValidationSource, error) {
	switch s {
	case "required-constraint":
		return ValidationSourceRequiredConstraint, nil
	case "unique-constraint":
		return ValidationSourceUniqueConstraint, nil
	case "custom-logic":
		return ValidationSourceCustomLogic, nil
	case "unlinked":
		return ValidationSourceUnlinked, nil
	case "invalid-option":
		return ValidationSourceInvalidOption, nil
	case "is-artifact":
		return ValidationSourceIsArtifact, nil
	}
	var t ValidationSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v ValidationSource) Ptr() *ValidationSource {
	return &v
}

type ValidationType string

const (
	ValidationTypeError ValidationType = "error"
	ValidationTypeWarn  ValidationType = "warn"
	ValidationTypeInfo  ValidationType = "info"
)

func NewValidationTypeFromString(s string) (ValidationType, error) {
	switch s {
	case "error":
		return ValidationTypeError, nil
	case "warn":
		return ValidationTypeWarn, nil
	case "info":
		return ValidationTypeInfo, nil
	}
	var t ValidationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v ValidationType) Ptr() *ValidationType {
	return &v
}

type ActorRoleResponse struct {
	Id         ActorRoleId      `json:"id" url:"id"`
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ActorId    *ActorIdUnion    `json:"actorId,omitempty" url:"actorId,omitempty"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`
	CreatedAt  time.Time        `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time        `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActorRoleResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActorRoleResponse) UnmarshalJSON(data []byte) error {
	type embed ActorRoleResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ActorRoleResponse(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActorRoleResponse) MarshalJSON() ([]byte, error) {
	type embed ActorRoleResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ActorRoleResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignActorRoleRequest struct {
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssignActorRoleRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssignActorRoleRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AssignActorRoleRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssignActorRoleRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignActorRoleRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignRoleResponse struct {
	Data *AssignRoleResponseData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssignRoleResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssignRoleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AssignRoleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssignRoleResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignRoleResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignRoleResponseData struct {
	Id         ActorRoleId      `json:"id" url:"id"`
	RoleId     RoleId           `json:"roleId" url:"roleId"`
	ActorId    *ActorIdUnion    `json:"actorId,omitempty" url:"actorId,omitempty"`
	ResourceId *ResourceIdUnion `json:"resourceId,omitempty" url:"resourceId,omitempty"`
	CreatedAt  time.Time        `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time        `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssignRoleResponseData) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssignRoleResponseData) UnmarshalJSON(data []byte) error {
	type embed AssignRoleResponseData
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssignRoleResponseData(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignRoleResponseData) MarshalJSON() ([]byte, error) {
	type embed AssignRoleResponseData
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *AssignRoleResponseData) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ListActorRolesResponse struct {
	Data []*ActorRoleResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListActorRolesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListActorRolesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListActorRolesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListActorRolesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListActorRolesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ResourceIdUnion struct {
	AccountId     AccountId
	EnvironmentId EnvironmentId
	SpaceId       SpaceId

	typ string
}

func NewResourceIdUnionFromAccountId(value AccountId) *ResourceIdUnion {
	return &ResourceIdUnion{typ: "AccountId", AccountId: value}
}

func NewResourceIdUnionFromEnvironmentId(value EnvironmentId) *ResourceIdUnion {
	return &ResourceIdUnion{typ: "EnvironmentId", EnvironmentId: value}
}

func NewResourceIdUnionFromSpaceId(value SpaceId) *ResourceIdUnion {
	return &ResourceIdUnion{typ: "SpaceId", SpaceId: value}
}

func (r *ResourceIdUnion) UnmarshalJSON(data []byte) error {
	var valueAccountId AccountId
	if err := json.Unmarshal(data, &valueAccountId); err == nil {
		r.typ = "AccountId"
		r.AccountId = valueAccountId
		return nil
	}
	var valueEnvironmentId EnvironmentId
	if err := json.Unmarshal(data, &valueEnvironmentId); err == nil {
		r.typ = "EnvironmentId"
		r.EnvironmentId = valueEnvironmentId
		return nil
	}
	var valueSpaceId SpaceId
	if err := json.Unmarshal(data, &valueSpaceId); err == nil {
		r.typ = "SpaceId"
		r.SpaceId = valueSpaceId
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r ResourceIdUnion) MarshalJSON() ([]byte, error) {
	if r.typ == "AccountId" || r.AccountId != "" {
		return json.Marshal(r.AccountId)
	}
	if r.typ == "EnvironmentId" || r.EnvironmentId != "" {
		return json.Marshal(r.EnvironmentId)
	}
	if r.typ == "SpaceId" || r.SpaceId != "" {
		return json.Marshal(r.SpaceId)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type ResourceIdUnionVisitor interface {
	VisitAccountId(AccountId) error
	VisitEnvironmentId(EnvironmentId) error
	VisitSpaceId(SpaceId) error
}

func (r *ResourceIdUnion) Accept(visitor ResourceIdUnionVisitor) error {
	if r.typ == "AccountId" || r.AccountId != "" {
		return visitor.VisitAccountId(r.AccountId)
	}
	if r.typ == "EnvironmentId" || r.EnvironmentId != "" {
		return visitor.VisitEnvironmentId(r.EnvironmentId)
	}
	if r.typ == "SpaceId" || r.SpaceId != "" {
		return visitor.VisitSpaceId(r.SpaceId)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RoleResponse struct {
	Id        RoleId    `json:"id" url:"id"`
	Name      string    `json:"name" url:"name"`
	AccountId AccountId `json:"accountId" url:"accountId"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleResponse) UnmarshalJSON(data []byte) error {
	type embed RoleResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RoleResponse(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleResponse) MarshalJSON() ([]byte, error) {
	type embed RoleResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (r *RoleResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The value of a secret
type Secret struct {
	// The reference name for a secret.
	Name SecretName `json:"name" url:"name"`
	// The secret value. This is hidden in the UI.
	Value SecretValue `json:"value" url:"value"`
	// The Environment of the secret.
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The Space of the secret.
	SpaceId *SpaceId `json:"spaceId,omitempty" url:"spaceId,omitempty"`
	// The Actor of the secret.
	ActorId *ActorIdUnion `json:"actorId,omitempty" url:"actorId,omitempty"`
	// The ID of the secret.
	Id SecretId `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Secret) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Secret) UnmarshalJSON(data []byte) error {
	type unmarshaler Secret
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Secret(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Secret) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The name of a secret. Minimum 1 character, maximum 1024
type SecretName = string

// The value of a secret. Minimum 1 character, maximum 1024
type SecretValue = string

type CellValueWithCounts struct {
	Valid    *bool                `json:"valid,omitempty" url:"valid,omitempty"`
	Messages []*ValidationMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// Deprecated, use record level metadata instead.
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Value     *CellValueUnion        `json:"value,omitempty" url:"value,omitempty"`
	Layer     *string                `json:"layer,omitempty" url:"layer,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	Counts    *RecordCounts          `json:"counts,omitempty" url:"counts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CellValueWithCounts) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CellValueWithCounts) UnmarshalJSON(data []byte) error {
	type embed CellValueWithCounts
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CellValueWithCounts(unmarshaler.embed)
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CellValueWithCounts) MarshalJSON() ([]byte, error) {
	type embed CellValueWithCounts
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CellValueWithCounts) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Cell values grouped by field key
type CellsResponseData = map[string][]*CellValueWithCounts

type CompositeUniqueConstraint struct {
	// The name of the constraint
	Name string `json:"name" url:"name"`
	// The fields that must be unique together
	Fields []string `json:"fields,omitempty" url:"fields,omitempty"`
	// Fields that, when empty, will cause this unique constraint to be ignored
	RequiredFields []string                          `json:"requiredFields,omitempty" url:"requiredFields,omitempty"`
	Strategy       CompositeUniqueConstraintStrategy `json:"strategy" url:"strategy"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CompositeUniqueConstraint) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompositeUniqueConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler CompositeUniqueConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompositeUniqueConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompositeUniqueConstraint) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CompositeUniqueConstraintStrategy string

const (
	// A hash of the fields will be used to determine uniqueness
	CompositeUniqueConstraintStrategyHash CompositeUniqueConstraintStrategy = "hash"
	// The values of the fields will be concatenated to determine uniqueness
	CompositeUniqueConstraintStrategyConcat CompositeUniqueConstraintStrategy = "concat"
)

func NewCompositeUniqueConstraintStrategyFromString(s string) (CompositeUniqueConstraintStrategy, error) {
	switch s {
	case "hash":
		return CompositeUniqueConstraintStrategyHash, nil
	case "concat":
		return CompositeUniqueConstraintStrategyConcat, nil
	}
	var t CompositeUniqueConstraintStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CompositeUniqueConstraintStrategy) Ptr() *CompositeUniqueConstraintStrategy {
	return &c
}

type ExternalSheetConstraint struct {
	Validator string `json:"validator" url:"validator"`
	// The fields that must be unique together
	Fields []string    `json:"fields,omitempty" url:"fields,omitempty"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExternalSheetConstraint) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalSheetConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalSheetConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalSheetConstraint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalSheetConstraint) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ListSheetsResponse struct {
	Data []*Sheet `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListSheetsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSheetsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSheetsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSheetsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSheetsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type RecordCountsResponseData struct {
	Counts  *RecordCounts `json:"counts,omitempty" url:"counts,omitempty"`
	Success bool          `json:"success" url:"success"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RecordCountsResponseData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RecordCountsResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler RecordCountsResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecordCountsResponseData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecordCountsResponseData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A place to store tabular data
type Sheet struct {
	// The ID of the Sheet.
	Id SheetId `json:"id" url:"id"`
	// The ID of the Workbook.
	WorkbookId WorkbookId `json:"workbookId" url:"workbookId"`
	// The name of the Sheet.
	Name string `json:"name" url:"name"`
	// The slug of the Sheet.
	Slug string `json:"slug" url:"slug"`
	// Describes shape of data as well as behavior
	Config *SheetConfig `json:"config,omitempty" url:"config,omitempty"`
	// Useful for any contextual metadata regarding the sheet. Store any valid json
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The scoped namespace of the Sheet.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// The actor who locked the Sheet.
	LockedBy *string `json:"lockedBy,omitempty" url:"lockedBy,omitempty"`
	// Date the sheet was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date the sheet was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The time the Sheet was locked.
	LockedAt *time.Time `json:"lockedAt,omitempty" url:"lockedAt,omitempty"`
	// The precomputed counts of records in the Sheet (may not exist).
	RecordCounts *RecordCounts `json:"recordCounts,omitempty" url:"recordCounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Sheet) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Sheet) UnmarshalJSON(data []byte) error {
	type embed Sheet
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		LockedAt  *core.DateTime `json:"lockedAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Sheet(unmarshaler.embed)
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.LockedAt = unmarshaler.LockedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Sheet) MarshalJSON() ([]byte, error) {
	type embed Sheet
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		LockedAt  *core.DateTime `json:"lockedAt,omitempty"`
	}{
		embed:     embed(*s),
		UpdatedAt: core.NewDateTime(s.UpdatedAt),
		CreatedAt: core.NewDateTime(s.CreatedAt),
		LockedAt:  core.NewOptionalDateTime(s.LockedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Sheet) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SheetAccess string

const (
	SheetAccessAll    SheetAccess = "*"
	SheetAccessAdd    SheetAccess = "add"
	SheetAccessEdit   SheetAccess = "edit"
	SheetAccessDelete SheetAccess = "delete"
	SheetAccessImport SheetAccess = "import"
)

func NewSheetAccessFromString(s string) (SheetAccess, error) {
	switch s {
	case "*":
		return SheetAccessAll, nil
	case "add":
		return SheetAccessAdd, nil
	case "edit":
		return SheetAccessEdit, nil
	case "delete":
		return SheetAccessDelete, nil
	case "import":
		return SheetAccessImport, nil
	}
	var t SheetAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SheetAccess) Ptr() *SheetAccess {
	return &s
}

// Describes shape of data as well as behavior
type SheetConfig struct {
	// The name of your Sheet as it will appear to your end users.
	Name string `json:"name" url:"name"`
	// A sentence or two describing the purpose of your Sheet.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A unique identifier for your Sheet.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// A boolean specifying whether or not this sheet is read only. Read only sheets are not editable by end users.
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`
	// Allow end users to add fields during mapping.
	AllowAdditionalFields *bool `json:"allowAdditionalFields,omitempty" url:"allowAdditionalFields,omitempty"`
	// The minimum confidence required to automatically map a field
	MappingConfidenceThreshold *float64 `json:"mappingConfidenceThreshold,omitempty" url:"mappingConfidenceThreshold,omitempty"`
	// Control Sheet-level access for all users.
	Access []SheetAccess `json:"access,omitempty" url:"access,omitempty"`
	// Where you define your Sheet’s data schema.
	Fields []*Property `json:"fields,omitempty" url:"fields,omitempty"`
	// An array of actions that end users can perform on this Sheet.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// An array of constraints that end users can perform on this Sheet.
	Constraints []*SheetConstraint `json:"constraints,omitempty" url:"constraints,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SheetConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SheetConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SheetConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SheetConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SheetConfigOrUpdate struct {
	// The name of your Sheet as it will appear to your end users.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A sentence or two describing the purpose of your Sheet.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A unique identifier for your Sheet. **Required when updating a Workbook.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// A boolean specifying whether or not this sheet is read only. Read only sheets are not editable by end users.
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`
	// Allow end users to add fields during mapping.
	AllowAdditionalFields *bool `json:"allowAdditionalFields,omitempty" url:"allowAdditionalFields,omitempty"`
	// The minimum confidence required to automatically map a field
	MappingConfidenceThreshold *float64 `json:"mappingConfidenceThreshold,omitempty" url:"mappingConfidenceThreshold,omitempty"`
	// Control Sheet-level access for all users.
	Access []SheetAccess `json:"access,omitempty" url:"access,omitempty"`
	// Where you define your Sheet’s data schema.
	Fields []*Property `json:"fields,omitempty" url:"fields,omitempty"`
	// An array of actions that end users can perform on this Sheet.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// The ID of the Sheet.
	Id *SheetId `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the Workbook.
	WorkbookId *WorkbookId `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	// Describes shape of data as well as behavior.
	Config *SheetConfig `json:"config,omitempty" url:"config,omitempty"`
	// Useful for any contextual metadata regarding the sheet. Store any valid json
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The scoped namespace of the Sheet.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Date the sheet was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// Date the sheet was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SheetConfigOrUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SheetConfigOrUpdate) UnmarshalJSON(data []byte) error {
	type embed SheetConfigOrUpdate
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SheetConfigOrUpdate(unmarshaler.embed)
	s.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetConfigOrUpdate) MarshalJSON() ([]byte, error) {
	type embed SheetConfigOrUpdate
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*s),
		UpdatedAt: core.NewOptionalDateTime(s.UpdatedAt),
		CreatedAt: core.NewOptionalDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *SheetConfigOrUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Changes to make to an existing sheet config
type SheetConfigUpdate struct {
	// The name of your Sheet as it will appear to your end users.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A sentence or two describing the purpose of your Sheet.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A unique identifier for your Sheet. **Required when updating a Workbook.**
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// A boolean specifying whether or not this sheet is read only. Read only sheets are not editable by end users.
	Readonly *bool `json:"readonly,omitempty" url:"readonly,omitempty"`
	// Allow end users to add fields during mapping.
	AllowAdditionalFields *bool `json:"allowAdditionalFields,omitempty" url:"allowAdditionalFields,omitempty"`
	// The minimum confidence required to automatically map a field
	MappingConfidenceThreshold *float64 `json:"mappingConfidenceThreshold,omitempty" url:"mappingConfidenceThreshold,omitempty"`
	// Control Sheet-level access for all users.
	Access []SheetAccess `json:"access,omitempty" url:"access,omitempty"`
	// Where you define your Sheet’s data schema.
	Fields []*Property `json:"fields,omitempty" url:"fields,omitempty"`
	// An array of actions that end users can perform on this Sheet.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SheetConfigUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SheetConfigUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler SheetConfigUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SheetConfigUpdate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetConfigUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SheetConstraint struct {
	Type     string
	Unique   *CompositeUniqueConstraint
	External *ExternalSheetConstraint
}

func NewSheetConstraintFromUnique(value *CompositeUniqueConstraint) *SheetConstraint {
	return &SheetConstraint{Type: "unique", Unique: value}
}

func NewSheetConstraintFromExternal(value *ExternalSheetConstraint) *SheetConstraint {
	return &SheetConstraint{Type: "external", External: value}
}

func (s *SheetConstraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "unique":
		value := new(CompositeUniqueConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Unique = value
	case "external":
		value := new(ExternalSheetConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.External = value
	}
	return nil
}

func (s SheetConstraint) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "unique":
		return core.MarshalJSONWithExtraProperty(s.Unique, "type", "unique")
	case "external":
		return core.MarshalJSONWithExtraProperty(s.External, "type", "external")
	}
}

type SheetConstraintVisitor interface {
	VisitUnique(*CompositeUniqueConstraint) error
	VisitExternal(*ExternalSheetConstraint) error
}

func (s *SheetConstraint) Accept(visitor SheetConstraintVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "unique":
		return visitor.VisitUnique(s.Unique)
	case "external":
		return visitor.VisitExternal(s.External)
	}
}

// Changes to make to an existing sheet
type SheetUpdate struct {
	// The ID of the Sheet.
	Id *SheetId `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the Workbook.
	WorkbookId *WorkbookId `json:"workbookId,omitempty" url:"workbookId,omitempty"`
	// Describes shape of data as well as behavior.
	Config *SheetConfig `json:"config,omitempty" url:"config,omitempty"`
	// Useful for any contextual metadata regarding the sheet. Store any valid json
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The scoped namespace of the Sheet.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Date the sheet was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// Date the sheet was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SheetUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SheetUpdate) UnmarshalJSON(data []byte) error {
	type embed SheetUpdate
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SheetUpdate(unmarshaler.embed)
	s.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SheetUpdate) MarshalJSON() ([]byte, error) {
	type embed SheetUpdate
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*s),
		UpdatedAt: core.NewOptionalDateTime(s.UpdatedAt),
		CreatedAt: core.NewOptionalDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *SheetUpdate) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SchemaDiffData = map[string]SchemaDiffEnum

type SchemaDiffEnum string

const (
	SchemaDiffEnumAdded     SchemaDiffEnum = "added"
	SchemaDiffEnumRemoved   SchemaDiffEnum = "removed"
	SchemaDiffEnumUnchanged SchemaDiffEnum = "unchanged"
)

func NewSchemaDiffEnumFromString(s string) (SchemaDiffEnum, error) {
	switch s {
	case "added":
		return SchemaDiffEnumAdded, nil
	case "removed":
		return SchemaDiffEnumRemoved, nil
	case "unchanged":
		return SchemaDiffEnumUnchanged, nil
	}
	var t SchemaDiffEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SchemaDiffEnum) Ptr() *SchemaDiffEnum {
	return &s
}

type SchemaDiffRecord = SchemaDiffData

type Snapshot struct {
	// The ID of the Snapshot.
	Id SnapshotId `json:"id" url:"id"`
	// The ID of the Sheet.
	SheetId SheetId `json:"sheetId" url:"sheetId"`
	// The title of the Snapshot.
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A summary of the Snapshot. This field is only available on the single get snapshot endpoint. It is not available for the list snapshots endpoint.
	Summary *SnapshotSummary `json:"summary,omitempty" url:"summary,omitempty"`
	// The time the Snapshot was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The actor who created the Snapshot.
	CreatedBy UserId `json:"createdBy" url:"createdBy"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Snapshot) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Snapshot) UnmarshalJSON(data []byte) error {
	type embed Snapshot
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Snapshot(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Snapshot) MarshalJSON() ([]byte, error) {
	type embed Snapshot
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Snapshot) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SnapshotSummary struct {
	CreatedSince *SummarySection `json:"createdSince,omitempty" url:"createdSince,omitempty"`
	UpdatedSince *SummarySection `json:"updatedSince,omitempty" url:"updatedSince,omitempty"`
	DeletedSince *SummarySection `json:"deletedSince,omitempty" url:"deletedSince,omitempty"`
	// The schema diff between the snapshot and the current sheet schema.
	SchemaDiff SchemaDiffRecord `json:"schemaDiff,omitempty" url:"schemaDiff,omitempty"`
	// The sheet configuration at the time of the snapshot.
	Config *SheetConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SnapshotSummary) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SnapshotSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler SnapshotSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SnapshotSummary(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SnapshotSummary) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SummarySection struct {
	Total   int            `json:"total" url:"total"`
	ByField map[string]int `json:"byField,omitempty" url:"byField,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SummarySection) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SummarySection) UnmarshalJSON(data []byte) error {
	type unmarshaler SummarySection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummarySection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummarySection) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Properties used to allow users to connect to the event bus
type EventToken struct {
	// The ID of the Account.
	AccountId *AccountId `json:"accountId,omitempty" url:"accountId,omitempty"`
	// The id of the event bus to subscribe to
	SubscribeKey *string `json:"subscribeKey,omitempty" url:"subscribeKey,omitempty"`
	// Time to live in minutes
	Ttl *int `json:"ttl,omitempty" url:"ttl,omitempty"`
	// This should be your API key.
	Token *string `json:"token,omitempty" url:"token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventToken) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventToken) UnmarshalJSON(data []byte) error {
	type unmarshaler EventToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventToken(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventToken) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventTokenResponse struct {
	Data *EventToken `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventTokenResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTokenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTokenResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type InternalSpaceConfigBase struct {
	SpaceConfigId *SpaceConfigId `json:"spaceConfigId,omitempty" url:"spaceConfigId,omitempty"`
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The ID of the primary workbook for the space. This should not be included in create space requests.
	PrimaryWorkbookId *WorkbookId `json:"primaryWorkbookId,omitempty" url:"primaryWorkbookId,omitempty"`
	// Metadata for the space
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The Space settings.
	Settings         *SpaceSettings `json:"settings,omitempty" url:"settings,omitempty"`
	Actions          []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Access           []SpaceAccess  `json:"access,omitempty" url:"access,omitempty"`
	AutoConfigure    *bool          `json:"autoConfigure,omitempty" url:"autoConfigure,omitempty"`
	Namespace        *string        `json:"namespace,omitempty" url:"namespace,omitempty"`
	Labels           []string       `json:"labels,omitempty" url:"labels,omitempty"`
	TranslationsPath *string        `json:"translationsPath,omitempty" url:"translationsPath,omitempty"`
	LanguageOverride *string        `json:"languageOverride,omitempty" url:"languageOverride,omitempty"`
	// Date when space was archived
	ArchivedAt *time.Time `json:"archivedAt,omitempty" url:"archivedAt,omitempty"`
	// The ID of the App that space is associated with
	AppId *AppId `json:"appId,omitempty" url:"appId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InternalSpaceConfigBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InternalSpaceConfigBase) UnmarshalJSON(data []byte) error {
	type embed InternalSpaceConfigBase
	var unmarshaler = struct {
		embed
		ArchivedAt *core.DateTime `json:"archivedAt,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InternalSpaceConfigBase(unmarshaler.embed)
	i.ArchivedAt = unmarshaler.ArchivedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InternalSpaceConfigBase) MarshalJSON() ([]byte, error) {
	type embed InternalSpaceConfigBase
	var marshaler = struct {
		embed
		ArchivedAt *core.DateTime `json:"archivedAt,omitempty"`
	}{
		embed:      embed(*i),
		ArchivedAt: core.NewOptionalDateTime(i.ArchivedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InternalSpaceConfigBase) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A place to store your workbooks
type Space struct {
	SpaceConfigId *SpaceConfigId `json:"spaceConfigId,omitempty" url:"spaceConfigId,omitempty"`
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The ID of the primary workbook for the space. This should not be included in create space requests.
	PrimaryWorkbookId *WorkbookId `json:"primaryWorkbookId,omitempty" url:"primaryWorkbookId,omitempty"`
	// Metadata for the space
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The Space settings.
	Settings         *SpaceSettings `json:"settings,omitempty" url:"settings,omitempty"`
	Actions          []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Access           []SpaceAccess  `json:"access,omitempty" url:"access,omitempty"`
	AutoConfigure    *bool          `json:"autoConfigure,omitempty" url:"autoConfigure,omitempty"`
	Namespace        *string        `json:"namespace,omitempty" url:"namespace,omitempty"`
	Labels           []string       `json:"labels,omitempty" url:"labels,omitempty"`
	TranslationsPath *string        `json:"translationsPath,omitempty" url:"translationsPath,omitempty"`
	LanguageOverride *string        `json:"languageOverride,omitempty" url:"languageOverride,omitempty"`
	// Date when space was archived
	ArchivedAt *time.Time `json:"archivedAt,omitempty" url:"archivedAt,omitempty"`
	// The ID of the App that space is associated with
	AppId *AppId  `json:"appId,omitempty" url:"appId,omitempty"`
	Id    SpaceId `json:"id" url:"id"`
	// Amount of workbooks in the space
	WorkbooksCount *int `json:"workbooksCount,omitempty" url:"workbooksCount,omitempty"`
	// Amount of files in the space
	FilesCount      *int    `json:"filesCount,omitempty" url:"filesCount,omitempty"`
	CreatedByUserId *UserId `json:"createdByUserId,omitempty" url:"createdByUserId,omitempty"`
	// User name who created space
	CreatedByUserName *string `json:"createdByUserName,omitempty" url:"createdByUserName,omitempty"`
	// Date when space was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date when space was updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date when space was expired
	ExpiredAt *time.Time `json:"expiredAt,omitempty" url:"expiredAt,omitempty"`
	// This date marks the most recent activity within the space, tracking actions to the second. Activities include creating or updating records in a sheet, uploading files, or modifying a workbook's configuration.
	LastActivityAt *time.Time `json:"lastActivityAt,omitempty" url:"lastActivityAt,omitempty"`
	// Guest link to the space
	GuestLink *string `json:"guestLink,omitempty" url:"guestLink,omitempty"`
	// The name of the space
	Name string `json:"name" url:"name"`
	// The display order
	DisplayOrder *int `json:"displayOrder,omitempty" url:"displayOrder,omitempty"`
	// Access token for the space
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`
	// Flag for collaborative (project) spaces
	IsCollaborative *bool `json:"isCollaborative,omitempty" url:"isCollaborative,omitempty"`
	// Size information for the space
	Size *SpaceSize `json:"size,omitempty" url:"size,omitempty"`
	// Date when the space was upgraded
	UpgradedAt *time.Time `json:"upgradedAt,omitempty" url:"upgradedAt,omitempty"`
	// Type of guest authentication
	GuestAuthentication []GuestAuthenticationEnum `json:"guestAuthentication,omitempty" url:"guestAuthentication,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Space) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Space) UnmarshalJSON(data []byte) error {
	type embed Space
	var unmarshaler = struct {
		embed
		ArchivedAt     *core.DateTime `json:"archivedAt,omitempty"`
		CreatedAt      *core.DateTime `json:"createdAt"`
		UpdatedAt      *core.DateTime `json:"updatedAt"`
		ExpiredAt      *core.DateTime `json:"expiredAt,omitempty"`
		LastActivityAt *core.DateTime `json:"lastActivityAt,omitempty"`
		UpgradedAt     *core.DateTime `json:"upgradedAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Space(unmarshaler.embed)
	s.ArchivedAt = unmarshaler.ArchivedAt.TimePtr()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	s.ExpiredAt = unmarshaler.ExpiredAt.TimePtr()
	s.LastActivityAt = unmarshaler.LastActivityAt.TimePtr()
	s.UpgradedAt = unmarshaler.UpgradedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Space) MarshalJSON() ([]byte, error) {
	type embed Space
	var marshaler = struct {
		embed
		ArchivedAt     *core.DateTime `json:"archivedAt,omitempty"`
		CreatedAt      *core.DateTime `json:"createdAt"`
		UpdatedAt      *core.DateTime `json:"updatedAt"`
		ExpiredAt      *core.DateTime `json:"expiredAt,omitempty"`
		LastActivityAt *core.DateTime `json:"lastActivityAt,omitempty"`
		UpgradedAt     *core.DateTime `json:"upgradedAt,omitempty"`
	}{
		embed:          embed(*s),
		ArchivedAt:     core.NewOptionalDateTime(s.ArchivedAt),
		CreatedAt:      core.NewDateTime(s.CreatedAt),
		UpdatedAt:      core.NewDateTime(s.UpdatedAt),
		ExpiredAt:      core.NewOptionalDateTime(s.ExpiredAt),
		LastActivityAt: core.NewOptionalDateTime(s.LastActivityAt),
		UpgradedAt:     core.NewOptionalDateTime(s.UpgradedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Space) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpaceAccess string

const (
	SpaceAccessAll    SpaceAccess = "*"
	SpaceAccessUpload SpaceAccess = "upload"
)

func NewSpaceAccessFromString(s string) (SpaceAccess, error) {
	switch s {
	case "*":
		return SpaceAccessAll, nil
	case "upload":
		return SpaceAccessUpload, nil
	}
	var t SpaceAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SpaceAccess) Ptr() *SpaceAccess {
	return &s
}

// Settings for a space
type SpaceSettings struct {
	// The sidebar configuration for the space. (This will eventually replace metadata.sidebarconfig)
	SidebarConfig *SpaceSidebarConfig `json:"sidebarConfig,omitempty" url:"sidebarConfig,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SpaceSettings) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpaceSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSettings) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpaceSidebarConfig struct {
	// Used to set the order of workbooks in the sidebar. This will not affect workbooks that are pinned and workbooks that are not specified here will be sorted alphabetically.
	WorkbookSidebarOrder []WorkbookId `json:"workbookSidebarOrder,omitempty" url:"workbookSidebarOrder,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SpaceSidebarConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpaceSidebarConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSidebarConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSidebarConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSidebarConfig) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The size of a space
type SpaceSize struct {
	Name     string `json:"name" url:"name"`
	Id       string `json:"id" url:"id"`
	NumUsers int    `json:"numUsers" url:"numUsers"`
	Pdv      int    `json:"pdv" url:"pdv"`
	NumFiles int    `json:"numFiles" url:"numFiles"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SpaceSize) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpaceSize) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSize
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSize(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSize) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configurations for the user
type User struct {
	Email      string                 `json:"email" url:"email"`
	Name       string                 `json:"name" url:"name"`
	AccountId  AccountId              `json:"accountId" url:"accountId"`
	Id         UserId                 `json:"id" url:"id"`
	Idp        string                 `json:"idp" url:"idp"`
	IdpRef     *string                `json:"idpRef,omitempty" url:"idpRef,omitempty"`
	Metadata   map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt  time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time              `json:"updatedAt" url:"updatedAt"`
	LastSeenAt *time.Time             `json:"lastSeenAt,omitempty" url:"lastSeenAt,omitempty"`
	Dashboard  *int                   `json:"dashboard,omitempty" url:"dashboard,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type embed User
	var unmarshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = User(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()
	u.LastSeenAt = unmarshaler.LastSeenAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed:      embed(*u),
		CreatedAt:  core.NewDateTime(u.CreatedAt),
		UpdatedAt:  core.NewDateTime(u.UpdatedAt),
		LastSeenAt: core.NewOptionalDateTime(u.LastSeenAt),
	}
	return json.Marshal(marshaler)
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserResponse struct {
	Data *User `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserWithRoles struct {
	Email      string                 `json:"email" url:"email"`
	Name       string                 `json:"name" url:"name"`
	AccountId  AccountId              `json:"accountId" url:"accountId"`
	Id         UserId                 `json:"id" url:"id"`
	Idp        string                 `json:"idp" url:"idp"`
	IdpRef     *string                `json:"idpRef,omitempty" url:"idpRef,omitempty"`
	Metadata   map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt  time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time              `json:"updatedAt" url:"updatedAt"`
	LastSeenAt *time.Time             `json:"lastSeenAt,omitempty" url:"lastSeenAt,omitempty"`
	Dashboard  *int                   `json:"dashboard,omitempty" url:"dashboard,omitempty"`
	ActorRoles []*ActorRoleResponse   `json:"actorRoles,omitempty" url:"actorRoles,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserWithRoles) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserWithRoles) UnmarshalJSON(data []byte) error {
	type embed UserWithRoles
	var unmarshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserWithRoles(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()
	u.LastSeenAt = unmarshaler.LastSeenAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserWithRoles) MarshalJSON() ([]byte, error) {
	type embed UserWithRoles
	var marshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"createdAt"`
		UpdatedAt  *core.DateTime `json:"updatedAt"`
		LastSeenAt *core.DateTime `json:"lastSeenAt,omitempty"`
	}{
		embed:      embed(*u),
		CreatedAt:  core.NewDateTime(u.CreatedAt),
		UpdatedAt:  core.NewDateTime(u.UpdatedAt),
		LastSeenAt: core.NewOptionalDateTime(u.LastSeenAt),
	}
	return json.Marshal(marshaler)
}

func (u *UserWithRoles) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type Version struct {
	VersionId VersionId `json:"versionId" url:"versionId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *Version) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *Version) UnmarshalJSON(data []byte) error {
	type unmarshaler Version
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = Version(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *Version) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VersionResponse struct {
	Data *Version `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VersionResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VersionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VersionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VersionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VersionResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// A view
type View struct {
	// The ID of the view
	Id ViewId `json:"id" url:"id"`
	// The associated sheet ID of the view
	SheetId SheetId `json:"sheetId" url:"sheetId"`
	// The name of the view
	Name string `json:"name" url:"name"`
	// The view filters of the view
	Config *ViewConfig `json:"config,omitempty" url:"config,omitempty"`
	// ID of the actor who created the view
	CreatedBy string `json:"createdBy" url:"createdBy"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *View) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *View) UnmarshalJSON(data []byte) error {
	type unmarshaler View
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = View(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *View) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The configuration of a view. Filters, sorting, and search query.
type ViewConfig struct {
	// Deprecated, use `commitId` instead.
	VersionId *VersionId `json:"versionId,omitempty" url:"versionId,omitempty"`
	CommitId  *CommitId  `json:"commitId,omitempty" url:"commitId,omitempty"`
	// Deprecated, use `sinceCommitId` instead.
	SinceVersionId *VersionId     `json:"sinceVersionId,omitempty" url:"sinceVersionId,omitempty"`
	SinceCommitId  *CommitId      `json:"sinceCommitId,omitempty" url:"sinceCommitId,omitempty"`
	SortField      *SortField     `json:"sortField,omitempty" url:"sortField,omitempty"`
	SortDirection  *SortDirection `json:"sortDirection,omitempty" url:"sortDirection,omitempty"`
	Filter         *Filter        `json:"filter,omitempty" url:"filter,omitempty"`
	// Name of field by which to filter records
	FilterField *FilterField `json:"filterField,omitempty" url:"filterField,omitempty"`
	SearchValue *SearchValue `json:"searchValue,omitempty" url:"searchValue,omitempty"`
	SearchField *SearchField `json:"searchField,omitempty" url:"searchField,omitempty"`
	// The Record Ids param (ids) is a list of record ids that can be passed to several record endpoints allowing the user to identify specific records to INCLUDE in the query, or specific records to EXCLUDE, depending on whether or not filters are being applied. When passing a query param that filters the record dataset, such as 'searchValue', or a 'filter' of 'valid' | 'error' | 'all', the 'ids' param will EXCLUDE those records from the filtered results. For basic queries that do not filter the dataset, passing record ids in the 'ids' param will limit the dataset to INCLUDE just those specific records. Maximum of 100 allowed.
	Ids []RecordId `json:"ids,omitempty" url:"ids,omitempty"`
	// Number of records to return in a page (default 10,000)
	PageSize *int `json:"pageSize,omitempty" url:"pageSize,omitempty"`
	// Based on pageSize, which page of records to return (Note - numbers start at 1)
	PageNumber *int `json:"pageNumber,omitempty" url:"pageNumber,omitempty"`
	// **DEPRECATED** Use GET /sheets/:sheetId/counts
	IncludeCounts *bool `json:"includeCounts,omitempty" url:"includeCounts,omitempty"`
	// The length of the record result set, returned as counts.total
	IncludeLength *bool `json:"includeLength,omitempty" url:"includeLength,omitempty"`
	// If true, linked records will be included in the results. Defaults to false.
	IncludeLinks *bool `json:"includeLinks,omitempty" url:"includeLinks,omitempty"`
	// Include error messages, defaults to false.
	IncludeMessages *bool `json:"includeMessages,omitempty" url:"includeMessages,omitempty"`
	// if "for" is provided, the query parameters will be pulled from the event payload
	For *EventId `json:"for,omitempty" url:"for,omitempty"`
	// An FFQL query used to filter the result set
	Q *string `json:"q,omitempty" url:"q,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *ViewConfig) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ViewConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ViewConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ViewConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ViewConfig) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// A collection of one or more sheets
type Workbook struct {
	// ID of the Workbook.
	Id WorkbookId `json:"id" url:"id"`
	// Name of the Workbook.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Associated Space ID of the Workbook.
	SpaceId SpaceId `json:"spaceId" url:"spaceId"`
	// Associated Environment ID of the Workbook.
	EnvironmentId EnvironmentId `json:"environmentId" url:"environmentId"`
	// A list of Sheets associated with the Workbook.
	Sheets []*Sheet `json:"sheets,omitempty" url:"sheets,omitempty"`
	// A list of labels for the Workbook.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// A list of Actions associated with the Workbook.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// The Workbook settings.
	Settings *WorkbookConfigSettings `json:"settings,omitempty" url:"settings,omitempty"`
	// Metadata for the workbook
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Treatments for the workbook
	Treatments []WorkbookTreatments `json:"treatments,omitempty" url:"treatments,omitempty"`
	Namespace  *string              `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Date the workbook was last updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date the workbook was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date the workbook was created
	ExpiredAt *time.Time `json:"expiredAt,omitempty" url:"expiredAt,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *Workbook) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *Workbook) UnmarshalJSON(data []byte) error {
	type embed Workbook
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		ExpiredAt *core.DateTime `json:"expiredAt,omitempty"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = Workbook(unmarshaler.embed)
	w.UpdatedAt = unmarshaler.UpdatedAt.Time()
	w.CreatedAt = unmarshaler.CreatedAt.Time()
	w.ExpiredAt = unmarshaler.ExpiredAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *Workbook) MarshalJSON() ([]byte, error) {
	type embed Workbook
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt"`
		CreatedAt *core.DateTime `json:"createdAt"`
		ExpiredAt *core.DateTime `json:"expiredAt,omitempty"`
	}{
		embed:     embed(*w),
		UpdatedAt: core.NewDateTime(w.UpdatedAt),
		CreatedAt: core.NewDateTime(w.CreatedAt),
		ExpiredAt: core.NewOptionalDateTime(w.ExpiredAt),
	}
	return json.Marshal(marshaler)
}

func (w *Workbook) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Settings for a workbook
type WorkbookConfigSettings struct {
	// Whether to track changes for this workbook. Defaults to false. Tracking changes on a workbook allows for disabling workbook and sheet actions while data in the workbook is still being processed. You must run a recordHook listener if you enable this feature.
	TrackChanges *bool `json:"trackChanges,omitempty" url:"trackChanges,omitempty"`
	// When noMappingRedirect is set to true, dragging a file into a sheet will not redirect to the mapping screen. Defaults to false.
	NoMappingRedirect *bool `json:"noMappingRedirect,omitempty" url:"noMappingRedirect,omitempty"`
	// Used to set the order of sheets in the sidebar. Sheets that are not specified will be shown after those listed.
	SheetSidebarOrder []SheetId `json:"sheetSidebarOrder,omitempty" url:"sheetSidebarOrder,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WorkbookConfigSettings) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkbookConfigSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkbookConfigSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkbookConfigSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkbookConfigSettings) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Available treatments for a workbook
type WorkbookTreatments string

const (
	WorkbookTreatmentsExtractedFromSource WorkbookTreatments = "EXTRACTED_FROM_SOURCE"
	WorkbookTreatmentsSmallData           WorkbookTreatments = "SMALL_DATA"
)

func NewWorkbookTreatmentsFromString(s string) (WorkbookTreatments, error) {
	switch s {
	case "EXTRACTED_FROM_SOURCE":
		return WorkbookTreatmentsExtractedFromSource, nil
	case "SMALL_DATA":
		return WorkbookTreatmentsSmallData, nil
	}
	var t WorkbookTreatments
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkbookTreatments) Ptr() *WorkbookTreatments {
	return &w
}
