// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/FlatFilers/flatfile-go/core"
)

type CreateNewApiKeyRequest struct {
	EnvironmentId EnvironmentId `json:"-"`
	// API key type (SECRET or PUBLISHABLE)
	Type ApiKeyType `json:"-"`
}

type DeleteApiKeyRequest struct {
	EnvironmentId EnvironmentId `json:"-"`
	Key           ApiKeyId      `json:"-"`
}

type GetApiKeysRequest struct {
	// ID of environment to search
	EnvironmentId EnvironmentId `json:"-"`
}

// Api Key ID
type ApiKeyId = string

type ApiKeyType string

const (
	ApiKeyTypePublishable ApiKeyType = "PUBLISHABLE"
	ApiKeyTypeSecret      ApiKeyType = "SECRET"
)

func NewApiKeyTypeFromString(s string) (ApiKeyType, error) {
	switch s {
	case "PUBLISHABLE":
		return ApiKeyTypePublishable, nil
	case "SECRET":
		return ApiKeyTypeSecret, nil
	}
	var t ApiKeyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApiKeyType) Ptr() *ApiKeyType {
	return &a
}

type ApiKeysResponse struct {
	Data []*ApiKey `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiKeysResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiKeysResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiKeysResponse(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiKeysResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Credentials to authenticate an user
type Credentials struct {
	Type            string
	UserCredentials *UserCredentials
	ApiCredentials  *ApiCredentials
}

func NewCredentialsFromUserCredentials(value *UserCredentials) *Credentials {
	return &Credentials{Type: "userCredentials", UserCredentials: value}
}

func NewCredentialsFromApiCredentials(value *ApiCredentials) *Credentials {
	return &Credentials{Type: "apiCredentials", ApiCredentials: value}
}

func (c *Credentials) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "userCredentials":
		value := new(UserCredentials)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.UserCredentials = value
	case "apiCredentials":
		value := new(ApiCredentials)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ApiCredentials = value
	}
	return nil
}

func (c Credentials) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "userCredentials":
		var marshaler = struct {
			Type string `json:"type"`
			*UserCredentials
		}{
			Type:            c.Type,
			UserCredentials: c.UserCredentials,
		}
		return json.Marshal(marshaler)
	case "apiCredentials":
		var marshaler = struct {
			Type string `json:"type"`
			*ApiCredentials
		}{
			Type:           c.Type,
			ApiCredentials: c.ApiCredentials,
		}
		return json.Marshal(marshaler)
	}
}

type CredentialsVisitor interface {
	VisitUserCredentials(*UserCredentials) error
	VisitApiCredentials(*ApiCredentials) error
}

func (c *Credentials) Accept(visitor CredentialsVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "userCredentials":
		return visitor.VisitUserCredentials(c.UserCredentials)
	case "apiCredentials":
		return visitor.VisitApiCredentials(c.ApiCredentials)
	}
}
