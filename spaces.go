// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/FlatFilers/flatfile-go/internal"
	time "time"
)

type DeleteSpacesRequest struct {
	// List of ids for the spaces to be deleted
	SpaceIds []SpaceId `json:"-" url:"spaceIds"`
}

type GetGuidanceRequest struct {
	// Include the guide with the guidance
	Guide *string `json:"-" url:"guide,omitempty"`
}

type ListSpacesRequest struct {
	// The ID of the environment.
	EnvironmentId *EnvironmentId `json:"-" url:"environmentId,omitempty"`
	// Number of spaces to return in a page (default 10)
	PageSize *int `json:"-" url:"pageSize,omitempty"`
	// Based on pageSize, which page of records to return
	PageNumber *int `json:"-" url:"pageNumber,omitempty"`
	// Search query for spaces
	Search *string `json:"-" url:"search,omitempty"`
	// Search by namespace
	Namespace *string `json:"-" url:"namespace,omitempty"`
	// Flag to include archived spaces
	Archived *bool `json:"-" url:"archived,omitempty"`
	// Field to sort spaces by
	SortField *GetSpacesSortField `json:"-" url:"sortField,omitempty"`
	// Direction of sorting
	SortDirection *SortDirection `json:"-" url:"sortDirection,omitempty"`
	// Flag for collaborative (project) spaces
	IsCollaborative *bool `json:"-" url:"isCollaborative,omitempty"`
	// Filter by appId
	AppId *AppId `json:"-" url:"appId,omitempty"`
	// Flag for app templates
	IsAppTemplate *bool `json:"-" url:"isAppTemplate,omitempty"`
}

type ListGuidanceRequest struct {
	// Include the guide with the guidance
	Guide *string `json:"-" url:"guide,omitempty"`
}

// Properties used to allow users to connect to the event bus
type EventToken struct {
	// The ID of the Account.
	AccountId *AccountId `json:"accountId,omitempty" url:"accountId,omitempty"`
	// The id of the event bus to subscribe to
	SubscribeKey *string `json:"subscribeKey,omitempty" url:"subscribeKey,omitempty"`
	// Time to live in minutes
	Ttl *int `json:"ttl,omitempty" url:"ttl,omitempty"`
	// This should be your API key.
	Token *string `json:"token,omitempty" url:"token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventToken) GetAccountId() *AccountId {
	if e == nil {
		return nil
	}
	return e.AccountId
}

func (e *EventToken) GetSubscribeKey() *string {
	if e == nil {
		return nil
	}
	return e.SubscribeKey
}

func (e *EventToken) GetTtl() *int {
	if e == nil {
		return nil
	}
	return e.Ttl
}

func (e *EventToken) GetToken() *string {
	if e == nil {
		return nil
	}
	return e.Token
}

func (e *EventToken) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventToken) UnmarshalJSON(data []byte) error {
	type unmarshaler EventToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventToken(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventToken) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventTokenResponse struct {
	Data *EventToken `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventTokenResponse) GetData() *EventToken {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EventTokenResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTokenResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type GetSpacesSortField string

const (
	GetSpacesSortFieldName              GetSpacesSortField = "name"
	GetSpacesSortFieldWorkbooksCount    GetSpacesSortField = "workbooksCount"
	GetSpacesSortFieldFilesCount        GetSpacesSortField = "filesCount"
	GetSpacesSortFieldEnvironmentId     GetSpacesSortField = "environmentId"
	GetSpacesSortFieldCreatedByUserName GetSpacesSortField = "createdByUserName"
	GetSpacesSortFieldCreatedAt         GetSpacesSortField = "createdAt"
	GetSpacesSortFieldLastActivityAt    GetSpacesSortField = "lastActivityAt"
)

func NewGetSpacesSortFieldFromString(s string) (GetSpacesSortField, error) {
	switch s {
	case "name":
		return GetSpacesSortFieldName, nil
	case "workbooksCount":
		return GetSpacesSortFieldWorkbooksCount, nil
	case "filesCount":
		return GetSpacesSortFieldFilesCount, nil
	case "environmentId":
		return GetSpacesSortFieldEnvironmentId, nil
	case "createdByUserName":
		return GetSpacesSortFieldCreatedByUserName, nil
	case "createdAt":
		return GetSpacesSortFieldCreatedAt, nil
	case "lastActivityAt":
		return GetSpacesSortFieldLastActivityAt, nil
	}
	var t GetSpacesSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSpacesSortField) Ptr() *GetSpacesSortField {
	return &g
}

type GuidanceApiCreateData struct {
	GuideSlug string `json:"guideSlug" url:"guideSlug"`
	// Options for the guidance
	Options *GuidanceOptions `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GuidanceApiCreateData) GetGuideSlug() string {
	if g == nil {
		return ""
	}
	return g.GuideSlug
}

func (g *GuidanceApiCreateData) GetOptions() *GuidanceOptions {
	if g == nil {
		return nil
	}
	return g.Options
}

func (g *GuidanceApiCreateData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuidanceApiCreateData) UnmarshalJSON(data []byte) error {
	type unmarshaler GuidanceApiCreateData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuidanceApiCreateData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuidanceApiCreateData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuidanceApiUpdateData struct {
	// Options for the guidance
	Options *GuidanceOptions `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GuidanceApiUpdateData) GetOptions() *GuidanceOptions {
	if g == nil {
		return nil
	}
	return g.Options
}

func (g *GuidanceApiUpdateData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuidanceApiUpdateData) UnmarshalJSON(data []byte) error {
	type unmarshaler GuidanceApiUpdateData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuidanceApiUpdateData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuidanceApiUpdateData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuidanceListResponse struct {
	Data []*GuidanceResource `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GuidanceListResponse) GetData() []*GuidanceResource {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GuidanceListResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuidanceListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GuidanceListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuidanceListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuidanceListResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuidanceOptions struct {
	Target  string      `json:"target" url:"target"`
	Trigger TriggerEnum `json:"trigger" url:"trigger"`
	Type    TypeEnum    `json:"type" url:"type"`
	Role    RoleEnum    `json:"role" url:"role"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GuidanceOptions) GetTarget() string {
	if g == nil {
		return ""
	}
	return g.Target
}

func (g *GuidanceOptions) GetTrigger() TriggerEnum {
	if g == nil {
		return ""
	}
	return g.Trigger
}

func (g *GuidanceOptions) GetType() TypeEnum {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GuidanceOptions) GetRole() RoleEnum {
	if g == nil {
		return ""
	}
	return g.Role
}

func (g *GuidanceOptions) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuidanceOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler GuidanceOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuidanceOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuidanceOptions) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuidanceResource struct {
	Id        GuidanceId       `json:"id" url:"id"`
	GuideSlug string           `json:"guideSlug" url:"guideSlug"`
	Options   *GuidanceOptions `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GuidanceResource) GetId() GuidanceId {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GuidanceResource) GetGuideSlug() string {
	if g == nil {
		return ""
	}
	return g.GuideSlug
}

func (g *GuidanceResource) GetOptions() *GuidanceOptions {
	if g == nil {
		return nil
	}
	return g.Options
}

func (g *GuidanceResource) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuidanceResource) UnmarshalJSON(data []byte) error {
	type unmarshaler GuidanceResource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuidanceResource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuidanceResource) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type InternalSpaceConfigBase struct {
	SpaceConfigId *SpaceConfigId `json:"spaceConfigId,omitempty" url:"spaceConfigId,omitempty"`
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The ID of the primary workbook for the space. This should not be included in create space requests.
	PrimaryWorkbookId *WorkbookId `json:"primaryWorkbookId,omitempty" url:"primaryWorkbookId,omitempty"`
	// Metadata for the space
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The Space settings.
	Settings         *SpaceSettings `json:"settings,omitempty" url:"settings,omitempty"`
	Actions          []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Access           []SpaceAccess  `json:"access,omitempty" url:"access,omitempty"`
	AutoConfigure    *bool          `json:"autoConfigure,omitempty" url:"autoConfigure,omitempty"`
	Namespace        *string        `json:"namespace,omitempty" url:"namespace,omitempty"`
	Labels           []string       `json:"labels,omitempty" url:"labels,omitempty"`
	TranslationsPath *string        `json:"translationsPath,omitempty" url:"translationsPath,omitempty"`
	LanguageOverride *string        `json:"languageOverride,omitempty" url:"languageOverride,omitempty"`
	// Date when space was archived
	ArchivedAt *time.Time `json:"archivedAt,omitempty" url:"archivedAt,omitempty"`
	// The ID of the App that space is associated with
	AppId *AppId `json:"appId,omitempty" url:"appId,omitempty"`
	// Whether the space is an app template. Only one space per app can be an app template.
	IsAppTemplate *bool `json:"isAppTemplate,omitempty" url:"isAppTemplate,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InternalSpaceConfigBase) GetSpaceConfigId() *SpaceConfigId {
	if i == nil {
		return nil
	}
	return i.SpaceConfigId
}

func (i *InternalSpaceConfigBase) GetEnvironmentId() *EnvironmentId {
	if i == nil {
		return nil
	}
	return i.EnvironmentId
}

func (i *InternalSpaceConfigBase) GetPrimaryWorkbookId() *WorkbookId {
	if i == nil {
		return nil
	}
	return i.PrimaryWorkbookId
}

func (i *InternalSpaceConfigBase) GetMetadata() interface{} {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InternalSpaceConfigBase) GetSettings() *SpaceSettings {
	if i == nil {
		return nil
	}
	return i.Settings
}

func (i *InternalSpaceConfigBase) GetActions() []*Action {
	if i == nil {
		return nil
	}
	return i.Actions
}

func (i *InternalSpaceConfigBase) GetAccess() []SpaceAccess {
	if i == nil {
		return nil
	}
	return i.Access
}

func (i *InternalSpaceConfigBase) GetAutoConfigure() *bool {
	if i == nil {
		return nil
	}
	return i.AutoConfigure
}

func (i *InternalSpaceConfigBase) GetNamespace() *string {
	if i == nil {
		return nil
	}
	return i.Namespace
}

func (i *InternalSpaceConfigBase) GetLabels() []string {
	if i == nil {
		return nil
	}
	return i.Labels
}

func (i *InternalSpaceConfigBase) GetTranslationsPath() *string {
	if i == nil {
		return nil
	}
	return i.TranslationsPath
}

func (i *InternalSpaceConfigBase) GetLanguageOverride() *string {
	if i == nil {
		return nil
	}
	return i.LanguageOverride
}

func (i *InternalSpaceConfigBase) GetArchivedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.ArchivedAt
}

func (i *InternalSpaceConfigBase) GetAppId() *AppId {
	if i == nil {
		return nil
	}
	return i.AppId
}

func (i *InternalSpaceConfigBase) GetIsAppTemplate() *bool {
	if i == nil {
		return nil
	}
	return i.IsAppTemplate
}

func (i *InternalSpaceConfigBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InternalSpaceConfigBase) UnmarshalJSON(data []byte) error {
	type embed InternalSpaceConfigBase
	var unmarshaler = struct {
		embed
		ArchivedAt *internal.DateTime `json:"archivedAt,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InternalSpaceConfigBase(unmarshaler.embed)
	i.ArchivedAt = unmarshaler.ArchivedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InternalSpaceConfigBase) MarshalJSON() ([]byte, error) {
	type embed InternalSpaceConfigBase
	var marshaler = struct {
		embed
		ArchivedAt *internal.DateTime `json:"archivedAt,omitempty"`
	}{
		embed:      embed(*i),
		ArchivedAt: internal.NewOptionalDateTime(i.ArchivedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InternalSpaceConfigBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// List of Space objects
type ListSpacesResponse struct {
	Pagination *Pagination `json:"pagination,omitempty" url:"pagination,omitempty"`
	Data       []*Space    `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListSpacesResponse) GetPagination() *Pagination {
	if l == nil {
		return nil
	}
	return l.Pagination
}

func (l *ListSpacesResponse) GetData() []*Space {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListSpacesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSpacesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSpacesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSpacesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSpacesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type RoleEnum string

const (
	RoleEnumAdmin RoleEnum = "admin"
	RoleEnumGuest RoleEnum = "guest"
)

func NewRoleEnumFromString(s string) (RoleEnum, error) {
	switch s {
	case "admin":
		return RoleEnumAdmin, nil
	case "guest":
		return RoleEnumGuest, nil
	}
	var t RoleEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoleEnum) Ptr() *RoleEnum {
	return &r
}

// A place to store your workbooks
type Space struct {
	SpaceConfigId *SpaceConfigId `json:"spaceConfigId,omitempty" url:"spaceConfigId,omitempty"`
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The ID of the primary workbook for the space. This should not be included in create space requests.
	PrimaryWorkbookId *WorkbookId `json:"primaryWorkbookId,omitempty" url:"primaryWorkbookId,omitempty"`
	// Metadata for the space
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The Space settings.
	Settings         *SpaceSettings `json:"settings,omitempty" url:"settings,omitempty"`
	Actions          []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Access           []SpaceAccess  `json:"access,omitempty" url:"access,omitempty"`
	AutoConfigure    *bool          `json:"autoConfigure,omitempty" url:"autoConfigure,omitempty"`
	Namespace        *string        `json:"namespace,omitempty" url:"namespace,omitempty"`
	Labels           []string       `json:"labels,omitempty" url:"labels,omitempty"`
	TranslationsPath *string        `json:"translationsPath,omitempty" url:"translationsPath,omitempty"`
	LanguageOverride *string        `json:"languageOverride,omitempty" url:"languageOverride,omitempty"`
	// Date when space was archived
	ArchivedAt *time.Time `json:"archivedAt,omitempty" url:"archivedAt,omitempty"`
	// The ID of the App that space is associated with
	AppId *AppId `json:"appId,omitempty" url:"appId,omitempty"`
	// Whether the space is an app template. Only one space per app can be an app template.
	IsAppTemplate *bool   `json:"isAppTemplate,omitempty" url:"isAppTemplate,omitempty"`
	Id            SpaceId `json:"id" url:"id"`
	// Amount of workbooks in the space
	WorkbooksCount *int `json:"workbooksCount,omitempty" url:"workbooksCount,omitempty"`
	// Amount of files in the space
	FilesCount      *int    `json:"filesCount,omitempty" url:"filesCount,omitempty"`
	CreatedByUserId *UserId `json:"createdByUserId,omitempty" url:"createdByUserId,omitempty"`
	// User name who created space
	CreatedByUserName *string `json:"createdByUserName,omitempty" url:"createdByUserName,omitempty"`
	// Date when space was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Date when space was updated
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Date when space was expired
	ExpiredAt *time.Time `json:"expiredAt,omitempty" url:"expiredAt,omitempty"`
	// This date marks the most recent activity within the space, tracking actions to the second. Activities include creating or updating records in a sheet, uploading files, or modifying a workbook's configuration.
	LastActivityAt *time.Time `json:"lastActivityAt,omitempty" url:"lastActivityAt,omitempty"`
	// Guest link to the space
	GuestLink *string `json:"guestLink,omitempty" url:"guestLink,omitempty"`
	// The name of the space
	Name string `json:"name" url:"name"`
	// The display order
	DisplayOrder *int `json:"displayOrder,omitempty" url:"displayOrder,omitempty"`
	// Access token for the space
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`
	// Flag for collaborative (project) spaces
	IsCollaborative *bool `json:"isCollaborative,omitempty" url:"isCollaborative,omitempty"`
	// Size information for the space
	Size *SpaceSize `json:"size,omitempty" url:"size,omitempty"`
	// Date when the space was upgraded
	UpgradedAt *time.Time `json:"upgradedAt,omitempty" url:"upgradedAt,omitempty"`
	// Type of guest authentication
	GuestAuthentication []GuestAuthenticationEnum `json:"guestAuthentication,omitempty" url:"guestAuthentication,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Space) GetSpaceConfigId() *SpaceConfigId {
	if s == nil {
		return nil
	}
	return s.SpaceConfigId
}

func (s *Space) GetEnvironmentId() *EnvironmentId {
	if s == nil {
		return nil
	}
	return s.EnvironmentId
}

func (s *Space) GetPrimaryWorkbookId() *WorkbookId {
	if s == nil {
		return nil
	}
	return s.PrimaryWorkbookId
}

func (s *Space) GetMetadata() interface{} {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *Space) GetSettings() *SpaceSettings {
	if s == nil {
		return nil
	}
	return s.Settings
}

func (s *Space) GetActions() []*Action {
	if s == nil {
		return nil
	}
	return s.Actions
}

func (s *Space) GetAccess() []SpaceAccess {
	if s == nil {
		return nil
	}
	return s.Access
}

func (s *Space) GetAutoConfigure() *bool {
	if s == nil {
		return nil
	}
	return s.AutoConfigure
}

func (s *Space) GetNamespace() *string {
	if s == nil {
		return nil
	}
	return s.Namespace
}

func (s *Space) GetLabels() []string {
	if s == nil {
		return nil
	}
	return s.Labels
}

func (s *Space) GetTranslationsPath() *string {
	if s == nil {
		return nil
	}
	return s.TranslationsPath
}

func (s *Space) GetLanguageOverride() *string {
	if s == nil {
		return nil
	}
	return s.LanguageOverride
}

func (s *Space) GetArchivedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ArchivedAt
}

func (s *Space) GetAppId() *AppId {
	if s == nil {
		return nil
	}
	return s.AppId
}

func (s *Space) GetIsAppTemplate() *bool {
	if s == nil {
		return nil
	}
	return s.IsAppTemplate
}

func (s *Space) GetId() SpaceId {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *Space) GetWorkbooksCount() *int {
	if s == nil {
		return nil
	}
	return s.WorkbooksCount
}

func (s *Space) GetFilesCount() *int {
	if s == nil {
		return nil
	}
	return s.FilesCount
}

func (s *Space) GetCreatedByUserId() *UserId {
	if s == nil {
		return nil
	}
	return s.CreatedByUserId
}

func (s *Space) GetCreatedByUserName() *string {
	if s == nil {
		return nil
	}
	return s.CreatedByUserName
}

func (s *Space) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *Space) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *Space) GetExpiredAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ExpiredAt
}

func (s *Space) GetLastActivityAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastActivityAt
}

func (s *Space) GetGuestLink() *string {
	if s == nil {
		return nil
	}
	return s.GuestLink
}

func (s *Space) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *Space) GetDisplayOrder() *int {
	if s == nil {
		return nil
	}
	return s.DisplayOrder
}

func (s *Space) GetAccessToken() *string {
	if s == nil {
		return nil
	}
	return s.AccessToken
}

func (s *Space) GetIsCollaborative() *bool {
	if s == nil {
		return nil
	}
	return s.IsCollaborative
}

func (s *Space) GetSize() *SpaceSize {
	if s == nil {
		return nil
	}
	return s.Size
}

func (s *Space) GetUpgradedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.UpgradedAt
}

func (s *Space) GetGuestAuthentication() []GuestAuthenticationEnum {
	if s == nil {
		return nil
	}
	return s.GuestAuthentication
}

func (s *Space) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Space) UnmarshalJSON(data []byte) error {
	type embed Space
	var unmarshaler = struct {
		embed
		ArchivedAt     *internal.DateTime `json:"archivedAt,omitempty"`
		CreatedAt      *internal.DateTime `json:"createdAt"`
		UpdatedAt      *internal.DateTime `json:"updatedAt"`
		ExpiredAt      *internal.DateTime `json:"expiredAt,omitempty"`
		LastActivityAt *internal.DateTime `json:"lastActivityAt,omitempty"`
		UpgradedAt     *internal.DateTime `json:"upgradedAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Space(unmarshaler.embed)
	s.ArchivedAt = unmarshaler.ArchivedAt.TimePtr()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	s.ExpiredAt = unmarshaler.ExpiredAt.TimePtr()
	s.LastActivityAt = unmarshaler.LastActivityAt.TimePtr()
	s.UpgradedAt = unmarshaler.UpgradedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Space) MarshalJSON() ([]byte, error) {
	type embed Space
	var marshaler = struct {
		embed
		ArchivedAt     *internal.DateTime `json:"archivedAt,omitempty"`
		CreatedAt      *internal.DateTime `json:"createdAt"`
		UpdatedAt      *internal.DateTime `json:"updatedAt"`
		ExpiredAt      *internal.DateTime `json:"expiredAt,omitempty"`
		LastActivityAt *internal.DateTime `json:"lastActivityAt,omitempty"`
		UpgradedAt     *internal.DateTime `json:"upgradedAt,omitempty"`
	}{
		embed:          embed(*s),
		ArchivedAt:     internal.NewOptionalDateTime(s.ArchivedAt),
		CreatedAt:      internal.NewDateTime(s.CreatedAt),
		UpdatedAt:      internal.NewDateTime(s.UpdatedAt),
		ExpiredAt:      internal.NewOptionalDateTime(s.ExpiredAt),
		LastActivityAt: internal.NewOptionalDateTime(s.LastActivityAt),
		UpgradedAt:     internal.NewOptionalDateTime(s.UpgradedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Space) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpaceAccess string

const (
	SpaceAccessAll    SpaceAccess = "*"
	SpaceAccessUpload SpaceAccess = "upload"
)

func NewSpaceAccessFromString(s string) (SpaceAccess, error) {
	switch s {
	case "*":
		return SpaceAccessAll, nil
	case "upload":
		return SpaceAccessUpload, nil
	}
	var t SpaceAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SpaceAccess) Ptr() *SpaceAccess {
	return &s
}

// Properties used to create a new Space
type SpaceConfig struct {
	SpaceConfigId *SpaceConfigId `json:"spaceConfigId,omitempty" url:"spaceConfigId,omitempty"`
	EnvironmentId *EnvironmentId `json:"environmentId,omitempty" url:"environmentId,omitempty"`
	// The ID of the primary workbook for the space. This should not be included in create space requests.
	PrimaryWorkbookId *WorkbookId `json:"primaryWorkbookId,omitempty" url:"primaryWorkbookId,omitempty"`
	// Metadata for the space
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The Space settings.
	Settings         *SpaceSettings `json:"settings,omitempty" url:"settings,omitempty"`
	Actions          []*Action      `json:"actions,omitempty" url:"actions,omitempty"`
	Access           []SpaceAccess  `json:"access,omitempty" url:"access,omitempty"`
	AutoConfigure    *bool          `json:"autoConfigure,omitempty" url:"autoConfigure,omitempty"`
	Namespace        *string        `json:"namespace,omitempty" url:"namespace,omitempty"`
	Labels           []string       `json:"labels,omitempty" url:"labels,omitempty"`
	TranslationsPath *string        `json:"translationsPath,omitempty" url:"translationsPath,omitempty"`
	LanguageOverride *string        `json:"languageOverride,omitempty" url:"languageOverride,omitempty"`
	// Date when space was archived
	ArchivedAt *time.Time `json:"archivedAt,omitempty" url:"archivedAt,omitempty"`
	// The ID of the App that space is associated with
	AppId *AppId `json:"appId,omitempty" url:"appId,omitempty"`
	// Whether the space is an app template. Only one space per app can be an app template.
	IsAppTemplate *bool `json:"isAppTemplate,omitempty" url:"isAppTemplate,omitempty"`
	// The name of the space
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The display order
	DisplayOrder        *int                      `json:"displayOrder,omitempty" url:"displayOrder,omitempty"`
	GuestAuthentication []GuestAuthenticationEnum `json:"guestAuthentication,omitempty" url:"guestAuthentication,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpaceConfig) GetSpaceConfigId() *SpaceConfigId {
	if s == nil {
		return nil
	}
	return s.SpaceConfigId
}

func (s *SpaceConfig) GetEnvironmentId() *EnvironmentId {
	if s == nil {
		return nil
	}
	return s.EnvironmentId
}

func (s *SpaceConfig) GetPrimaryWorkbookId() *WorkbookId {
	if s == nil {
		return nil
	}
	return s.PrimaryWorkbookId
}

func (s *SpaceConfig) GetMetadata() interface{} {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *SpaceConfig) GetSettings() *SpaceSettings {
	if s == nil {
		return nil
	}
	return s.Settings
}

func (s *SpaceConfig) GetActions() []*Action {
	if s == nil {
		return nil
	}
	return s.Actions
}

func (s *SpaceConfig) GetAccess() []SpaceAccess {
	if s == nil {
		return nil
	}
	return s.Access
}

func (s *SpaceConfig) GetAutoConfigure() *bool {
	if s == nil {
		return nil
	}
	return s.AutoConfigure
}

func (s *SpaceConfig) GetNamespace() *string {
	if s == nil {
		return nil
	}
	return s.Namespace
}

func (s *SpaceConfig) GetLabels() []string {
	if s == nil {
		return nil
	}
	return s.Labels
}

func (s *SpaceConfig) GetTranslationsPath() *string {
	if s == nil {
		return nil
	}
	return s.TranslationsPath
}

func (s *SpaceConfig) GetLanguageOverride() *string {
	if s == nil {
		return nil
	}
	return s.LanguageOverride
}

func (s *SpaceConfig) GetArchivedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ArchivedAt
}

func (s *SpaceConfig) GetAppId() *AppId {
	if s == nil {
		return nil
	}
	return s.AppId
}

func (s *SpaceConfig) GetIsAppTemplate() *bool {
	if s == nil {
		return nil
	}
	return s.IsAppTemplate
}

func (s *SpaceConfig) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SpaceConfig) GetDisplayOrder() *int {
	if s == nil {
		return nil
	}
	return s.DisplayOrder
}

func (s *SpaceConfig) GetGuestAuthentication() []GuestAuthenticationEnum {
	if s == nil {
		return nil
	}
	return s.GuestAuthentication
}

func (s *SpaceConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpaceConfig) UnmarshalJSON(data []byte) error {
	type embed SpaceConfig
	var unmarshaler = struct {
		embed
		ArchivedAt *internal.DateTime `json:"archivedAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SpaceConfig(unmarshaler.embed)
	s.ArchivedAt = unmarshaler.ArchivedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceConfig) MarshalJSON() ([]byte, error) {
	type embed SpaceConfig
	var marshaler = struct {
		embed
		ArchivedAt *internal.DateTime `json:"archivedAt,omitempty"`
	}{
		embed:      embed(*s),
		ArchivedAt: internal.NewOptionalDateTime(s.ArchivedAt),
	}
	return json.Marshal(marshaler)
}

func (s *SpaceConfig) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpaceResponse struct {
	Data *Space `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpaceResponse) GetData() *Space {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SpaceResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpaceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Settings for a space
type SpaceSettings struct {
	// The sidebar configuration for the space. (This will eventually replace metadata.sidebarconfig)
	SidebarConfig *SpaceSidebarConfig `json:"sidebarConfig,omitempty" url:"sidebarConfig,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpaceSettings) GetSidebarConfig() *SpaceSidebarConfig {
	if s == nil {
		return nil
	}
	return s.SidebarConfig
}

func (s *SpaceSettings) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpaceSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSettings) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpaceSidebarConfig struct {
	// Used to set the order of workbooks in the sidebar. This will not affect workbooks that are pinned and workbooks that are not specified here will be sorted alphabetically.
	WorkbookSidebarOrder []WorkbookId `json:"workbookSidebarOrder,omitempty" url:"workbookSidebarOrder,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpaceSidebarConfig) GetWorkbookSidebarOrder() []WorkbookId {
	if s == nil {
		return nil
	}
	return s.WorkbookSidebarOrder
}

func (s *SpaceSidebarConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpaceSidebarConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSidebarConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSidebarConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSidebarConfig) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The size of a space
type SpaceSize struct {
	Name     string `json:"name" url:"name"`
	Id       string `json:"id" url:"id"`
	NumUsers int    `json:"numUsers" url:"numUsers"`
	Pdv      int    `json:"pdv" url:"pdv"`
	NumFiles int    `json:"numFiles" url:"numFiles"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpaceSize) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SpaceSize) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SpaceSize) GetNumUsers() int {
	if s == nil {
		return 0
	}
	return s.NumUsers
}

func (s *SpaceSize) GetPdv() int {
	if s == nil {
		return 0
	}
	return s.Pdv
}

func (s *SpaceSize) GetNumFiles() int {
	if s == nil {
		return 0
	}
	return s.NumFiles
}

func (s *SpaceSize) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpaceSize) UnmarshalJSON(data []byte) error {
	type unmarshaler SpaceSize
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpaceSize(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpaceSize) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TriggerEnum string

const (
	TriggerEnumFirst  TriggerEnum = "first"
	TriggerEnumHover  TriggerEnum = "hover"
	TriggerEnumEvent  TriggerEnum = "event"
	TriggerEnumManual TriggerEnum = "manual"
)

func NewTriggerEnumFromString(s string) (TriggerEnum, error) {
	switch s {
	case "first":
		return TriggerEnumFirst, nil
	case "hover":
		return TriggerEnumHover, nil
	case "event":
		return TriggerEnumEvent, nil
	case "manual":
		return TriggerEnumManual, nil
	}
	var t TriggerEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TriggerEnum) Ptr() *TriggerEnum {
	return &t
}

type TypeEnum string

const (
	TypeEnumSidebar TypeEnum = "sidebar"
	TypeEnumPopout  TypeEnum = "popout"
	TypeEnumTooltip TypeEnum = "tooltip"
)

func NewTypeEnumFromString(s string) (TypeEnum, error) {
	switch s {
	case "sidebar":
		return TypeEnumSidebar, nil
	case "popout":
		return TypeEnumPopout, nil
	case "tooltip":
		return TypeEnumTooltip, nil
	}
	var t TypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TypeEnum) Ptr() *TypeEnum {
	return &t
}
