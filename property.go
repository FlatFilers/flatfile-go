// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/FlatFilers/flatfile-go/internal"
)

type ArrayableProperty struct {
	// Will allow multiple values and store as an array
	IsArray *bool `json:"isArray,omitempty" url:"isArray,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ArrayableProperty) GetIsArray() *bool {
	if a == nil {
		return nil
	}
	return a.IsArray
}

func (a *ArrayableProperty) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ArrayableProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ArrayableProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArrayableProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArrayableProperty) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BaseProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseProperty) GetKey() string {
	if b == nil {
		return ""
	}
	return b.Key
}

func (b *BaseProperty) GetLabel() *string {
	if b == nil {
		return nil
	}
	return b.Label
}

func (b *BaseProperty) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BaseProperty) GetConstraints() []*Constraint {
	if b == nil {
		return nil
	}
	return b.Constraints
}

func (b *BaseProperty) GetReadonly() *bool {
	if b == nil {
		return nil
	}
	return b.Readonly
}

func (b *BaseProperty) GetAppearance() *FieldAppearance {
	if b == nil {
		return nil
	}
	return b.Appearance
}

func (b *BaseProperty) GetActions() []*Action {
	if b == nil {
		return nil
	}
	return b.Actions
}

func (b *BaseProperty) GetMetadata() interface{} {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BaseProperty) GetTreatments() []string {
	if b == nil {
		return nil
	}
	return b.Treatments
}

func (b *BaseProperty) GetAlternativeNames() []string {
	if b == nil {
		return nil
	}
	return b.AlternativeNames
}

func (b *BaseProperty) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseProperty) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A `true` or `false` value type. Matching engines should attempt to resolve all common ways of representing this value and it should usually be displayed as a checkbox.
type BooleanProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string               `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string               `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *BooleanPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BooleanProperty) GetKey() string {
	if b == nil {
		return ""
	}
	return b.Key
}

func (b *BooleanProperty) GetLabel() *string {
	if b == nil {
		return nil
	}
	return b.Label
}

func (b *BooleanProperty) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BooleanProperty) GetConstraints() []*Constraint {
	if b == nil {
		return nil
	}
	return b.Constraints
}

func (b *BooleanProperty) GetReadonly() *bool {
	if b == nil {
		return nil
	}
	return b.Readonly
}

func (b *BooleanProperty) GetAppearance() *FieldAppearance {
	if b == nil {
		return nil
	}
	return b.Appearance
}

func (b *BooleanProperty) GetActions() []*Action {
	if b == nil {
		return nil
	}
	return b.Actions
}

func (b *BooleanProperty) GetMetadata() interface{} {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BooleanProperty) GetTreatments() []string {
	if b == nil {
		return nil
	}
	return b.Treatments
}

func (b *BooleanProperty) GetAlternativeNames() []string {
	if b == nil {
		return nil
	}
	return b.AlternativeNames
}

func (b *BooleanProperty) GetConfig() *BooleanPropertyConfig {
	if b == nil {
		return nil
	}
	return b.Config
}

func (b *BooleanProperty) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanProperty) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BooleanPropertyConfig struct {
	// Allow a neither true or false state to be stored as `null`
	AllowIndeterminate bool `json:"allowIndeterminate" url:"allowIndeterminate"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BooleanPropertyConfig) GetAllowIndeterminate() bool {
	if b == nil {
		return false
	}
	return b.AllowIndeterminate
}

func (b *BooleanPropertyConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanPropertyConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanPropertyConfig) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Constraint struct {
	Type     string
	Required interface{}
	Unique   *UniqueConstraint
	Computed interface{}
	External *ExternalConstraint
	Stored   *StoredConstraint
}

func NewConstraintFromRequired(value interface{}) *Constraint {
	return &Constraint{Type: "required", Required: value}
}

func NewConstraintFromUnique(value *UniqueConstraint) *Constraint {
	return &Constraint{Type: "unique", Unique: value}
}

func NewConstraintFromComputed(value interface{}) *Constraint {
	return &Constraint{Type: "computed", Computed: value}
}

func NewConstraintFromExternal(value *ExternalConstraint) *Constraint {
	return &Constraint{Type: "external", External: value}
}

func NewConstraintFromStored(value *StoredConstraint) *Constraint {
	return &Constraint{Type: "stored", Stored: value}
}

func (c *Constraint) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *Constraint) GetRequired() interface{} {
	if c == nil {
		return nil
	}
	return c.Required
}

func (c *Constraint) GetUnique() *UniqueConstraint {
	if c == nil {
		return nil
	}
	return c.Unique
}

func (c *Constraint) GetComputed() interface{} {
	if c == nil {
		return nil
	}
	return c.Computed
}

func (c *Constraint) GetExternal() *ExternalConstraint {
	if c == nil {
		return nil
	}
	return c.External
}

func (c *Constraint) GetStored() *StoredConstraint {
	if c == nil {
		return nil
	}
	return c.Stored
}

func (c *Constraint) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "required":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Required = value
	case "unique":
		value := new(UniqueConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Unique = value
	case "computed":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Computed = value
	case "external":
		value := new(ExternalConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.External = value
	case "stored":
		value := new(StoredConstraint)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Stored = value
	}
	return nil
}

func (c Constraint) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "required":
		var marshaler = struct {
			Type     string      `json:"type"`
			Required interface{} `json:"required,omitempty"`
		}{
			Type:     "required",
			Required: c.Required,
		}
		return json.Marshal(marshaler)
	case "unique":
		return internal.MarshalJSONWithExtraProperty(c.Unique, "type", "unique")
	case "computed":
		var marshaler = struct {
			Type     string      `json:"type"`
			Computed interface{} `json:"computed,omitempty"`
		}{
			Type:     "computed",
			Computed: c.Computed,
		}
		return json.Marshal(marshaler)
	case "external":
		return internal.MarshalJSONWithExtraProperty(c.External, "type", "external")
	case "stored":
		return internal.MarshalJSONWithExtraProperty(c.Stored, "type", "stored")
	}
}

type ConstraintVisitor interface {
	VisitRequired(interface{}) error
	VisitUnique(*UniqueConstraint) error
	VisitComputed(interface{}) error
	VisitExternal(*ExternalConstraint) error
	VisitStored(*StoredConstraint) error
}

func (c *Constraint) Accept(visitor ConstraintVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "required":
		return visitor.VisitRequired(c.Required)
	case "unique":
		return visitor.VisitUnique(c.Unique)
	case "computed":
		return visitor.VisitComputed(c.Computed)
	case "external":
		return visitor.VisitExternal(c.External)
	case "stored":
		return visitor.VisitStored(c.Stored)
	}
}

func (c *Constraint) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Required != nil {
		fields = append(fields, "required")
	}
	if c.Unique != nil {
		fields = append(fields, "unique")
	}
	if c.Computed != nil {
		fields = append(fields, "computed")
	}
	if c.External != nil {
		fields = append(fields, "external")
	}
	if c.Stored != nil {
		fields = append(fields, "stored")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

// Store a field as a GMT date. Data hooks must convert this value into a `YYYY-MM-DD` format in order for it to be considered a valid value. Datetime should be a separate and future supported value as it must consider timezone.
type DateProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DateProperty) GetKey() string {
	if d == nil {
		return ""
	}
	return d.Key
}

func (d *DateProperty) GetLabel() *string {
	if d == nil {
		return nil
	}
	return d.Label
}

func (d *DateProperty) GetDescription() *string {
	if d == nil {
		return nil
	}
	return d.Description
}

func (d *DateProperty) GetConstraints() []*Constraint {
	if d == nil {
		return nil
	}
	return d.Constraints
}

func (d *DateProperty) GetReadonly() *bool {
	if d == nil {
		return nil
	}
	return d.Readonly
}

func (d *DateProperty) GetAppearance() *FieldAppearance {
	if d == nil {
		return nil
	}
	return d.Appearance
}

func (d *DateProperty) GetActions() []*Action {
	if d == nil {
		return nil
	}
	return d.Actions
}

func (d *DateProperty) GetMetadata() interface{} {
	if d == nil {
		return nil
	}
	return d.Metadata
}

func (d *DateProperty) GetTreatments() []string {
	if d == nil {
		return nil
	}
	return d.Treatments
}

func (d *DateProperty) GetAlternativeNames() []string {
	if d == nil {
		return nil
	}
	return d.AlternativeNames
}

func (d *DateProperty) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler DateProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateProperty) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines an array of values selected from an enumerated list of options. Matching tooling attempts to resolve incoming data assigment to a valid option. The maximum number of items that can be in this list is `100`.
type EnumListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string            `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string            `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *EnumPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EnumListProperty) GetKey() string {
	if e == nil {
		return ""
	}
	return e.Key
}

func (e *EnumListProperty) GetLabel() *string {
	if e == nil {
		return nil
	}
	return e.Label
}

func (e *EnumListProperty) GetDescription() *string {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *EnumListProperty) GetConstraints() []*Constraint {
	if e == nil {
		return nil
	}
	return e.Constraints
}

func (e *EnumListProperty) GetReadonly() *bool {
	if e == nil {
		return nil
	}
	return e.Readonly
}

func (e *EnumListProperty) GetAppearance() *FieldAppearance {
	if e == nil {
		return nil
	}
	return e.Appearance
}

func (e *EnumListProperty) GetActions() []*Action {
	if e == nil {
		return nil
	}
	return e.Actions
}

func (e *EnumListProperty) GetMetadata() interface{} {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EnumListProperty) GetTreatments() []string {
	if e == nil {
		return nil
	}
	return e.Treatments
}

func (e *EnumListProperty) GetAlternativeNames() []string {
	if e == nil {
		return nil
	}
	return e.AlternativeNames
}

func (e *EnumListProperty) GetConfig() *EnumPropertyConfig {
	if e == nil {
		return nil
	}
	return e.Config
}

func (e *EnumListProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumListProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumListProperty) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Defines an enumerated list of options for the user to select from. Matching tooling attempts to resolve incoming data assigment to a valid option. The maximum number of options for this list is `100`. For larger lists, users should use the reference or future `lookup` types.
type EnumProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool `json:"isArray,omitempty" url:"isArray,omitempty"`
	// Will allow multiple values and store / provide the values in an array if set. Not all field types support arrays.
	Multi  *bool               `json:"multi,omitempty" url:"multi,omitempty"`
	Config *EnumPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EnumProperty) GetKey() string {
	if e == nil {
		return ""
	}
	return e.Key
}

func (e *EnumProperty) GetLabel() *string {
	if e == nil {
		return nil
	}
	return e.Label
}

func (e *EnumProperty) GetDescription() *string {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *EnumProperty) GetConstraints() []*Constraint {
	if e == nil {
		return nil
	}
	return e.Constraints
}

func (e *EnumProperty) GetReadonly() *bool {
	if e == nil {
		return nil
	}
	return e.Readonly
}

func (e *EnumProperty) GetAppearance() *FieldAppearance {
	if e == nil {
		return nil
	}
	return e.Appearance
}

func (e *EnumProperty) GetActions() []*Action {
	if e == nil {
		return nil
	}
	return e.Actions
}

func (e *EnumProperty) GetMetadata() interface{} {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EnumProperty) GetTreatments() []string {
	if e == nil {
		return nil
	}
	return e.Treatments
}

func (e *EnumProperty) GetAlternativeNames() []string {
	if e == nil {
		return nil
	}
	return e.AlternativeNames
}

func (e *EnumProperty) GetIsArray() *bool {
	if e == nil {
		return nil
	}
	return e.IsArray
}

func (e *EnumProperty) GetMulti() *bool {
	if e == nil {
		return nil
	}
	return e.Multi
}

func (e *EnumProperty) GetConfig() *EnumPropertyConfig {
	if e == nil {
		return nil
	}
	return e.Config
}

func (e *EnumProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumProperty) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertyConfig struct {
	// Permit the user to create new options for this specific field.
	AllowCustom *bool                 `json:"allowCustom,omitempty" url:"allowCustom,omitempty"`
	Options     []*EnumPropertyOption `json:"options,omitempty" url:"options,omitempty"`
	// Sort the options by the value of this property. Defaults to `label`.
	SortBy *EnumPropertySortBy `json:"sortBy,omitempty" url:"sortBy,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EnumPropertyConfig) GetAllowCustom() *bool {
	if e == nil {
		return nil
	}
	return e.AllowCustom
}

func (e *EnumPropertyConfig) GetOptions() []*EnumPropertyOption {
	if e == nil {
		return nil
	}
	return e.Options
}

func (e *EnumPropertyConfig) GetSortBy() *EnumPropertySortBy {
	if e == nil {
		return nil
	}
	return e.SortBy
}

func (e *EnumPropertyConfig) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumPropertyConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumPropertyConfig) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertyOption struct {
	// A visual label for this option
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// An optional color to assign this option
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// A reference pointer to a previously registered icon
	Icon *string `json:"icon,omitempty" url:"icon,omitempty"`
	// An arbitrary JSON object to be associated with this option and made available to hooks
	Meta map[string]interface{} `json:"meta,omitempty" url:"meta,omitempty"`
	// The value or ID of this option. This value will be sent in egress. The type is a string | integer | boolean.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Alternative names to match this enum option to
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// The order of this option in the list. SortBy must be set to `ordinal` to use this.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EnumPropertyOption) GetLabel() *string {
	if e == nil {
		return nil
	}
	return e.Label
}

func (e *EnumPropertyOption) GetDescription() *string {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *EnumPropertyOption) GetColor() *string {
	if e == nil {
		return nil
	}
	return e.Color
}

func (e *EnumPropertyOption) GetIcon() *string {
	if e == nil {
		return nil
	}
	return e.Icon
}

func (e *EnumPropertyOption) GetMeta() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Meta
}

func (e *EnumPropertyOption) GetValue() interface{} {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *EnumPropertyOption) GetAlternativeNames() []string {
	if e == nil {
		return nil
	}
	return e.AlternativeNames
}

func (e *EnumPropertyOption) GetOrdinal() *int {
	if e == nil {
		return nil
	}
	return e.Ordinal
}

func (e *EnumPropertyOption) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumPropertyOption) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumPropertyOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumPropertyOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnumPropertyOption) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EnumPropertySortBy string

const (
	EnumPropertySortByLabel   EnumPropertySortBy = "label"
	EnumPropertySortByValue   EnumPropertySortBy = "value"
	EnumPropertySortByOrdinal EnumPropertySortBy = "ordinal"
)

func NewEnumPropertySortByFromString(s string) (EnumPropertySortBy, error) {
	switch s {
	case "label":
		return EnumPropertySortByLabel, nil
	case "value":
		return EnumPropertySortByValue, nil
	case "ordinal":
		return EnumPropertySortByOrdinal, nil
	}
	var t EnumPropertySortBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnumPropertySortBy) Ptr() *EnumPropertySortBy {
	return &e
}

type ExternalConstraint struct {
	Validator string      `json:"validator" url:"validator"`
	Config    interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExternalConstraint) GetValidator() string {
	if e == nil {
		return ""
	}
	return e.Validator
}

func (e *ExternalConstraint) GetConfig() interface{} {
	if e == nil {
		return nil
	}
	return e.Config
}

func (e *ExternalConstraint) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalConstraint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalConstraint) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Control the appearance of this field when it's displayed in a table or input
type FieldAppearance struct {
	Size *FieldSize `json:"size,omitempty" url:"size,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FieldAppearance) GetSize() *FieldSize {
	if f == nil {
		return nil
	}
	return f.Size
}

func (f *FieldAppearance) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldAppearance) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldAppearance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldAppearance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldAppearance) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The default visual sizing. This sizing may be overridden by a user
type FieldSize string

const (
	FieldSizeXs FieldSize = "xs"
	FieldSizeS  FieldSize = "s"
	FieldSizeM  FieldSize = "m"
	FieldSizeL  FieldSize = "l"
	FieldSizeXl FieldSize = "xl"
)

func NewFieldSizeFromString(s string) (FieldSize, error) {
	switch s {
	case "xs":
		return FieldSizeXs, nil
	case "s":
		return FieldSizeS, nil
	case "m":
		return FieldSizeM, nil
	case "l":
		return FieldSizeL, nil
	case "xl":
		return FieldSizeXl, nil
	}
	var t FieldSize
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldSize) Ptr() *FieldSize {
	return &f
}

type NumberConfig struct {
	// Number of decimal places to round data to
	DecimalPlaces *int `json:"decimalPlaces,omitempty" url:"decimalPlaces,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NumberConfig) GetDecimalPlaces() *int {
	if n == nil {
		return nil
	}
	return n.DecimalPlaces
}

func (n *NumberConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberConfig) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Defines a property that should be stored and read as either an integer or floating point number. Database engines should look at the configuration to determine ideal storage format.
type NumberProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool         `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *NumberConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NumberProperty) GetKey() string {
	if n == nil {
		return ""
	}
	return n.Key
}

func (n *NumberProperty) GetLabel() *string {
	if n == nil {
		return nil
	}
	return n.Label
}

func (n *NumberProperty) GetDescription() *string {
	if n == nil {
		return nil
	}
	return n.Description
}

func (n *NumberProperty) GetConstraints() []*Constraint {
	if n == nil {
		return nil
	}
	return n.Constraints
}

func (n *NumberProperty) GetReadonly() *bool {
	if n == nil {
		return nil
	}
	return n.Readonly
}

func (n *NumberProperty) GetAppearance() *FieldAppearance {
	if n == nil {
		return nil
	}
	return n.Appearance
}

func (n *NumberProperty) GetActions() []*Action {
	if n == nil {
		return nil
	}
	return n.Actions
}

func (n *NumberProperty) GetMetadata() interface{} {
	if n == nil {
		return nil
	}
	return n.Metadata
}

func (n *NumberProperty) GetTreatments() []string {
	if n == nil {
		return nil
	}
	return n.Treatments
}

func (n *NumberProperty) GetAlternativeNames() []string {
	if n == nil {
		return nil
	}
	return n.AlternativeNames
}

func (n *NumberProperty) GetIsArray() *bool {
	if n == nil {
		return nil
	}
	return n.IsArray
}

func (n *NumberProperty) GetConfig() *NumberConfig {
	if n == nil {
		return nil
	}
	return n.Config
}

func (n *NumberProperty) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberProperty) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type Property struct {
	Type          string
	String        *StringProperty
	Number        *NumberProperty
	Boolean       *BooleanProperty
	Date          *DateProperty
	Enum          *EnumProperty
	Reference     *ReferenceProperty
	ReferenceList *ReferenceListProperty
	StringList    *StringListProperty
	EnumList      *EnumListProperty
}

func NewPropertyFromString(value *StringProperty) *Property {
	return &Property{Type: "string", String: value}
}

func NewPropertyFromNumber(value *NumberProperty) *Property {
	return &Property{Type: "number", Number: value}
}

func NewPropertyFromBoolean(value *BooleanProperty) *Property {
	return &Property{Type: "boolean", Boolean: value}
}

func NewPropertyFromDate(value *DateProperty) *Property {
	return &Property{Type: "date", Date: value}
}

func NewPropertyFromEnum(value *EnumProperty) *Property {
	return &Property{Type: "enum", Enum: value}
}

func NewPropertyFromReference(value *ReferenceProperty) *Property {
	return &Property{Type: "reference", Reference: value}
}

func NewPropertyFromReferenceList(value *ReferenceListProperty) *Property {
	return &Property{Type: "reference-list", ReferenceList: value}
}

func NewPropertyFromStringList(value *StringListProperty) *Property {
	return &Property{Type: "string-list", StringList: value}
}

func NewPropertyFromEnumList(value *EnumListProperty) *Property {
	return &Property{Type: "enum-list", EnumList: value}
}

func (p *Property) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *Property) GetString() *StringProperty {
	if p == nil {
		return nil
	}
	return p.String
}

func (p *Property) GetNumber() *NumberProperty {
	if p == nil {
		return nil
	}
	return p.Number
}

func (p *Property) GetBoolean() *BooleanProperty {
	if p == nil {
		return nil
	}
	return p.Boolean
}

func (p *Property) GetDate() *DateProperty {
	if p == nil {
		return nil
	}
	return p.Date
}

func (p *Property) GetEnum() *EnumProperty {
	if p == nil {
		return nil
	}
	return p.Enum
}

func (p *Property) GetReference() *ReferenceProperty {
	if p == nil {
		return nil
	}
	return p.Reference
}

func (p *Property) GetReferenceList() *ReferenceListProperty {
	if p == nil {
		return nil
	}
	return p.ReferenceList
}

func (p *Property) GetStringList() *StringListProperty {
	if p == nil {
		return nil
	}
	return p.StringList
}

func (p *Property) GetEnumList() *EnumListProperty {
	if p == nil {
		return nil
	}
	return p.EnumList
}

func (p *Property) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "string":
		value := new(StringProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.String = value
	case "number":
		value := new(NumberProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Number = value
	case "boolean":
		value := new(BooleanProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Boolean = value
	case "date":
		value := new(DateProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Date = value
	case "enum":
		value := new(EnumProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Enum = value
	case "reference":
		value := new(ReferenceProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Reference = value
	case "reference-list":
		value := new(ReferenceListProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ReferenceList = value
	case "string-list":
		value := new(StringListProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StringList = value
	case "enum-list":
		value := new(EnumListProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EnumList = value
	}
	return nil
}

func (p Property) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "string":
		return internal.MarshalJSONWithExtraProperty(p.String, "type", "string")
	case "number":
		return internal.MarshalJSONWithExtraProperty(p.Number, "type", "number")
	case "boolean":
		return internal.MarshalJSONWithExtraProperty(p.Boolean, "type", "boolean")
	case "date":
		return internal.MarshalJSONWithExtraProperty(p.Date, "type", "date")
	case "enum":
		return internal.MarshalJSONWithExtraProperty(p.Enum, "type", "enum")
	case "reference":
		return internal.MarshalJSONWithExtraProperty(p.Reference, "type", "reference")
	case "reference-list":
		return internal.MarshalJSONWithExtraProperty(p.ReferenceList, "type", "reference-list")
	case "string-list":
		return internal.MarshalJSONWithExtraProperty(p.StringList, "type", "string-list")
	case "enum-list":
		return internal.MarshalJSONWithExtraProperty(p.EnumList, "type", "enum-list")
	}
}

type PropertyVisitor interface {
	VisitString(*StringProperty) error
	VisitNumber(*NumberProperty) error
	VisitBoolean(*BooleanProperty) error
	VisitDate(*DateProperty) error
	VisitEnum(*EnumProperty) error
	VisitReference(*ReferenceProperty) error
	VisitReferenceList(*ReferenceListProperty) error
	VisitStringList(*StringListProperty) error
	VisitEnumList(*EnumListProperty) error
}

func (p *Property) Accept(visitor PropertyVisitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "string":
		return visitor.VisitString(p.String)
	case "number":
		return visitor.VisitNumber(p.Number)
	case "boolean":
		return visitor.VisitBoolean(p.Boolean)
	case "date":
		return visitor.VisitDate(p.Date)
	case "enum":
		return visitor.VisitEnum(p.Enum)
	case "reference":
		return visitor.VisitReference(p.Reference)
	case "reference-list":
		return visitor.VisitReferenceList(p.ReferenceList)
	case "string-list":
		return visitor.VisitStringList(p.StringList)
	case "enum-list":
		return visitor.VisitEnumList(p.EnumList)
	}
}

func (p *Property) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.String != nil {
		fields = append(fields, "string")
	}
	if p.Number != nil {
		fields = append(fields, "number")
	}
	if p.Boolean != nil {
		fields = append(fields, "boolean")
	}
	if p.Date != nil {
		fields = append(fields, "date")
	}
	if p.Enum != nil {
		fields = append(fields, "enum")
	}
	if p.Reference != nil {
		fields = append(fields, "reference")
	}
	if p.ReferenceList != nil {
		fields = append(fields, "reference-list")
	}
	if p.StringList != nil {
		fields = append(fields, "string-list")
	}
	if p.EnumList != nil {
		fields = append(fields, "enum-list")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

// Defines an array of values referenced from another sheet. Links should be established automatically by the matching engine or similar upon an evaluation of unique or similar columns between datasets.
type ReferenceListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool                        `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *ReferenceListPropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReferenceListProperty) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *ReferenceListProperty) GetLabel() *string {
	if r == nil {
		return nil
	}
	return r.Label
}

func (r *ReferenceListProperty) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *ReferenceListProperty) GetConstraints() []*Constraint {
	if r == nil {
		return nil
	}
	return r.Constraints
}

func (r *ReferenceListProperty) GetReadonly() *bool {
	if r == nil {
		return nil
	}
	return r.Readonly
}

func (r *ReferenceListProperty) GetAppearance() *FieldAppearance {
	if r == nil {
		return nil
	}
	return r.Appearance
}

func (r *ReferenceListProperty) GetActions() []*Action {
	if r == nil {
		return nil
	}
	return r.Actions
}

func (r *ReferenceListProperty) GetMetadata() interface{} {
	if r == nil {
		return nil
	}
	return r.Metadata
}

func (r *ReferenceListProperty) GetTreatments() []string {
	if r == nil {
		return nil
	}
	return r.Treatments
}

func (r *ReferenceListProperty) GetAlternativeNames() []string {
	if r == nil {
		return nil
	}
	return r.AlternativeNames
}

func (r *ReferenceListProperty) GetIsArray() *bool {
	if r == nil {
		return nil
	}
	return r.IsArray
}

func (r *ReferenceListProperty) GetConfig() *ReferenceListPropertyConfig {
	if r == nil {
		return nil
	}
	return r.Config
}

func (r *ReferenceListProperty) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceListProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceListProperty) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferenceListPropertyConfig struct {
	// Full path reference to a sheet configuration. Must be in the same workbook.
	Ref string `json:"ref" url:"ref"`
	// Key of the property to use as the reference key. Defaults to `id`
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReferenceListPropertyConfig) GetRef() string {
	if r == nil {
		return ""
	}
	return r.Ref
}

func (r *ReferenceListPropertyConfig) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *ReferenceListPropertyConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceListPropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceListPropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceListPropertyConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceListPropertyConfig) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines a reference to another sheet. Links should be established automatically by the matching engine or similar upon an evaluation of unique or similar columns between datasets.
type ReferenceProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	// Will allow multiple values and store as an array
	IsArray *bool                    `json:"isArray,omitempty" url:"isArray,omitempty"`
	Config  *ReferencePropertyConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReferenceProperty) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *ReferenceProperty) GetLabel() *string {
	if r == nil {
		return nil
	}
	return r.Label
}

func (r *ReferenceProperty) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *ReferenceProperty) GetConstraints() []*Constraint {
	if r == nil {
		return nil
	}
	return r.Constraints
}

func (r *ReferenceProperty) GetReadonly() *bool {
	if r == nil {
		return nil
	}
	return r.Readonly
}

func (r *ReferenceProperty) GetAppearance() *FieldAppearance {
	if r == nil {
		return nil
	}
	return r.Appearance
}

func (r *ReferenceProperty) GetActions() []*Action {
	if r == nil {
		return nil
	}
	return r.Actions
}

func (r *ReferenceProperty) GetMetadata() interface{} {
	if r == nil {
		return nil
	}
	return r.Metadata
}

func (r *ReferenceProperty) GetTreatments() []string {
	if r == nil {
		return nil
	}
	return r.Treatments
}

func (r *ReferenceProperty) GetAlternativeNames() []string {
	if r == nil {
		return nil
	}
	return r.AlternativeNames
}

func (r *ReferenceProperty) GetIsArray() *bool {
	if r == nil {
		return nil
	}
	return r.IsArray
}

func (r *ReferenceProperty) GetConfig() *ReferencePropertyConfig {
	if r == nil {
		return nil
	}
	return r.Config
}

func (r *ReferenceProperty) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferenceProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferenceProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferenceProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferenceProperty) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencePropertyConfig struct {
	// Full path reference to a sheet configuration. Must be in the same workbook.
	Ref string `json:"ref" url:"ref"`
	// Key of the property to use as the reference key. Defaults to `id`
	Key string `json:"key" url:"key"`
	// The type of relationship this defines
	Relationship *ReferencePropertyRelationship `json:"relationship,omitempty" url:"relationship,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReferencePropertyConfig) GetRef() string {
	if r == nil {
		return ""
	}
	return r.Ref
}

func (r *ReferencePropertyConfig) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *ReferencePropertyConfig) GetRelationship() *ReferencePropertyRelationship {
	if r == nil {
		return nil
	}
	return r.Relationship
}

func (r *ReferencePropertyConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferencePropertyConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencePropertyConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencePropertyConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReferencePropertyConfig) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencePropertyRelationship string

const (
	ReferencePropertyRelationshipHasOne  ReferencePropertyRelationship = "has-one"
	ReferencePropertyRelationshipHasMany ReferencePropertyRelationship = "has-many"
)

func NewReferencePropertyRelationshipFromString(s string) (ReferencePropertyRelationship, error) {
	switch s {
	case "has-one":
		return ReferencePropertyRelationshipHasOne, nil
	case "has-many":
		return ReferencePropertyRelationshipHasMany, nil
	}
	var t ReferencePropertyRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReferencePropertyRelationship) Ptr() *ReferencePropertyRelationship {
	return &r
}

type StoredConstraint struct {
	// Must match the constraint validator name.
	Validator string `json:"validator" url:"validator"`
	// The version of the stored constraint to use. (Defaults to version 1.)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A full description of what this constraint configuration does
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A short description of what this constraint constraint should do, example - values between 1 and 100
	Label  *string     `json:"label,omitempty" url:"label,omitempty"`
	Config interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StoredConstraint) GetValidator() string {
	if s == nil {
		return ""
	}
	return s.Validator
}

func (s *StoredConstraint) GetVersion() *int {
	if s == nil {
		return nil
	}
	return s.Version
}

func (s *StoredConstraint) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *StoredConstraint) GetLabel() *string {
	if s == nil {
		return nil
	}
	return s.Label
}

func (s *StoredConstraint) GetConfig() interface{} {
	if s == nil {
		return nil
	}
	return s.Config
}

func (s *StoredConstraint) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StoredConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler StoredConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StoredConstraint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StoredConstraint) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StringConfig struct {
	Size StringConfigOptions `json:"size" url:"size"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StringConfig) GetSize() StringConfigOptions {
	if s == nil {
		return ""
	}
	return s.Size
}

func (s *StringConfig) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler StringConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringConfig) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// How much text should be storeable in this field
type StringConfigOptions string

const (
	// up to 255 characters
	StringConfigOptionsTiny StringConfigOptions = "tiny"
	// 64kb (default)
	StringConfigOptionsNormal StringConfigOptions = "normal"
	// 16mb
	StringConfigOptionsMedium StringConfigOptions = "medium"
	// 4gb
	StringConfigOptionsLong StringConfigOptions = "long"
)

func NewStringConfigOptionsFromString(s string) (StringConfigOptions, error) {
	switch s {
	case "tiny":
		return StringConfigOptionsTiny, nil
	case "normal":
		return StringConfigOptionsNormal, nil
	case "medium":
		return StringConfigOptionsMedium, nil
	case "long":
		return StringConfigOptionsLong, nil
	}
	var t StringConfigOptions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StringConfigOptions) Ptr() *StringConfigOptions {
	return &s
}

// Defines a property that should be stored and read as an array of strings. Database engines should expect any number of items to be provided here. The maximum number of items that can be in this list is `100`.
type StringListProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StringListProperty) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *StringListProperty) GetLabel() *string {
	if s == nil {
		return nil
	}
	return s.Label
}

func (s *StringListProperty) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *StringListProperty) GetConstraints() []*Constraint {
	if s == nil {
		return nil
	}
	return s.Constraints
}

func (s *StringListProperty) GetReadonly() *bool {
	if s == nil {
		return nil
	}
	return s.Readonly
}

func (s *StringListProperty) GetAppearance() *FieldAppearance {
	if s == nil {
		return nil
	}
	return s.Appearance
}

func (s *StringListProperty) GetActions() []*Action {
	if s == nil {
		return nil
	}
	return s.Actions
}

func (s *StringListProperty) GetMetadata() interface{} {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *StringListProperty) GetTreatments() []string {
	if s == nil {
		return nil
	}
	return s.Treatments
}

func (s *StringListProperty) GetAlternativeNames() []string {
	if s == nil {
		return nil
	}
	return s.AlternativeNames
}

func (s *StringListProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringListProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler StringListProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringListProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringListProperty) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines a property that should be stored and read as a basic string. Database engines should expect any length of text to be provided here unless explicitly defined in the config.
type StringProperty struct {
	Key string `json:"key" url:"key"`
	// User friendly field name
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// A short description of the field. Markdown syntax is supported.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// A list of constraints that should be applied to this field. This is limited to a maximum of 10 constraints and all external and stored constraints must have unique validator values.
	Constraints []*Constraint    `json:"constraints,omitempty" url:"constraints,omitempty"`
	Readonly    *bool            `json:"readonly,omitempty" url:"readonly,omitempty"`
	Appearance  *FieldAppearance `json:"appearance,omitempty" url:"appearance,omitempty"`
	// An array of actions that end users can perform on this Column.
	Actions []*Action `json:"actions,omitempty" url:"actions,omitempty"`
	// Useful for any contextual metadata regarding the schema. Store any valid json here.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// A unique presentation for a field in the UI.
	Treatments       []string      `json:"treatments,omitempty" url:"treatments,omitempty"`
	AlternativeNames []string      `json:"alternativeNames,omitempty" url:"alternativeNames,omitempty"`
	Config           *StringConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StringProperty) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *StringProperty) GetLabel() *string {
	if s == nil {
		return nil
	}
	return s.Label
}

func (s *StringProperty) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *StringProperty) GetConstraints() []*Constraint {
	if s == nil {
		return nil
	}
	return s.Constraints
}

func (s *StringProperty) GetReadonly() *bool {
	if s == nil {
		return nil
	}
	return s.Readonly
}

func (s *StringProperty) GetAppearance() *FieldAppearance {
	if s == nil {
		return nil
	}
	return s.Appearance
}

func (s *StringProperty) GetActions() []*Action {
	if s == nil {
		return nil
	}
	return s.Actions
}

func (s *StringProperty) GetMetadata() interface{} {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *StringProperty) GetTreatments() []string {
	if s == nil {
		return nil
	}
	return s.Treatments
}

func (s *StringProperty) GetAlternativeNames() []string {
	if s == nil {
		return nil
	}
	return s.AlternativeNames
}

func (s *StringProperty) GetConfig() *StringConfig {
	if s == nil {
		return nil
	}
	return s.Config
}

func (s *StringProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler StringProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringProperty) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UniqueConstraint struct {
	Config *UniqueConstraintConfig `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UniqueConstraint) GetConfig() *UniqueConstraintConfig {
	if u == nil {
		return nil
	}
	return u.Config
}

func (u *UniqueConstraint) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UniqueConstraint) UnmarshalJSON(data []byte) error {
	type unmarshaler UniqueConstraint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UniqueConstraint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UniqueConstraint) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UniqueConstraintConfig struct {
	// Ignore casing when determining uniqueness
	CaseSensitive *bool `json:"caseSensitive,omitempty" url:"caseSensitive,omitempty"`
	// Do not flag empty values as duplicate
	IgnoreEmpty *bool `json:"ignoreEmpty,omitempty" url:"ignoreEmpty,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UniqueConstraintConfig) GetCaseSensitive() *bool {
	if u == nil {
		return nil
	}
	return u.CaseSensitive
}

func (u *UniqueConstraintConfig) GetIgnoreEmpty() *bool {
	if u == nil {
		return nil
	}
	return u.IgnoreEmpty
}

func (u *UniqueConstraintConfig) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UniqueConstraintConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler UniqueConstraintConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UniqueConstraintConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UniqueConstraintConfig) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
