// This file was auto-generated by Fern from our API Definition.

package jobs

import (
	context "context"
	fmt "fmt"
	flatfilego "github.com/FlatFilers/flatfile-go"
	core "github.com/FlatFilers/flatfile-go/core"
	http "net/http"
	url "net/url"
)

type Client struct {
	baseURL string
	caller  *core.Caller
	header  http.Header
}

func NewClient(opts ...core.ClientOption) *Client {
	options := core.NewClientOptions()
	for _, opt := range opts {
		opt(options)
	}
	return &Client{
		baseURL: options.BaseURL,
		caller:  core.NewCaller(options.HTTPClient),
		header:  options.ToHeader(),
	}
}

func (c *Client) List(ctx context.Context, request *flatfilego.ListJobsRequest) (*flatfilego.ListJobsResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "jobs"

	queryParams := make(url.Values)
	if request.EnvironmentId != nil {
		queryParams.Add("environmentId", fmt.Sprintf("%v", request.EnvironmentId))
	}
	if request.SpaceId != nil {
		queryParams.Add("spaceId", fmt.Sprintf("%v", request.SpaceId))
	}
	if request.WorkbookId != nil {
		queryParams.Add("workbookId", fmt.Sprintf("%v", request.WorkbookId))
	}
	if request.FileId != nil {
		queryParams.Add("fileId", fmt.Sprintf("%v", request.FileId))
	}
	if request.ParentId != nil {
		queryParams.Add("parentId", fmt.Sprintf("%v", request.ParentId))
	}
	if request.PageSize != nil {
		queryParams.Add("pageSize", fmt.Sprintf("%v", *request.PageSize))
	}
	if request.PageNumber != nil {
		queryParams.Add("pageNumber", fmt.Sprintf("%v", *request.PageNumber))
	}
	if request.SortDirection != nil {
		queryParams.Add("sortDirection", fmt.Sprintf("%v", request.SortDirection))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *flatfilego.ListJobsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) Create(ctx context.Context, request *flatfilego.JobConfig) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "jobs"

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) Get(ctx context.Context, jobId flatfilego.JobId) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v", jobId)

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) Update(ctx context.Context, jobId flatfilego.JobId, request *flatfilego.JobUpdate) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v", jobId)

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPatch,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) Delete(ctx context.Context, jobId flatfilego.JobId) (*flatfilego.Success, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v", jobId)

	var response *flatfilego.Success
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodDelete,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Execute a job and return the job
//
// ID of job to return
func (c *Client) Execute(ctx context.Context, jobId string) (*flatfilego.Success, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/execute", jobId)

	var response *flatfilego.Success
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Returns a single job's execution plan
//
// ID of job to return
func (c *Client) GetExecutionPlan(ctx context.Context, jobId flatfilego.JobId) (*flatfilego.JobPlanResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/plan", jobId)

	var response *flatfilego.JobPlanResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Update a job's entire execution plan
//
// ID of job to return
func (c *Client) UpdateExecutionPlan(ctx context.Context, jobId flatfilego.JobId, request *flatfilego.JobExecutionPlanRequest) (*flatfilego.JobPlanResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/plan", jobId)

	var response *flatfilego.JobPlanResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPut,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Update one or more individual fields on a job's execution plan
//
// ID of job to return
func (c *Client) UpdateExecutionPlanFields(ctx context.Context, jobId string, request *flatfilego.JobExecutionPlanConfigRequest) (*flatfilego.JobPlanResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/plan", jobId)

	var response *flatfilego.JobPlanResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPatch,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Acknowledge a job and return the job
//
// ID of job to return
func (c *Client) Ack(ctx context.Context, jobId flatfilego.JobId, request *flatfilego.JobAckDetails) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/ack", jobId)

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Acknowledge a job outcome and return the job
//
// ID of job to return
func (c *Client) AckOutcome(ctx context.Context, jobId flatfilego.JobId) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/outcome/ack", jobId)

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Complete a job and return the job
//
// ID of job to return
func (c *Client) Complete(ctx context.Context, jobId flatfilego.JobId, request *flatfilego.JobCompleteDetails) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/complete", jobId)

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Fail a job and return the job
//
// ID of job to return
func (c *Client) Fail(ctx context.Context, jobId flatfilego.JobId, request *flatfilego.JobCompleteDetails) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/fail", jobId)

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Cancel a job and return the job
//
// ID of job to return
func (c *Client) Cancel(ctx context.Context, jobId flatfilego.JobId, request *flatfilego.JobCancelDetails) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/cancel", jobId)

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Split a job and return the job
//
// ID of job to return
func (c *Client) Split(ctx context.Context, jobId flatfilego.JobId, request *flatfilego.JobSplitDetails) (*flatfilego.JobResponse, error) {
	baseURL := "https://api.x.flatfile.com/v1"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"jobs/%v/split", jobId)

	var response *flatfilego.JobResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}
